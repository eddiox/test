/*! jQuery v3.5.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement("script");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[o.call(e)]||"object":typeof e}var f="3.5.1",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&"length"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}S.fn=S.prototype={jquery:f,constructor:S,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=S.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return S.each(this,e)},map:function(n){return this.pushStack(S.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(S.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(S.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},S.extend=S.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(S.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||S.isPlainObject(n)?n:{},i=!1,a[t]=S.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},S.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==o.call(e))&&(!(t=r(e))||"function"==typeof(n=v.call(t,"constructor")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){b(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(p(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},makeArray:function(e,t){var n=t||[];return null!=e&&(p(Object(e))?S.merge(n,"string"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(p(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:y}),"function"==typeof Symbol&&(S.fn[Symbol.iterator]=t[Symbol.iterator]),S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var d=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,S="sizzle"+1*new Date,p=n.document,k=0,r=0,m=ue(),x=ue(),A=ue(),N=ue(),D=function(e,t){return e===t&&(l=!0),0},j={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",I="(?:\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",W="\\["+M+"*("+I+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+I+"))|)"+M+"*\\]",F=":("+I+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+W+")*)|.*)\\)|)",B=new RegExp(M+"+","g"),$=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=new RegExp("^"+M+"*,"+M+"*"),z=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp(M+"|>"),X=new RegExp(F),V=new RegExp("^"+I+"$"),G={ID:new RegExp("^#("+I+")"),CLASS:new RegExp("^\\.("+I+")"),TAG:new RegExp("^("+I+"|[*])"),ATTR:new RegExp("^"+W),PSEUDO:new RegExp("^"+F),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\d$/i,K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\([^\\r\\n\\f])","g"),ne=function(e,t){var n="0x"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{H.apply(t=O.call(p.childNodes),p.childNodes),t[p.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!N[t+" "]&&(!v||!v.test(t))&&(1!==p||"object"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&(U.test(t)||z.test(t))){(f=ee.test(t)&&ye(e.parentNode)||e)===e&&d.scope||((s=e.getAttribute("id"))?s=s.replace(re,ie):e.setAttribute("id",s=S)),o=(l=h(t)).length;while(o--)l[o]=(s?"#"+s:":scope")+" "+xe(l[o]);c=l.join(",")}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){N(t,!0)}finally{s===S&&e.removeAttribute("id")}}}return g(t.replace($,"$1"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function le(e){return e[S]=!0,e}function ce(e){var t=C.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split("|"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return"input"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return("input"===t||"button"===t)&&e.type===n}}function ge(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e.namespaceURI,n=(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||"HTML")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:p;return r!=C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),p!=C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",oe,!1):n.attachEvent&&n.attachEvent("onunload",oe)),d.scope=ce(function(e){return a.appendChild(e).appendChild(C.createElement("div")),"undefined"!=typeof e.querySelectorAll&&!e.querySelectorAll(":scope fieldset div").length}),d.attributes=ce(function(e){return e.className="i",!e.getAttribute("className")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment("")),!e.getElementsByTagName("*").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=S,!C.getElementsByName||!C.getElementsByName(S).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){var t;a.appendChild(e).innerHTML="<a id='"+S+"'></a><select id='"+S+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&v.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||v.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll("[id~="+S+"-]").length||v.push("~="),(t=C.createElement("input")).setAttribute("name",""),e.appendChild(t),e.querySelectorAll("[name='']").length||v.push("\\["+M+"*name"+M+"*="+M+"*(?:''|\"\")"),e.querySelectorAll(":checked").length||v.push(":checked"),e.querySelectorAll("a#"+S+"+*").length||v.push(".#.+[+~]"),e.querySelectorAll("\\\f"),v.push("[\\r\\n\\f]")}),ce(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=C.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&v.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&v.push(":enabled",":disabled"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&v.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),v.push(",.*:")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,"*"),c.call(e,"[s!='']:x"),s.push("!=",F)}),v=v.length&&new RegExp(v.join("|")),s=s.length&&new RegExp(s.join("|")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e==C||e.ownerDocument==p&&y(p,e)?-1:t==C||t.ownerDocument==p&&y(p,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e==C?-1:t==C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]==p?-1:s[r]==p?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if(T(e),d.matchesSelector&&E&&!N[t+" "]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){N(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!=C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!=C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&j.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+"").replace(re,ie)},se.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(D),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=m[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&m(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace(B," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(h,e,t,g,v){var y="nth"!==h.slice(0,3),m="last"!==h.slice(-4),x="of-type"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?"nextSibling":"previousSibling",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l="only"===h&&!u&&"nextSibling"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[k,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[k,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error("unsupported pseudo: "+e);return a[S]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace($,"$1"));return s[S]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||"")||se.error("unsupported lang: "+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&"parentNode"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[k,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[S]||(e[S]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===k&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[S]&&(v=Ce(v)),y&&!y[S]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace($,"$1"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace($," ")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=A[e+" "];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[S]?i.push(a):o.push(a);(a=A(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=k+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(k=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(k=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=S.split("").sort(D).join("")===S,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement("fieldset"))}),ce(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute("disabled")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);S.find=d,S.expr=d.selectors,S.expr[":"]=S.expr.pseudos,S.uniqueSort=S.unique=d.uniqueSort,S.text=d.getText,S.isXMLDoc=d.isXML,S.contains=d.contains,S.escapeSelector=d.escape;var h=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&S(e).is(n))break;r.push(e)}return r},T=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},k=S.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var N=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function D(e,n,r){return m(n)?S.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?S.grep(e,function(e){return e===n!==r}):"string"!=typeof n?S.grep(e,function(e){return-1<i.call(n,e)!==r}):S.filter(n,e,r)}S.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?S.find.matchesSelector(r,e)?[r]:[]:S.find.matches(e,S.grep(t,function(e){return 1===e.nodeType}))},S.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(S(e).filter(function(){for(t=0;t<r;t++)if(S.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)S.find(e,i[t],n);return 1<r?S.uniqueSort(n):n},filter:function(e){return this.pushStack(D(this,e||[],!1))},not:function(e){return this.pushStack(D(this,e||[],!0))},is:function(e){return!!D(this,"string"==typeof e&&k.test(e)?S(e):e||[],!1).length}});var j,q=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(S.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||j,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:q.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof S?t[0]:t,S.merge(this,S.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),N.test(r[1])&&S.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(S):S.makeArray(e,this)}).prototype=S.fn,j=S(E);var L=/^(?:parents|prev(?:Until|All))/,H={children:!0,contents:!0,next:!0,prev:!0};function O(e,t){while((e=e[t])&&1!==e.nodeType);return e}S.fn.extend({has:function(e){var t=S(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(S.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&S(e);if(!k.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&S.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?S.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?i.call(S(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(S.uniqueSort(S.merge(this.get(),S(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),S.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return h(e,"parentNode")},parentsUntil:function(e,t,n){return h(e,"parentNode",n)},next:function(e){return O(e,"nextSibling")},prev:function(e){return O(e,"previousSibling")},nextAll:function(e){return h(e,"nextSibling")},prevAll:function(e){return h(e,"previousSibling")},nextUntil:function(e,t,n){return h(e,"nextSibling",n)},prevUntil:function(e,t,n){return h(e,"previousSibling",n)},siblings:function(e){return T((e.parentNode||{}).firstChild,e)},children:function(e){return T(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(A(e,"template")&&(e=e.content||e),S.merge([],e.childNodes))}},function(r,i){S.fn[r]=function(e,t){var n=S.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=S.filter(t,n)),1<this.length&&(H[r]||S.uniqueSort(n),L.test(r)&&n.reverse()),this.pushStack(n)}});var P=/[^\x20\t\r\n\f]+/g;function R(e){return e}function M(e){throw e}function I(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}S.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},S.each(e.match(P)||[],function(e,t){n[t]=!0}),n):S.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){S.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return S.each(arguments,function(e,t){var n;while(-1<(n=S.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<S.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},S.extend({Deferred:function(e){var o=[["notify","progress",S.Callbacks("memory"),S.Callbacks("memory"),2],["resolve","done",S.Callbacks("once memory"),S.Callbacks("once memory"),0,"resolved"],["reject","fail",S.Callbacks("once memory"),S.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return S.Deferred(function(r){S.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,R,s),l(u,o,M,s)):(u++,t.call(e,l(u,o,R,s),l(u,o,M,s),l(u,o,R,o.notifyWith))):(a!==R&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){S.Deferred.exceptionHook&&S.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==M&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(S.Deferred.getStackHook&&(t.stackTrace=S.Deferred.getStackHook()),C.setTimeout(t))}}return S.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:R,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:R)),o[2][3].add(l(0,e,m(n)?n:M))}).promise()},promise:function(e){return null!=e?S.extend(e,a):a}},s={};return S.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=S.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(I(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)I(i[t],a(t),o.reject);return o.promise()}});var W=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;S.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&W.test(e.name)&&C.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},S.readyException=function(e){C.setTimeout(function(){throw e})};var F=S.Deferred();function B(){E.removeEventListener("DOMContentLoaded",B),C.removeEventListener("load",B),S.ready()}S.fn.ready=function(e){return F.then(e)["catch"](function(e){S.readyException(e)}),this},S.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--S.readyWait:S.isReady)||(S.isReady=!0)!==e&&0<--S.readyWait||F.resolveWith(E,[S])}}),S.ready.then=F.then,"complete"===E.readyState||"loading"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(S.ready):(E.addEventListener("DOMContentLoaded",B),C.addEventListener("load",B));var $=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===w(n))for(s in i=!0,n)$(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(S(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},_=/^-ms-/,z=/-([a-z])/g;function U(e,t){return t.toUpperCase()}function X(e){return e.replace(_,"ms-").replace(z,U)}var V=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function G(){this.expando=S.expando+G.uid++}G.uid=1,G.prototype={cache:function(e){var t=e[this.expando];return t||(t={},V(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[X(t)]=n;else for(r in t)i[X(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][X(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(X):(t=X(t))in r?[t]:t.match(P)||[]).length;while(n--)delete r[t[n]]}(void 0===t||S.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!S.isEmptyObject(t)}};var Y=new G,Q=new G,J=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,K=/[A-Z]/g;function Z(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(K,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:J.test(i)?JSON.parse(i):i)}catch(e){}Q.set(e,t,n)}else n=void 0;return n}S.extend({hasData:function(e){return Q.hasData(e)||Y.hasData(e)},data:function(e,t,n){return Q.access(e,t,n)},removeData:function(e,t){Q.remove(e,t)},_data:function(e,t,n){return Y.access(e,t,n)},_removeData:function(e,t){Y.remove(e,t)}}),S.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=Q.get(o),1===o.nodeType&&!Y.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=X(r.slice(5)),Z(o,r,i[r]));Y.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){Q.set(this,n)}):$(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=Q.get(o,n))?t:void 0!==(t=Z(o,n))?t:void 0;this.each(function(){Q.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){Q.remove(this,e)})}}),S.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Y.get(e,t),n&&(!r||Array.isArray(n)?r=Y.access(e,t,S.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=S.queue(e,t),r=n.length,i=n.shift(),o=S._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){S.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Y.get(e,n)||Y.access(e,n,{empty:S.Callbacks("once memory").add(function(){Y.remove(e,[t+"queue",n])})})}}),S.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?S.queue(this[0],t):void 0===n?this:this.each(function(){var e=S.queue(this,t,n);S._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&S.dequeue(this,t)})},dequeue:function(e){return this.each(function(){S.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=S.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=Y.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var ee=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,te=new RegExp("^(?:([+-])=|)("+ee+")([a-z%]*)$","i"),ne=["Top","Right","Bottom","Left"],re=E.documentElement,ie=function(e){return S.contains(e.ownerDocument,e)},oe={composed:!0};re.getRootNode&&(ie=function(e){return S.contains(e.ownerDocument,e)||e.getRootNode(oe)===e.ownerDocument});var ae=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&ie(e)&&"none"===S.css(e,"display")};function se(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return S.css(e,t,"")},u=s(),l=n&&n[3]||(S.cssNumber[t]?"":"px"),c=e.nodeType&&(S.cssNumber[t]||"px"!==l&&+u)&&te.exec(S.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)S.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,S.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ue={};function le(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=Y.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&ae(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ue[s])||(o=a.body.appendChild(a.createElement(s)),u=S.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ue[s]=u)))):"none"!==n&&(l[c]="none",Y.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}S.fn.extend({show:function(){return le(this,!0)},hide:function(){return le(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){ae(this)?S(this).show():S(this).hide()})}});var ce,fe,pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,he=/^$|^module$|\/(?:java|ecma)script/i;ce=E.createDocumentFragment().appendChild(E.createElement("div")),(fe=E.createElement("input")).setAttribute("type","radio"),fe.setAttribute("checked","checked"),fe.setAttribute("name","t"),ce.appendChild(fe),y.checkClone=ce.cloneNode(!0).cloneNode(!0).lastChild.checked,ce.innerHTML="<textarea>x</textarea>",y.noCloneChecked=!!ce.cloneNode(!0).lastChild.defaultValue,ce.innerHTML="<option></option>",y.option=!!ce.lastChild;var ge={thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function ve(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&A(e,t)?S.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Y.set(e[n],"globalEval",!t||Y.get(t[n],"globalEval"))}ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td,y.option||(ge.optgroup=ge.option=[1,"<select multiple='multiple'>","</select>"]);var me=/<|&#?\w+;/;function xe(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===w(o))S.merge(p,o.nodeType?[o]:o);else if(me.test(o)){a=a||f.appendChild(t.createElement("div")),s=(de.exec(o)||["",""])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+S.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;S.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<S.inArray(o,r))i&&i.push(o);else if(l=ie(o),a=ve(f.appendChild(o),"script"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||"")&&n.push(o)}return f}var be=/^key/,we=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Te=/^([^.]*)(?:\.(.+)|)/;function Ce(){return!0}function Ee(){return!1}function Se(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==("focus"===t)}function ke(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)ke(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Ee;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return S().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=S.guid++)),e.each(function(){S.event.add(this,t,i,r,n)})}function Ae(e,i,o){o?(Y.set(e,i,!1),S.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Y.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(S.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Y.set(this,i,r),t=o(this,i),this[i](),r!==(n=Y.get(this,i))||t?Y.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n.value}else r.length&&(Y.set(this,i,{value:S.event.trigger(S.extend(r[0],S.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Y.get(e,i)&&S.event.add(e,i,Ce)}S.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.get(t);if(V(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&S.find.matchesSelector(re,i),n.guid||(n.guid=S.guid++),(u=v.events)||(u=v.events=Object.create(null)),(a=v.handle)||(a=v.handle=function(e){return"undefined"!=typeof S&&S.event.triggered!==e.type?S.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(P)||[""]).length;while(l--)d=g=(s=Te.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=S.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=S.event.special[d]||{},c=S.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&S.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),S.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.hasData(e)&&Y.get(e);if(v&&(u=v.events)){l=(t=(t||"").match(P)||[""]).length;while(l--)if(d=g=(s=Te.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=S.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||S.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)S.event.remove(e,d+t[l],n,r,!0);S.isEmptyObject(u)&&Y.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=S.event.fix(e),l=(Y.get(this,"events")||Object.create(null))[u.type]||[],c=S.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=S.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((S.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<S(i,this).index(l):S.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(S.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[S.expando]?e:new S.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Ae(t,"click",Ce),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Ae(t,"click"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,"input")&&Y.get(t,"click")||A(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},S.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},S.Event=function(e,t){if(!(this instanceof S.Event))return new S.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?Ce:Ee,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&S.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[S.expando]=!0},S.Event.prototype={constructor:S.Event,isDefaultPrevented:Ee,isPropagationStopped:Ee,isImmediatePropagationStopped:Ee,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=Ce,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=Ce,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=Ce,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},S.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&be.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&we.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},S.event.addProp),S.each({focus:"focusin",blur:"focusout"},function(e,t){S.event.special[e]={setup:function(){return Ae(this,e,Se),!1},trigger:function(){return Ae(this,e),!0},delegateType:t}}),S.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){S.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||S.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),S.fn.extend({on:function(e,t,n,r){return ke(this,e,t,n,r)},one:function(e,t,n,r){return ke(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,S(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=Ee),this.each(function(){S.event.remove(this,e,n,t)})}});var Ne=/<script|<style|<link/i,De=/checked\s*(?:[^=]|=\s*.checked.)/i,je=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function qe(e,t){return A(e,"table")&&A(11!==t.nodeType?t:t.firstChild,"tr")&&S(e).children("tbody")[0]||e}function Le(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function He(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Oe(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(Y.hasData(e)&&(s=Y.get(e).events))for(i in Y.remove(t,"handle events"),s)for(n=0,r=s[i].length;n<r;n++)S.event.add(t,i,s[i][n]);Q.hasData(e)&&(o=Q.access(e),a=S.extend({},o),Q.set(t,a))}}function Pe(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&"string"==typeof d&&!y.checkClone&&De.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),Pe(t,r,i,o)});if(f&&(t=(e=xe(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=S.map(ve(e,"script"),Le)).length;c<f;c++)u=e,c!==p&&(u=S.clone(u,!0,!0),s&&S.merge(a,ve(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,S.map(a,He),c=0;c<s;c++)u=a[c],he.test(u.type||"")&&!Y.access(u,"globalEval")&&S.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?S._evalUrl&&!u.noModule&&S._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")},l):b(u.textContent.replace(je,""),u,l))}return n}function Re(e,t,n){for(var r,i=t?S.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||S.cleanData(ve(r)),r.parentNode&&(n&&ie(r)&&ye(ve(r,"script")),r.parentNode.removeChild(r));return e}S.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=ie(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||S.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Oe(o[r],a[r]);else Oe(e,c);return 0<(a=ve(c,"script")).length&&ye(a,!f&&ve(e,"script")),c},cleanData:function(e){for(var t,n,r,i=S.event.special,o=0;void 0!==(n=e[o]);o++)if(V(n)){if(t=n[Y.expando]){if(t.events)for(r in t.events)i[r]?S.event.remove(n,r):S.removeEvent(n,r,t.handle);n[Y.expando]=void 0}n[Q.expando]&&(n[Q.expando]=void 0)}}}),S.fn.extend({detach:function(e){return Re(this,e,!0)},remove:function(e){return Re(this,e)},text:function(e){return $(this,function(e){return void 0===e?S.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return Pe(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||qe(this,e).appendChild(e)})},prepend:function(){return Pe(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=qe(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return Pe(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return Pe(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(S.cleanData(ve(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return S.clone(this,e,t)})},html:function(e){return $(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!Ne.test(e)&&!ge[(de.exec(e)||["",""])[1].toLowerCase()]){e=S.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(S.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return Pe(this,arguments,function(e){var t=this.parentNode;S.inArray(this,n)<0&&(S.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),S.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){S.fn[e]=function(e){for(var t,n=[],r=S(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),S(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var Me=new RegExp("^("+ee+")(?!px)[a-z%]+$","i"),Ie=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},We=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},Fe=new RegExp(ne.join("|"),"i");function Be(e,t,n){var r,i,o,a,s=e.style;return(n=n||Ie(e))&&(""!==(a=n.getPropertyValue(t)||n[t])||ie(e)||(a=S.style(e,t)),!y.pixelBoxStyles()&&Me.test(a)&&Fe.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function $e(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",l.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",re.appendChild(u).appendChild(l);var e=C.getComputedStyle(l);n="1%"!==e.top,s=12===t(e.marginLeft),l.style.right="60%",o=36===t(e.right),r=36===t(e.width),l.style.position="absolute",i=12===t(l.offsetWidth/3),re.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=E.createElement("div"),l=E.createElement("div");l.style&&(l.style.backgroundClip="content-box",l.cloneNode(!0).style.backgroundClip="",y.clearCloneStyle="content-box"===l.style.backgroundClip,S.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=E.createElement("table"),t=E.createElement("tr"),n=E.createElement("div"),e.style.cssText="position:absolute;left:-11111px",t.style.height="1px",n.style.height="9px",re.appendChild(e).appendChild(t).appendChild(n),r=C.getComputedStyle(t),a=3<parseInt(r.height),re.removeChild(e)),a}}))}();var _e=["Webkit","Moz","ms"],ze=E.createElement("div").style,Ue={};function Xe(e){var t=S.cssProps[e]||Ue[e];return t||(e in ze?e:Ue[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=_e.length;while(n--)if((e=_e[n]+t)in ze)return e}(e)||e)}var Ve=/^(none|table(?!-c[ea]).+)/,Ge=/^--/,Ye={position:"absolute",visibility:"hidden",display:"block"},Qe={letterSpacing:"0",fontWeight:"400"};function Je(e,t,n){var r=te.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function Ke(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=S.css(e,n+ne[a],!0,i)),r?("content"===n&&(u-=S.css(e,"padding"+ne[a],!0,i)),"margin"!==n&&(u-=S.css(e,"border"+ne[a]+"Width",!0,i))):(u+=S.css(e,"padding"+ne[a],!0,i),"padding"!==n?u+=S.css(e,"border"+ne[a]+"Width",!0,i):s+=S.css(e,"border"+ne[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function Ze(e,t,n){var r=Ie(e),i=(!y.boxSizingReliable()||n)&&"border-box"===S.css(e,"boxSizing",!1,r),o=i,a=Be(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if(Me.test(a)){if(!n)return a;a="auto"}return(!y.boxSizingReliable()&&i||!y.reliableTrDimensions()&&A(e,"tr")||"auto"===a||!parseFloat(a)&&"inline"===S.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===S.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+Ke(e,t,n||(i?"border":"content"),o,r,a)+"px"}function et(e,t,n,r,i){return new et.prototype.init(e,t,n,r,i)}S.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Be(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=X(t),u=Ge.test(t),l=e.style;if(u||(t=Xe(s)),a=S.cssHooks[t]||S.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=te.exec(n))&&i[1]&&(n=se(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(S.cssNumber[s]?"":"px")),y.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=X(t);return Ge.test(t)||(t=Xe(s)),(a=S.cssHooks[t]||S.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=Be(e,t,r)),"normal"===i&&t in Qe&&(i=Qe[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),S.each(["height","width"],function(e,u){S.cssHooks[u]={get:function(e,t,n){if(t)return!Ve.test(S.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?Ze(e,u,n):We(e,Ye,function(){return Ze(e,u,n)})},set:function(e,t,n){var r,i=Ie(e),o=!y.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===S.css(e,"boxSizing",!1,i),s=n?Ke(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-Ke(e,u,"border",!1,i)-.5)),s&&(r=te.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=S.css(e,u)),Je(0,t,s)}}}),S.cssHooks.marginLeft=$e(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(Be(e,"marginLeft"))||e.getBoundingClientRect().left-We(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),S.each({margin:"",padding:"",border:"Width"},function(i,o){S.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+ne[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(S.cssHooks[i+o].set=Je)}),S.fn.extend({css:function(e,t){return $(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Ie(e),i=t.length;a<i;a++)o[t[a]]=S.css(e,t[a],!1,r);return o}return void 0!==n?S.style(e,t,n):S.css(e,t)},e,t,1<arguments.length)}}),((S.Tween=et).prototype={constructor:et,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||S.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(S.cssNumber[n]?"":"px")},cur:function(){var e=et.propHooks[this.prop];return e&&e.get?e.get(this):et.propHooks._default.get(this)},run:function(e){var t,n=et.propHooks[this.prop];return this.options.duration?this.pos=t=S.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):et.propHooks._default.set(this),this}}).init.prototype=et.prototype,(et.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=S.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){S.fx.step[e.prop]?S.fx.step[e.prop](e):1!==e.elem.nodeType||!S.cssHooks[e.prop]&&null==e.elem.style[Xe(e.prop)]?e.elem[e.prop]=e.now:S.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=et.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},S.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},S.fx=et.prototype.init,S.fx.step={};var tt,nt,rt,it,ot=/^(?:toggle|show|hide)$/,at=/queueHooks$/;function st(){nt&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(st):C.setTimeout(st,S.fx.interval),S.fx.tick())}function ut(){return C.setTimeout(function(){tt=void 0}),tt=Date.now()}function lt(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=ne[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function ct(e,t,n){for(var r,i=(ft.tweeners[t]||[]).concat(ft.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function ft(o,e,t){var n,a,r=0,i=ft.prefilters.length,s=S.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=tt||ut(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:S.extend({},e),opts:S.extend(!0,{specialEasing:{},easing:S.easing._default},t),originalProperties:e,originalOptions:t,startTime:tt||ut(),duration:t.duration,tweens:[],createTween:function(e,t){var n=S.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=X(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=S.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=ft.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(S._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return S.map(c,ct,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),S.fx.timer(S.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}S.Animation=S.extend(ft,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return se(n.elem,e,te.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=["*"]):e=e.match(P);for(var n,r=0,i=e.length;r<i;r++)n=e[r],ft.tweeners[n]=ft.tweeners[n]||[],ft.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&ae(e),v=Y.get(e,"fxshow");for(r in n.queue||(null==(a=S._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,S.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],ot.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||S.style(e,r)}if((u=!S.isEmptyObject(t))||!S.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Y.get(e,"display")),"none"===(c=S.css(e,"display"))&&(l?c=l:(le([e],!0),l=e.style.display||l,c=S.css(e,"display"),le([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===S.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=Y.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&le([e],!0),p.done(function(){for(r in g||le([e]),Y.remove(e,"fxshow"),d)S.style(e,r,d[r])})),u=ct(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?ft.prefilters.unshift(e):ft.prefilters.push(e)}}),S.speed=function(e,t,n){var r=e&&"object"==typeof e?S.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return S.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in S.fx.speeds?r.duration=S.fx.speeds[r.duration]:r.duration=S.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&S.dequeue(this,r.queue)},r},S.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ae).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=S.isEmptyObject(t),o=S.speed(e,n,r),a=function(){var e=ft(this,S.extend({},t),o);(i||Y.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=S.timers,r=Y.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&at.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||S.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=Y.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=S.timers,o=n?n.length:0;for(t.finish=!0,S.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),S.each(["toggle","show","hide"],function(e,r){var i=S.fn[r];S.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(lt(r,!0),e,t,n)}}),S.each({slideDown:lt("show"),slideUp:lt("hide"),slideToggle:lt("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){S.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),S.timers=[],S.fx.tick=function(){var e,t=0,n=S.timers;for(tt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||S.fx.stop(),tt=void 0},S.fx.timer=function(e){S.timers.push(e),S.fx.start()},S.fx.interval=13,S.fx.start=function(){nt||(nt=!0,st())},S.fx.stop=function(){nt=null},S.fx.speeds={slow:600,fast:200,_default:400},S.fn.delay=function(r,e){return r=S.fx&&S.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},rt=E.createElement("input"),it=E.createElement("select").appendChild(E.createElement("option")),rt.type="checkbox",y.checkOn=""!==rt.value,y.optSelected=it.selected,(rt=E.createElement("input")).value="t",rt.type="radio",y.radioValue="t"===rt.value;var pt,dt=S.expr.attrHandle;S.fn.extend({attr:function(e,t){return $(this,S.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){S.removeAttr(this,e)})}}),S.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?S.prop(e,t,n):(1===o&&S.isXMLDoc(e)||(i=S.attrHooks[t.toLowerCase()]||(S.expr.match.bool.test(t)?pt:void 0)),void 0!==n?null===n?void S.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=S.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&"radio"===t&&A(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(P);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),pt={set:function(e,t,n){return!1===t?S.removeAttr(e,n):e.setAttribute(n,n),n}},S.each(S.expr.match.bool.source.match(/\w+/g),function(e,t){var a=dt[t]||S.find.attr;dt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=dt[o],dt[o]=r,r=null!=a(e,t,n)?o:null,dt[o]=i),r}});var ht=/^(?:input|select|textarea|button)$/i,gt=/^(?:a|area)$/i;function vt(e){return(e.match(P)||[]).join(" ")}function yt(e){return e.getAttribute&&e.getAttribute("class")||""}function mt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(P)||[]}S.fn.extend({prop:function(e,t){return $(this,S.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[S.propFix[e]||e]})}}),S.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&S.isXMLDoc(e)||(t=S.propFix[t]||t,i=S.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=S.find.attr(e,"tabindex");return t?parseInt(t,10):ht.test(e.nodeName)||gt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),y.optSelected||(S.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),S.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){S.propFix[this.toLowerCase()]=this}),S.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).addClass(t.call(this,e,yt(this)))});if((e=mt(t)).length)while(n=this[u++])if(i=yt(n),r=1===n.nodeType&&" "+vt(i)+" "){a=0;while(o=e[a++])r.indexOf(" "+o+" ")<0&&(r+=o+" ");i!==(s=vt(r))&&n.setAttribute("class",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).removeClass(t.call(this,e,yt(this)))});if(!arguments.length)return this.attr("class","");if((e=mt(t)).length)while(n=this[u++])if(i=yt(n),r=1===n.nodeType&&" "+vt(i)+" "){a=0;while(o=e[a++])while(-1<r.indexOf(" "+o+" "))r=r.replace(" "+o+" "," ");i!==(s=vt(r))&&n.setAttribute("class",s)}return this},toggleClass:function(i,t){var o=typeof i,a="string"===o||Array.isArray(i);return"boolean"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){S(this).toggleClass(i.call(this,e,yt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=S(this),r=mt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&"boolean"!==o||((e=yt(this))&&Y.set(this,"__className__",e),this.setAttribute&&this.setAttribute("class",e||!1===i?"":Y.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+vt(yt(n))+" ").indexOf(t))return!0;return!1}});var xt=/\r/g;S.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,S(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=S.map(t,function(e){return null==e?"":e+""})),(r=S.valHooks[this.type]||S.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=S.valHooks[t.type]||S.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(xt,""):null==e?"":e:void 0}}),S.extend({valHooks:{option:{get:function(e){var t=S.find.attr(e,"value");return null!=t?t:vt(S.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,"optgroup"))){if(t=S(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=S.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<S.inArray(S.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),S.each(["radio","checkbox"],function(){S.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<S.inArray(S(e).val(),t)}},y.checkOn||(S.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),y.focusin="onfocusin"in C;var bt=/^(?:focusinfocus|focusoutblur)$/,wt=function(e){e.stopPropagation()};S.extend(S.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,"type")?e.type:e,h=v.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!bt.test(d+S.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[S.expando]?e:new S.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:S.makeArray(t,[e]),c=S.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,bt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Y.get(o,"events")||Object.create(null))[e.type]&&Y.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&V(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!V(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),S.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,wt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,wt),S.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=S.extend(new S.Event,n,{type:e,isSimulated:!0});S.event.trigger(r,null,t)}}),S.fn.extend({trigger:function(e,t){return this.each(function(){S.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return S.event.trigger(e,t,n,!0)}}),y.focusin||S.each({focus:"focusin",blur:"focusout"},function(n,r){var i=function(e){S.event.simulate(r,e.target,S.event.fix(e))};S.event.special[r]={setup:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r);t||e.addEventListener(n,i,!0),Y.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r)-1;t?Y.access(e,r,t):(e.removeEventListener(n,i,!0),Y.remove(e,r))}}});var Tt=C.location,Ct={guid:Date.now()},Et=/\?/;S.parseXML=function(e){var t;if(!e||"string"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,"text/xml")}catch(e){t=void 0}return t&&!t.getElementsByTagName("parsererror").length||S.error("Invalid XML: "+e),t};var St=/\[\]$/,kt=/\r?\n/g,At=/^(?:submit|button|image|reset|file)$/i,Nt=/^(?:input|select|textarea|keygen)/i;function Dt(n,e,r,i){var t;if(Array.isArray(e))S.each(e,function(e,t){r||St.test(n)?i(n,t):Dt(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==w(e))i(n,e);else for(t in e)Dt(n+"["+t+"]",e[t],r,i)}S.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!S.isPlainObject(e))S.each(e,function(){i(this.name,this.value)});else for(n in e)Dt(n,e[n],t,i);return r.join("&")},S.fn.extend({serialize:function(){return S.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=S.prop(this,"elements");return e?S.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!S(this).is(":disabled")&&Nt.test(this.nodeName)&&!At.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=S(this).val();return null==n?null:Array.isArray(n)?S.map(n,function(e){return{name:t.name,value:e.replace(kt,"\r\n")}}):{name:t.name,value:n.replace(kt,"\r\n")}}).get()}});var jt=/%20/g,qt=/#.*$/,Lt=/([?&])_=[^&]*/,Ht=/^(.*?):[ \t]*([^\r\n]*)$/gm,Ot=/^(?:GET|HEAD)$/,Pt=/^\/\//,Rt={},Mt={},It="*/".concat("*"),Wt=E.createElement("a");function Ft(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(P)||[];if(m(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function Bt(t,i,o,a){var s={},u=t===Mt;function l(e){var r;return s[e]=!0,S.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function $t(e,t){var n,r,i=S.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&S.extend(!0,e,r),e}Wt.href=Tt.href,S.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Tt.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Tt.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":It,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":S.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?$t($t(e,S.ajaxSettings),t):$t(S.ajaxSettings,e)},ajaxPrefilter:Ft(Rt),ajaxTransport:Ft(Mt),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=S.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?S(y):S.event,x=S.Deferred(),b=S.Callbacks("once memory"),w=v.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Ht.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Tt.href)+"").replace(Pt,Tt.protocol+"//"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||"*").toLowerCase().match(P)||[""],null==v.crossDomain){r=E.createElement("a");try{r.href=v.url,r.href=r.href,v.crossDomain=Wt.protocol+"//"+Wt.host!=r.protocol+"//"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&"string"!=typeof v.data&&(v.data=S.param(v.data,v.traditional)),Bt(Rt,v,t,T),h)return T;for(i in(g=S.event&&v.global)&&0==S.active++&&S.event.trigger("ajaxStart"),v.type=v.type.toUpperCase(),v.hasContent=!Ot.test(v.type),f=v.url.replace(qt,""),v.hasContent?v.data&&v.processData&&0===(v.contentType||"").indexOf("application/x-www-form-urlencoded")&&(v.data=v.data.replace(jt,"+")):(o=v.url.slice(f.length),v.data&&(v.processData||"string"==typeof v.data)&&(f+=(Et.test(f)?"&":"?")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Lt,"$1"),o=(Et.test(f)?"&":"?")+"_="+Ct.guid+++o),v.url=f+o),v.ifModified&&(S.lastModified[f]&&T.setRequestHeader("If-Modified-Since",S.lastModified[f]),S.etag[f]&&T.setRequestHeader("If-None-Match",S.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader("Content-Type",v.contentType),T.setRequestHeader("Accept",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+("*"!==v.dataTypes[0]?", "+It+"; q=0.01":""):v.accepts["*"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u="abort",b.add(v.complete),T.done(v.success),T.fail(v.error),c=Bt(Mt,v,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort("timeout")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),!i&&-1<S.inArray("script",v.dataTypes)&&(v.converters["text script"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(S.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(S.etag[f]=u)),204===e||"HEAD"===v.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger("ajaxComplete",[T,v]),--S.active||S.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return S.get(e,t,n,"json")},getScript:function(e,t){return S.get(e,void 0,t,"script")}}),S.each(["get","post"],function(e,i){S[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),S.ajax(S.extend({url:e,type:i,dataType:r,data:t,success:n},S.isPlainObject(e)&&e))}}),S.ajaxPrefilter(function(e){var t;for(t in e.headers)"content-type"===t.toLowerCase()&&(e.contentType=e.headers[t]||"")}),S._evalUrl=function(e,t,n){return S.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){S.globalEval(e,t,n)}})},S.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=S(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){S(this).wrapInner(n.call(this,e))}):this.each(function(){var e=S(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){S(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){S(this).replaceWith(this.childNodes)}),this}}),S.expr.pseudos.hidden=function(e){return!S.expr.pseudos.visible(e)},S.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},S.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var _t={0:200,1223:204},zt=S.ajaxSettings.xhr();y.cors=!!zt&&"withCredentials"in zt,y.ajax=zt=!!zt,S.ajaxTransport(function(i){var o,a;if(y.cors||zt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(_t[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),S.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),S.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return S.globalEval(e),e}}}),S.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),S.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=S("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Ut,Xt=[],Vt=/(=)\?(?=&|$)|\?\?/;S.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Xt.pop()||S.expando+"_"+Ct.guid++;return this[e]=!0,e}}),S.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Vt.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Vt.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Vt,"$1"+r):!1!==e.jsonp&&(e.url+=(Et.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||S.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?S(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Xt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),"script"}),y.createHTMLDocument=((Ut=E.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Ut.childNodes.length),S.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument("")).createElement("base")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=N.exec(e))?[t.createElement(i[1])]:(i=xe([e],t,o),o&&o.length&&S(o).remove(),S.merge([],i.childNodes)));var r,i,o},S.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=vt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&S.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?S("<div>").append(S.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},S.expr.pseudos.animated=function(t){return S.grep(S.timers,function(e){return t===e.elem}).length},S.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=S.css(e,"position"),c=S(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=S.css(e,"top"),u=S.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,S.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):("number"==typeof f.top&&(f.top+="px"),"number"==typeof f.left&&(f.left+="px"),c.css(f))}},S.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){S.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===S.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===S.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=S(e).offset()).top+=S.css(e,"borderTopWidth",!0),i.left+=S.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-S.css(r,"marginTop",!0),left:t.left-i.left-S.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===S.css(e,"position"))e=e.offsetParent;return e||re})}}),S.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;S.fn[t]=function(e){return $(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),S.each(["top","left"],function(e,n){S.cssHooks[n]=$e(y.pixelPosition,function(e,t){if(t)return t=Be(e,n),Me.test(t)?S(e).position()[n]+"px":t})}),S.each({Height:"height",Width:"width"},function(a,s){S.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){S.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return $(this,function(e,t,n){var r;return x(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?S.css(e,t,i):S.style(e,t,n,i)},s,n?e:void 0,n)}})}),S.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){S.fn[t]=function(e){return this.on(t,e)}}),S.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){S.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var Gt=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;S.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||S.guid++,i},S.holdReady=function(e){e?S.readyWait++:S.ready(!0)},S.isArray=Array.isArray,S.parseJSON=JSON.parse,S.nodeName=A,S.isFunction=m,S.isWindow=x,S.camelCase=X,S.type=w,S.now=Date.now,S.isNumeric=function(e){var t=S.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},S.trim=function(e){return null==e?"":(e+"").replace(Gt,"")},"function"==typeof define&&define.amd&&define("jquery",[],function(){return S});var Yt=C.jQuery,Qt=C.$;return S.noConflict=function(e){return C.$===S&&(C.$=Qt),e&&C.jQuery===S&&(C.jQuery=Yt),S},"undefined"==typeof e&&(C.jQuery=C.$=S),S});
;
/*!
 * jQuery Once v2.2.3 - http://github.com/robloach/jquery-once
 * @license MIT, GPL-2.0
 *   http://opensource.org/licenses/MIT
 *   http://opensource.org/licenses/GPL-2.0
 */
(function(e){"use strict";if(typeof exports==="object"&&typeof exports.nodeName!=="string"){e(require("jquery"))}else if(typeof define==="function"&&define.amd){define(["jquery"],e)}else{e(jQuery)}})(function(t){"use strict";var r=function(e){e=e||"once";if(typeof e!=="string"){throw new TypeError("The jQuery Once id parameter must be a string")}return e};t.fn.once=function(e){var n="jquery-once-"+r(e);return this.filter(function(){return t(this).data(n)!==true}).data(n,true)};t.fn.removeOnce=function(e){return this.findOnce(e).removeData("jquery-once-"+r(e))};t.fn.findOnce=function(e){var n="jquery-once-"+r(e);return this.filter(function(){return t(this).data(n)===true})}});

/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

(function () {
  var settingsElement = document.querySelector('head > script[type="application/json"][data-drupal-selector="drupal-settings-json"], body > script[type="application/json"][data-drupal-selector="drupal-settings-json"]');

  window.drupalSettings = {};

  if (settingsElement !== null) {
    window.drupalSettings = JSON.parse(settingsElement.textContent);
  }
})();;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

window.Drupal = { behaviors: {}, locale: {} };

(function (Drupal, drupalSettings, drupalTranslations, console, Proxy, Reflect) {
  Drupal.throwError = function (error) {
    setTimeout(function () {
      throw error;
    }, 0);
  };

  Drupal.attachBehaviors = function (context, settings) {
    context = context || document;
    settings = settings || drupalSettings;
    var behaviors = Drupal.behaviors;

    Object.keys(behaviors || {}).forEach(function (i) {
      if (typeof behaviors[i].attach === 'function') {
        try {
          behaviors[i].attach(context, settings);
        } catch (e) {
          Drupal.throwError(e);
        }
      }
    });
  };

  Drupal.detachBehaviors = function (context, settings, trigger) {
    context = context || document;
    settings = settings || drupalSettings;
    trigger = trigger || 'unload';
    var behaviors = Drupal.behaviors;

    Object.keys(behaviors || {}).forEach(function (i) {
      if (typeof behaviors[i].detach === 'function') {
        try {
          behaviors[i].detach(context, settings, trigger);
        } catch (e) {
          Drupal.throwError(e);
        }
      }
    });
  };

  Drupal.checkPlain = function (str) {
    str = str.toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    return str;
  };

  Drupal.formatString = function (str, args) {
    var processedArgs = {};

    Object.keys(args || {}).forEach(function (key) {
      switch (key.charAt(0)) {
        case '@':
          processedArgs[key] = Drupal.checkPlain(args[key]);
          break;

        case '!':
          processedArgs[key] = args[key];
          break;

        default:
          processedArgs[key] = Drupal.theme('placeholder', args[key]);
          break;
      }
    });

    return Drupal.stringReplace(str, processedArgs, null);
  };

  Drupal.stringReplace = function (str, args, keys) {
    if (str.length === 0) {
      return str;
    }

    if (!Array.isArray(keys)) {
      keys = Object.keys(args || {});

      keys.sort(function (a, b) {
        return a.length - b.length;
      });
    }

    if (keys.length === 0) {
      return str;
    }

    var key = keys.pop();
    var fragments = str.split(key);

    if (keys.length) {
      for (var i = 0; i < fragments.length; i++) {
        fragments[i] = Drupal.stringReplace(fragments[i], args, keys.slice(0));
      }
    }

    return fragments.join(args[key]);
  };

  Drupal.t = function (str, args, options) {
    options = options || {};
    options.context = options.context || '';

    if (typeof drupalTranslations !== 'undefined' && drupalTranslations.strings && drupalTranslations.strings[options.context] && drupalTranslations.strings[options.context][str]) {
      str = drupalTranslations.strings[options.context][str];
    }

    if (args) {
      str = Drupal.formatString(str, args);
    }
    return str;
  };

  Drupal.url = function (path) {
    return drupalSettings.path.baseUrl + drupalSettings.path.pathPrefix + path;
  };

  Drupal.url.toAbsolute = function (url) {
    var urlParsingNode = document.createElement('a');

    try {
      url = decodeURIComponent(url);
    } catch (e) {}

    urlParsingNode.setAttribute('href', url);

    return urlParsingNode.cloneNode(false).href;
  };

  Drupal.url.isLocal = function (url) {
    var absoluteUrl = Drupal.url.toAbsolute(url);
    var protocol = window.location.protocol;

    if (protocol === 'http:' && absoluteUrl.indexOf('https:') === 0) {
      protocol = 'https:';
    }
    var baseUrl = protocol + '//' + window.location.host + drupalSettings.path.baseUrl.slice(0, -1);

    try {
      absoluteUrl = decodeURIComponent(absoluteUrl);
    } catch (e) {}
    try {
      baseUrl = decodeURIComponent(baseUrl);
    } catch (e) {}

    return absoluteUrl === baseUrl || absoluteUrl.indexOf(baseUrl + '/') === 0;
  };

  Drupal.formatPlural = function (count, singular, plural, args, options) {
    args = args || {};
    args['@count'] = count;

    var pluralDelimiter = drupalSettings.pluralDelimiter;
    var translations = Drupal.t(singular + pluralDelimiter + plural, args, options).split(pluralDelimiter);
    var index = 0;

    if (typeof drupalTranslations !== 'undefined' && drupalTranslations.pluralFormula) {
      index = count in drupalTranslations.pluralFormula ? drupalTranslations.pluralFormula[count] : drupalTranslations.pluralFormula.default;
    } else if (args['@count'] !== 1) {
      index = 1;
    }

    return translations[index];
  };

  Drupal.encodePath = function (item) {
    return window.encodeURIComponent(item).replace(/%2F/g, '/');
  };

  Drupal.deprecationError = function (_ref) {
    var message = _ref.message;

    if (drupalSettings.suppressDeprecationErrors === false && typeof console !== 'undefined' && console.warn) {
      console.warn('[Deprecation] ' + message);
    }
  };

  Drupal.deprecatedProperty = function (_ref2) {
    var target = _ref2.target,
        deprecatedProperty = _ref2.deprecatedProperty,
        message = _ref2.message;

    if (!Proxy || !Reflect) {
      return target;
    }

    return new Proxy(target, {
      get: function get(target, key) {
        for (var _len = arguments.length, rest = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          rest[_key - 2] = arguments[_key];
        }

        if (key === deprecatedProperty) {
          Drupal.deprecationError({ message: message });
        }
        return Reflect.get.apply(Reflect, [target, key].concat(rest));
      }
    });
  };

  Drupal.theme = function (func) {
    if (func in Drupal.theme) {
      var _Drupal$theme;

      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return (_Drupal$theme = Drupal.theme)[func].apply(_Drupal$theme, args);
    }
  };

  Drupal.theme.placeholder = function (str) {
    return '<em class="placeholder">' + Drupal.checkPlain(str) + '</em>';
  };
})(Drupal, window.drupalSettings, window.drupalTranslations, window.console, window.Proxy, window.Reflect);;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

if (window.jQuery) {
  jQuery.noConflict();
}

document.documentElement.className += ' js';

(function (Drupal, drupalSettings) {
  var domReady = function domReady(callback) {
    if (document.readyState !== 'loading') {
      callback();
    } else {
      var listener = function listener() {
        callback();
        document.removeEventListener('DOMContentLoaded', listener);
      };
      document.addEventListener('DOMContentLoaded', listener);
    }
  };

  domReady(function () {
    Drupal.attachBehaviors(document, drupalSettings);
  });
})(Drupal, window.drupalSettings);;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery","./version"],a):a(jQuery)}(function(a){return a.extend(a.expr[":"],{data:a.expr.createPseudo?a.expr.createPseudo(function(b){return function(c){return!!a.data(c,b)}}):function(b,c,d){return!!a.data(b,d[3])}})});;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery","./version"],a):a(jQuery)}(function(a){return a.fn.extend({disableSelection:function(){var a="onselectstart"in document.createElement("div")?"selectstart":"mousedown";return function(){return this.on(a+".ui-disableSelection",function(a){a.preventDefault()})}}(),enableSelection:function(){return this.off(".ui-disableSelection")}})});;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery","./version"],a):a(jQuery)}(function(a){return a.fn.form=function(){return"string"==typeof this[0].form?this.closest("form"):a(this[0].form)}});;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery","./version","./escape-selector"],a):a(jQuery)}(function(a){return a.fn.labels=function(){var b,c,d,e,f;return this[0].labels&&this[0].labels.length?this.pushStack(this[0].labels):(e=this.eq(0).parents("label"),d=this.attr("id"),d&&(b=this.eq(0).parents().last(),f=b.add(b.length?b.siblings():this.siblings()),c="label[for='"+a.ui.escapeSelector(d)+"']",e=e.add(f.find(c).addBack(c))),this.pushStack(e))}});;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery","./version"],a):a(jQuery)}(function(a){"1.7"===a.fn.jquery.substring(0,3)&&(a.each(["Width","Height"],function(b,c){function d(b,c,d,f){return a.each(e,function(){c-=parseFloat(a.css(b,"padding"+this))||0,d&&(c-=parseFloat(a.css(b,"border"+this+"Width"))||0),f&&(c-=parseFloat(a.css(b,"margin"+this))||0)}),c}var e="Width"===c?["Left","Right"]:["Top","Bottom"],f=c.toLowerCase(),g={innerWidth:a.fn.innerWidth,innerHeight:a.fn.innerHeight,outerWidth:a.fn.outerWidth,outerHeight:a.fn.outerHeight};a.fn["inner"+c]=function(b){return void 0===b?g["inner"+c].call(this):this.each(function(){a(this).css(f,d(this,b)+"px")})},a.fn["outer"+c]=function(b,e){return"number"!=typeof b?g["outer"+c].call(this,b):this.each(function(){a(this).css(f,d(this,b,!0,e)+"px")})}}),a.fn.addBack=function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))})});;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery","./version"],a):a(jQuery)}(function(a){return a.fn.scrollParent=function(b){var c=this.css("position"),d="absolute"===c,e=b?/(auto|scroll|hidden)/:/(auto|scroll)/,f=this.parents().filter(function(){var b=a(this);return(!d||"static"!==b.css("position"))&&e.test(b.css("overflow")+b.css("overflow-y")+b.css("overflow-x"))}).eq(0);return"fixed"!==c&&f.length?f:a(this[0].ownerDocument||document)}});;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery","./version","./focusable"],a):a(jQuery)}(function(a){return a.extend(a.expr[":"],{tabbable:function(b){var c=a.attr(b,"tabindex"),d=null!=c;return(!d||c>=0)&&a.ui.focusable(b,d)}})});;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery","./version"],a):a(jQuery)}(function(a){return a.fn.extend({uniqueId:function(){var a=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++a)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&a(this).removeAttr("id")})}})});;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery"],a):a(jQuery)}(function(a){return a.ui=a.ui||{},a.ui.version="1.12.1"});;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery","./version"],a):a(jQuery)}(function(a){return a.ui.escapeSelector=function(){var a=/([!"#$%&'()*+,.\/:;<=>?@[\]^`{|}~])/g;return function(b){return b.replace(a,"\\$1")}}()});;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery","./version"],a):a(jQuery)}(function(a){function b(a){for(var b=a.css("visibility");"inherit"===b;)a=a.parent(),b=a.css("visibility");return"hidden"!==b}return a.ui.focusable=function(c,d){var e,f,g,h,i,j=c.nodeName.toLowerCase();return"area"===j?(e=c.parentNode,f=e.name,!(!c.href||!f||"map"!==e.nodeName.toLowerCase())&&(g=a("img[usemap='#"+f+"']"),g.length>0&&g.is(":visible"))):(/^(input|select|textarea|button|object)$/.test(j)?(h=!c.disabled,h&&(i=a(c).closest("fieldset")[0],i&&(h=!i.disabled))):h="a"===j?c.href||d:d,h&&a(c).is(":visible")&&b(a(c)))},a.extend(a.expr[":"],{focusable:function(b){return a.ui.focusable(b,null!=a.attr(b,"tabindex"))}}),a.ui.focusable});;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery","./version"],a):a(jQuery)}(function(a){return a.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase())});;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery","./version"],a):a(jQuery)}(function(a){return a.ui.keyCode={BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38}});;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery","./version"],a):a(jQuery)}(function(a){return a.ui.plugin={add:function(b,c,d){var e,f=a.ui[b].prototype;for(e in d)f.plugins[e]=f.plugins[e]||[],f.plugins[e].push([c,d[e]])},call:function(a,b,c,d){var e,f=a.plugins[b];if(f&&(d||a.element[0].parentNode&&11!==a.element[0].parentNode.nodeType))for(e=0;e<f.length;e++)a.options[f[e][0]]&&f[e][1].apply(a.element,c)}}});;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery","./version"],a):a(jQuery)}(function(a){return a.ui.safeActiveElement=function(a){var b;try{b=a.activeElement}catch(c){b=a.body}return b||(b=a.body),b.nodeName||(b=a.body),b}});;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery","./version"],a):a(jQuery)}(function(a){return a.ui.safeBlur=function(b){b&&"body"!==b.nodeName.toLowerCase()&&a(b).trigger("blur")}});;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery","./version"],a):a(jQuery)}(function(a){var b=0,c=Array.prototype.slice;return a.cleanData=function(b){return function(c){var d,e,f;for(f=0;null!=(e=c[f]);f++)try{d=a._data(e,"events"),d&&d.remove&&a(e).triggerHandler("remove")}catch(g){}b(c)}}(a.cleanData),a.widget=function(b,c,d){var e,f,g,h={},i=b.split(".")[0];b=b.split(".")[1];var j=i+"-"+b;return d||(d=c,c=a.Widget),a.isArray(d)&&(d=a.extend.apply(null,[{}].concat(d))),a.expr[":"][j.toLowerCase()]=function(b){return!!a.data(b,j)},a[i]=a[i]||{},e=a[i][b],f=a[i][b]=function(a,b){return this._createWidget?void(arguments.length&&this._createWidget(a,b)):new f(a,b)},a.extend(f,e,{version:d.version,_proto:a.extend({},d),_childConstructors:[]}),g=new c,g.options=a.widget.extend({},g.options),a.each(d,function(b,d){return a.isFunction(d)?void(h[b]=function(){function a(){return c.prototype[b].apply(this,arguments)}function e(a){return c.prototype[b].apply(this,a)}return function(){var b,c=this._super,f=this._superApply;return this._super=a,this._superApply=e,b=d.apply(this,arguments),this._super=c,this._superApply=f,b}}()):void(h[b]=d)}),f.prototype=a.widget.extend(g,{widgetEventPrefix:e?g.widgetEventPrefix||b:b},h,{constructor:f,namespace:i,widgetName:b,widgetFullName:j}),e?(a.each(e._childConstructors,function(b,c){var d=c.prototype;a.widget(d.namespace+"."+d.widgetName,f,c._proto)}),delete e._childConstructors):c._childConstructors.push(f),a.widget.bridge(b,f),f},a.widget.extend=function(b){for(var d,e,f=c.call(arguments,1),g=0,h=f.length;g<h;g++)for(d in f[g])e=f[g][d],f[g].hasOwnProperty(d)&&void 0!==e&&(a.isPlainObject(e)?b[d]=a.isPlainObject(b[d])?a.widget.extend({},b[d],e):a.widget.extend({},e):b[d]=e);return b},a.widget.bridge=function(b,d){var e=d.prototype.widgetFullName||b;a.fn[b]=function(f){var g="string"==typeof f,h=c.call(arguments,1),i=this;return g?this.length||"instance"!==f?this.each(function(){var c,d=a.data(this,e);return"instance"===f?(i=d,!1):d?a.isFunction(d[f])&&"_"!==f.charAt(0)?(c=d[f].apply(d,h),c!==d&&void 0!==c?(i=c&&c.jquery?i.pushStack(c.get()):c,!1):void 0):a.error("no such method '"+f+"' for "+b+" widget instance"):a.error("cannot call methods on "+b+" prior to initialization; attempted to call method '"+f+"'")}):i=void 0:(h.length&&(f=a.widget.extend.apply(null,[f].concat(h))),this.each(function(){var b=a.data(this,e);b?(b.option(f||{}),b._init&&b._init()):a.data(this,e,new d(f,this))})),i}},a.Widget=function(){},a.Widget._childConstructors=[],a.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{classes:{},disabled:!1,create:null},_createWidget:function(c,d){d=a(d||this.defaultElement||this)[0],this.element=a(d),this.uuid=b++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=a(),this.hoverable=a(),this.focusable=a(),this.classesElementLookup={},d!==this&&(a.data(d,this.widgetFullName,this),this._on(!0,this.element,{remove:function(a){a.target===d&&this.destroy()}}),this.document=a(d.style?d.ownerDocument:d.document||d),this.window=a(this.document[0].defaultView||this.document[0].parentWindow)),this.options=a.widget.extend({},this.options,this._getCreateOptions(),c),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:a.noop,_create:a.noop,_init:a.noop,destroy:function(){var b=this;this._destroy(),a.each(this.classesElementLookup,function(a,c){b._removeClass(c,a)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr("aria-disabled"),this.bindings.off(this.eventNamespace)},_destroy:a.noop,widget:function(){return this.element},option:function(b,c){var d,e,f,g=b;if(0===arguments.length)return a.widget.extend({},this.options);if("string"==typeof b)if(g={},d=b.split("."),b=d.shift(),d.length){for(e=g[b]=a.widget.extend({},this.options[b]),f=0;f<d.length-1;f++)e[d[f]]=e[d[f]]||{},e=e[d[f]];if(b=d.pop(),1===arguments.length)return void 0===e[b]?null:e[b];e[b]=c}else{if(1===arguments.length)return void 0===this.options[b]?null:this.options[b];g[b]=c}return this._setOptions(g),this},_setOptions:function(a){var b;for(b in a)this._setOption(b,a[b]);return this},_setOption:function(a,b){return"classes"===a&&this._setOptionClasses(b),this.options[a]=b,"disabled"===a&&this._setOptionDisabled(b),this},_setOptionClasses:function(b){var c,d,e;for(c in b)e=this.classesElementLookup[c],b[c]!==this.options.classes[c]&&e&&e.length&&(d=a(e.get()),this._removeClass(e,c),d.addClass(this._classes({element:d,keys:c,classes:b,add:!0})))},_setOptionDisabled:function(a){this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,!!a),a&&(this._removeClass(this.hoverable,null,"ui-state-hover"),this._removeClass(this.focusable,null,"ui-state-focus"))},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_classes:function(b){function c(c,f){var g,h;for(h=0;h<c.length;h++)g=e.classesElementLookup[c[h]]||a(),g=a(b.add?a.unique(g.get().concat(b.element.get())):g.not(b.element).get()),e.classesElementLookup[c[h]]=g,d.push(c[h]),f&&b.classes[c[h]]&&d.push(b.classes[c[h]])}var d=[],e=this;return b=a.extend({element:this.element,classes:this.options.classes||{}},b),this._on(b.element,{remove:"_untrackClassesElement"}),b.keys&&c(b.keys.match(/\S+/g)||[],!0),b.extra&&c(b.extra.match(/\S+/g)||[]),d.join(" ")},_untrackClassesElement:function(b){var c=this;a.each(c.classesElementLookup,function(d,e){a.inArray(b.target,e)!==-1&&(c.classesElementLookup[d]=a(e.not(b.target).get()))})},_removeClass:function(a,b,c){return this._toggleClass(a,b,c,!1)},_addClass:function(a,b,c){return this._toggleClass(a,b,c,!0)},_toggleClass:function(a,b,c,d){d="boolean"==typeof d?d:c;var e="string"==typeof a||null===a,f={extra:e?b:c,keys:e?a:b,element:e?this.element:a,add:d};return f.element.toggleClass(this._classes(f),d),this},_on:function(b,c,d){var e,f=this;"boolean"!=typeof b&&(d=c,c=b,b=!1),d?(c=e=a(c),this.bindings=this.bindings.add(c)):(d=c,c=this.element,e=this.widget()),a.each(d,function(d,g){function h(){if(b||f.options.disabled!==!0&&!a(this).hasClass("ui-state-disabled"))return("string"==typeof g?f[g]:g).apply(f,arguments)}"string"!=typeof g&&(h.guid=g.guid=g.guid||h.guid||a.guid++);var i=d.match(/^([\w:-]*)\s*(.*)$/),j=i[1]+f.eventNamespace,k=i[2];k?e.on(j,k,h):c.on(j,h)})},_off:function(b,c){c=(c||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,b.off(c).off(c),this.bindings=a(this.bindings.not(b).get()),this.focusable=a(this.focusable.not(b).get()),this.hoverable=a(this.hoverable.not(b).get())},_delay:function(a,b){function c(){return("string"==typeof a?d[a]:a).apply(d,arguments)}var d=this;return setTimeout(c,b||0)},_hoverable:function(b){this.hoverable=this.hoverable.add(b),this._on(b,{mouseenter:function(b){this._addClass(a(b.currentTarget),null,"ui-state-hover")},mouseleave:function(b){this._removeClass(a(b.currentTarget),null,"ui-state-hover")}})},_focusable:function(b){this.focusable=this.focusable.add(b),this._on(b,{focusin:function(b){this._addClass(a(b.currentTarget),null,"ui-state-focus")},focusout:function(b){this._removeClass(a(b.currentTarget),null,"ui-state-focus")}})},_trigger:function(b,c,d){var e,f,g=this.options[b];if(d=d||{},c=a.Event(c),c.type=(b===this.widgetEventPrefix?b:this.widgetEventPrefix+b).toLowerCase(),c.target=this.element[0],f=c.originalEvent)for(e in f)e in c||(c[e]=f[e]);return this.element.trigger(c,d),!(a.isFunction(g)&&g.apply(this.element[0],[c].concat(d))===!1||c.isDefaultPrevented())}},a.each({show:"fadeIn",hide:"fadeOut"},function(b,c){a.Widget.prototype["_"+b]=function(d,e,f){"string"==typeof e&&(e={effect:e});var g,h=e?e===!0||"number"==typeof e?c:e.effect||c:b;e=e||{},"number"==typeof e&&(e={duration:e}),g=!a.isEmptyObject(e),e.complete=f,e.delay&&d.delay(e.delay),g&&a.effects&&a.effects.effect[h]?d[b](e):h!==b&&d[h]?d[h](e.duration,e.easing,f):d.queue(function(c){a(this)[b](),f&&f.call(d[0]),c()})}}),a.widget});;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

(function ($, Drupal) {
  var autocomplete = void 0;

  function autocompleteSplitValues(value) {
    var result = [];
    var quote = false;
    var current = '';
    var valueLength = value.length;
    var character = void 0;

    for (var i = 0; i < valueLength; i++) {
      character = value.charAt(i);
      if (character === '"') {
        current += character;
        quote = !quote;
      } else if (character === ',' && !quote) {
        result.push(current.trim());
        current = '';
      } else {
        current += character;
      }
    }
    if (value.length > 0) {
      result.push($.trim(current));
    }

    return result;
  }

  function extractLastTerm(terms) {
    return autocomplete.splitValues(terms).pop();
  }

  function searchHandler(event) {
    var options = autocomplete.options;

    if (options.isComposing) {
      return false;
    }

    var term = autocomplete.extractLastTerm(event.target.value);

    if (term.length > 0 && options.firstCharacterBlacklist.indexOf(term[0]) !== -1) {
      return false;
    }

    return term.length >= options.minLength;
  }

  function sourceData(request, response) {
    var elementId = this.element.attr('id');

    if (!(elementId in autocomplete.cache)) {
      autocomplete.cache[elementId] = {};
    }

    function showSuggestions(suggestions) {
      var tagged = autocomplete.splitValues(request.term);
      var il = tagged.length;
      for (var i = 0; i < il; i++) {
        var index = suggestions.indexOf(tagged[i]);
        if (index >= 0) {
          suggestions.splice(index, 1);
        }
      }
      response(suggestions);
    }

    var term = autocomplete.extractLastTerm(request.term);

    function sourceCallbackHandler(data) {
      autocomplete.cache[elementId][term] = data;

      showSuggestions(data);
    }

    if (autocomplete.cache[elementId].hasOwnProperty(term)) {
      showSuggestions(autocomplete.cache[elementId][term]);
    } else {
      var options = $.extend({ success: sourceCallbackHandler, data: { q: term } }, autocomplete.ajax);
      $.ajax(this.element.attr('data-autocomplete-path'), options);
    }
  }

  function focusHandler() {
    return false;
  }

  function selectHandler(event, ui) {
    var terms = autocomplete.splitValues(event.target.value);

    terms.pop();

    terms.push(ui.item.value);

    event.target.value = terms.join(', ');

    return false;
  }

  function renderItem(ul, item) {
    return $('<li>').append($('<a>').html(item.label)).appendTo(ul);
  }

  Drupal.behaviors.autocomplete = {
    attach: function attach(context) {
      var $autocomplete = $(context).find('input.form-autocomplete').once('autocomplete');
      if ($autocomplete.length) {
        var blacklist = $autocomplete.attr('data-autocomplete-first-character-blacklist');
        $.extend(autocomplete.options, {
          firstCharacterBlacklist: blacklist || ''
        });

        $autocomplete.autocomplete(autocomplete.options).each(function () {
          $(this).data('ui-autocomplete')._renderItem = autocomplete.options.renderItem;
        });

        $autocomplete.on('compositionstart.autocomplete', function () {
          autocomplete.options.isComposing = true;
        });
        $autocomplete.on('compositionend.autocomplete', function () {
          autocomplete.options.isComposing = false;
        });
      }
    },
    detach: function detach(context, settings, trigger) {
      if (trigger === 'unload') {
        $(context).find('input.form-autocomplete').removeOnce('autocomplete').autocomplete('destroy');
      }
    }
  };

  autocomplete = {
    cache: {},

    splitValues: autocompleteSplitValues,
    extractLastTerm: extractLastTerm,

    options: {
      source: sourceData,
      focus: focusHandler,
      search: searchHandler,
      select: selectHandler,
      renderItem: renderItem,
      minLength: 1,

      firstCharacterBlacklist: '',

      isComposing: false
    },
    ajax: {
      dataType: 'json',
      jsonp: false
    }
  };

  Drupal.autocomplete = autocomplete;
})(jQuery, Drupal);;
!function(e,t,n){function r(e,t){return typeof e===t}function o(e){var t=T.className,n=b._config.classPrefix||"";if(w&&(t=t.baseVal),b._config.enableJSClass){var r=new RegExp("(^|\\s)"+n+"no-js(\\s|$)");t=t.replace(r,"$1"+n+"js$2")}b._config.enableClasses&&(t+=" "+n+e.join(" "+n),w?T.className.baseVal=t:T.className=t)}function s(){return"function"!=typeof t.createElement?t.createElement(arguments[0]):w?t.createElementNS.call(t,"http://www.w3.org/2000/svg",arguments[0]):t.createElement.apply(t,arguments)}function i(e,t){if("object"==typeof e)for(var n in e)j(e,n)&&i(n,e[n]);else{e=e.toLowerCase();var r=e.split("."),s=b[r[0]];if(2==r.length&&(s=s[r[1]]),void 0!==s)return b;t="function"==typeof t?t():t,1==r.length?b[r[0]]=t:(!b[r[0]]||b[r[0]]instanceof Boolean||(b[r[0]]=new Boolean(b[r[0]])),b[r[0]][r[1]]=t),o([(t&&0!=t?"":"no-")+r.join("-")]),b._trigger(e,t)}return b}function a(){var e=t.body;return e||(e=s(w?"svg":"body"),e.fake=!0),e}function l(e,n,r,o){var i,l,u,f,c="modernizr",d=s("div"),p=a();if(parseInt(r,10))for(;r--;)u=s("div"),u.id=o?o[r]:c+(r+1),d.appendChild(u);return i=s("style"),i.type="text/css",i.id="s"+c,(p.fake?p:d).appendChild(i),p.appendChild(d),i.styleSheet?i.styleSheet.cssText=e:i.appendChild(t.createTextNode(e)),d.id=c,p.fake&&(p.style.background="",p.style.overflow="hidden",f=T.style.overflow,T.style.overflow="hidden",T.appendChild(p)),l=n(d,e),p.fake?(p.parentNode.removeChild(p),T.style.overflow=f,T.offsetHeight):d.parentNode.removeChild(d),!!l}function u(e,t){return!!~(""+e).indexOf(t)}function f(e){return e.replace(/([A-Z])/g,function(e,t){return"-"+t.toLowerCase()}).replace(/^ms-/,"-ms-")}function c(t,n,r){var o;if("getComputedStyle"in e){o=getComputedStyle.call(e,t,n);var s=e.console;if(null!==o)r&&(o=o.getPropertyValue(r));else if(s){var i=s.error?"error":"log";s[i].call(s,"getComputedStyle returning null, its possible modernizr test results are inaccurate")}}else o=!n&&t.currentStyle&&t.currentStyle[r];return o}function d(t,r){var o=t.length;if("CSS"in e&&"supports"in e.CSS){for(;o--;)if(e.CSS.supports(f(t[o]),r))return!0;return!1}if("CSSSupportsRule"in e){for(var s=[];o--;)s.push("("+f(t[o])+":"+r+")");return s=s.join(" or "),l("@supports ("+s+") { #modernizr { position: absolute; } }",function(e){return"absolute"==c(e,null,"position")})}return n}function p(e){return e.replace(/([a-z])-([a-z])/g,function(e,t,n){return t+n.toUpperCase()}).replace(/^-/,"")}function A(e,t,o,i){function a(){f&&(delete L.style,delete L.modElem)}if(i=!r(i,"undefined")&&i,!r(o,"undefined")){var l=d(e,o);if(!r(l,"undefined"))return l}for(var f,c,A,m,g,v=["modernizr","tspan","samp"];!L.style&&v.length;)f=!0,L.modElem=s(v.shift()),L.style=L.modElem.style;for(A=e.length,c=0;c<A;c++)if(m=e[c],g=L.style[m],u(m,"-")&&(m=p(m)),L.style[m]!==n){if(i||r(o,"undefined"))return a(),"pfx"!=t||m;try{L.style[m]=o}catch(e){}if(L.style[m]!=g)return a(),"pfx"!=t||m}return a(),!1}function m(e,t){return function(){return e.apply(t,arguments)}}function g(e,t,n){var o;for(var s in e)if(e[s]in t)return!1===n?e[s]:(o=t[e[s]],r(o,"function")?m(o,n||t):o);return!1}function v(e,t,n,o,s){var i=e.charAt(0).toUpperCase()+e.slice(1),a=(e+" "+O.join(i+" ")+i).split(" ");return r(t,"string")||r(t,"undefined")?A(a,t,o,s):(a=(e+" "+M.join(i+" ")+i).split(" "),g(a,t,n))}function h(e,t,r){return v(e,n,n,t,r)}var y=[],C={_version:"3.6.0",_config:{classPrefix:"",enableClasses:!0,enableJSClass:!0,usePrefixes:!0},_q:[],on:function(e,t){var n=this;setTimeout(function(){t(n[e])},0)},addTest:function(e,t,n){y.push({name:e,fn:t,options:n})},addAsyncTest:function(e){y.push({name:null,fn:e})}},b=function(){};b.prototype=C,b=new b;var x=[],T=t.documentElement,w="svg"===T.nodeName.toLowerCase();b.addTest("picture","HTMLPictureElement"in e),b.addTest("canvas",function(){var e=s("canvas");return!(!e.getContext||!e.getContext("2d"))});var S=s("input"),_="autocomplete autofocus list placeholder max min multiple pattern required step".split(" "),E={};b.input=function(t){for(var n=0,r=t.length;n<r;n++)E[t[n]]=!!(t[n]in S);return E.list&&(E.list=!(!s("datalist")||!e.HTMLDataListElement)),E}(_);var B="search tel url email datetime date month week time datetime-local number range color".split(" "),k={};b.inputtypes=function(e){for(var r,o,s,i=e.length,a=0;a<i;a++)S.setAttribute("type",r=e[a]),s="text"!==S.type&&"style"in S,s&&(S.value="1)",S.style.cssText="position:absolute;visibility:hidden;",/^range$/.test(r)&&S.style.WebkitAppearance!==n?(T.appendChild(S),o=t.defaultView,s=o.getComputedStyle&&"textfield"!==o.getComputedStyle(S,null).WebkitAppearance&&0!==S.offsetHeight,T.removeChild(S)):/^(search|tel)$/.test(r)||(s=/^(url|email)$/.test(r)?S.checkValidity&&!1===S.checkValidity():"1)"!=S.value)),k[e[a]]=!!s;return k}(B),b.addTest("svg",!!t.createElementNS&&!!t.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect);var j;!function(){var e={}.hasOwnProperty;j=r(e,"undefined")||r(e.call,"undefined")?function(e,t){return t in e&&r(e.constructor.prototype[t],"undefined")}:function(t,n){return e.call(t,n)}}(),C._l={},C.on=function(e,t){this._l[e]||(this._l[e]=[]),this._l[e].push(t),b.hasOwnProperty(e)&&setTimeout(function(){b._trigger(e,b[e])},0)},C._trigger=function(e,t){if(this._l[e]){var n=this._l[e];setTimeout(function(){var e;for(e=0;e<n.length;e++)(0,n[e])(t)},0),delete this._l[e]}},b._q.push(function(){C.addTest=i}),b.addTest("svgasimg",t.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image","1.1"));var R=C._config.usePrefixes?" -webkit- -moz- -o- -ms- ".split(" "):["",""];C._prefixes=R;var z=C.testStyles=l;b.addTest("touchevents",function(){var n;if("ontouchstart"in e||e.DocumentTouch&&t instanceof DocumentTouch)n=!0;else{var r=["@media (",R.join("touch-enabled),("),"heartz",")","{#modernizr{top:9px;position:absolute}}"].join("");z(r,function(e){n=9===e.offsetTop})}return n});var P=function(){function e(e,t){var o;return!!e&&(t&&"string"!=typeof t||(t=s(t||"div")),e="on"+e,o=e in t,!o&&r&&(t.setAttribute||(t=s("div")),t.setAttribute(e,""),o="function"==typeof t[e],t[e]!==n&&(t[e]=n),t.removeAttribute(e)),o)}var r=!("onblur"in t.documentElement);return e}();C.hasEvent=P;var N="Moz O ms Webkit",O=C._config.usePrefixes?N.split(" "):[];C._cssomPrefixes=O;var V={elem:s("modernizr")};b._q.push(function(){delete V.elem});var L={style:V.elem.style};b._q.unshift(function(){delete L.style});var M=C._config.usePrefixes?N.toLowerCase().split(" "):[];C._domPrefixes=M,C.testAllProps=v;var U=function(t){var r,o=R.length,s=e.CSSRule;if(void 0===s)return n;if(!t)return!1;if(t=t.replace(/^@/,""),(r=t.replace(/-/g,"_").toUpperCase()+"_RULE")in s)return"@"+t;for(var i=0;i<o;i++){var a=R[i];if(a.toUpperCase()+"_"+r in s)return"@-"+a.toLowerCase()+"-"+t}return!1};C.atRule=U;var W=C.prefixed=function(e,t,n){return 0===e.indexOf("@")?U(e):(-1!=e.indexOf("-")&&(e=p(e)),t?v(e,t,n):v(e,"pfx"))};b.addTest("forcetouch",function(){return!!P(W("mouseforcewillbegin",e,!1),e)&&(MouseEvent.WEBKIT_FORCE_AT_MOUSE_DOWN&&MouseEvent.WEBKIT_FORCE_AT_FORCE_MOUSE_DOWN)}),C.testAllProps=h,b.addTest("cssanimations",h("animationName","a",!0)),b.addTest("csscalc",function(){var e=s("a");return e.style.cssText="width:"+R.join("calc(10px);width:"),!!e.style.length}),function(){b.addTest("csscolumns",function(){var e=!1,t=h("columnCount");try{e=!!t,e&&(e=new Boolean(e))}catch(e){}return e});for(var e,t,n=["Width","Span","Fill","Gap","Rule","RuleColor","RuleStyle","RuleWidth","BreakBefore","BreakAfter","BreakInside"],r=0;r<n.length;r++)e=n[r].toLowerCase(),t=h("column"+n[r]),"breakbefore"!==e&&"breakafter"!==e&&"breakinside"!=e||(t=t||h(n[r])),b.addTest("csscolumns."+e,t)}();var F="CSS"in e&&"supports"in e.CSS,I="supportsCSS"in e;b.addTest("supports",F||I),b.addTest("cssfilters",function(){if(b.supports)return h("filter","blur(2px)");var e=s("a");return e.style.cssText=R.join("filter:blur(2px); "),!!e.style.length&&(t.documentMode===n||t.documentMode>9)}),b.addTest("flexbox",h("flexBasis","1px",!0)),b.addTest("multiplebgs",function(){var e=s("a").style;return e.cssText="background:url(https://),url(https://),red url(https://)",/(url\s*\(.*?){3}/.test(e.background)}),b.addTest("csstransforms",function(){return-1===navigator.userAgent.indexOf("Android 2.")&&h("transform","scale(1)",!0)}),b.addTest("csstransforms3d",function(){return!!h("perspective","1px",!0)}),b.addTest("csstransitions",h("transition","all",!0)),b.addTest("cssmask",h("maskRepeat","repeat-x",!0)),b.addTest("objectfit",!!W("objectFit"),{aliases:["object-fit"]}),b.addTest("csspseudotransitions",function(){var t=!1;if(!b.csstransitions||!e.getComputedStyle)return t;var n='#modernizr:before { content:" "; font-size:5px;'+b._prefixes.join("transition:0s 100s;")+"}#modernizr.trigger:before { font-size:10px; }";return b.testStyles(n,function(n){e.getComputedStyle(n,":before").getPropertyValue("font-size"),n.className+="trigger",t="5px"===e.getComputedStyle(n,":before").getPropertyValue("font-size")}),t}),b.addAsyncTest(function(){if(!b.canvas)return!1;var e=new Image,t=s("canvas"),n=t.getContext("2d");e.onload=function(){i("apng",function(){return void 0!==t.getContext&&(n.drawImage(e,0,0),0===n.getImageData(0,0,1,1).data[3])})},e.src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACGFjVEwAAAABAAAAAcMq2TYAAAANSURBVAiZY2BgYPgPAAEEAQB9ssjfAAAAGmZjVEwAAAAAAAAAAQAAAAEAAAAAAAAAAAD6A+gBAbNU+2sAAAARZmRBVAAAAAEImWNgYGBgAAAABQAB6MzFdgAAAABJRU5ErkJggg=="}),function(){var e,t,n,o,s,i,a;for(var l in y)if(y.hasOwnProperty(l)){if(e=[],t=y[l],t.name&&(e.push(t.name.toLowerCase()),t.options&&t.options.aliases&&t.options.aliases.length))for(n=0;n<t.options.aliases.length;n++)e.push(t.options.aliases[n].toLowerCase());for(o=r(t.fn,"function")?t.fn():t.fn,s=0;s<e.length;s++)i=e[s],a=i.split("."),1===a.length?b[a[0]]=o:(!b[a[0]]||b[a[0]]instanceof Boolean||(b[a[0]]=new Boolean(b[a[0]])),b[a[0]][a[1]]=o),x.push((o?"":"no-")+a.join("-"))}}(),o(x),delete C.addTest,delete C.addAsyncTest;for(var q=0;q<b._q.length;q++)b._q[q]();e.Modernizr=b}(window,document);;
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
 *
 *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 *
 */

(function(window, document) {
'use strict';


// Exits early if all IntersectionObserver and IntersectionObserverEntry
// features are natively supported.
if ('IntersectionObserver' in window &&
    'IntersectionObserverEntry' in window &&
    'intersectionRatio' in window.IntersectionObserverEntry.prototype) {

  // Minimal polyfill for Edge 15's lack of `isIntersecting`
  // See: https://github.com/w3c/IntersectionObserver/issues/211
  if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {
    Object.defineProperty(window.IntersectionObserverEntry.prototype,
      'isIntersecting', {
      get: function () {
        return this.intersectionRatio > 0;
      }
    });
  }
  return;
}


/**
 * An IntersectionObserver registry. This registry exists to hold a strong
 * reference to IntersectionObserver instances currently observing a target
 * element. Without this registry, instances without another reference may be
 * garbage collected.
 */
var registry = [];


/**
 * Creates the global IntersectionObserverEntry constructor.
 * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry
 * @param {Object} entry A dictionary of instance properties.
 * @constructor
 */
function IntersectionObserverEntry(entry) {
  this.time = entry.time;
  this.target = entry.target;
  this.rootBounds = entry.rootBounds;
  this.boundingClientRect = entry.boundingClientRect;
  this.intersectionRect = entry.intersectionRect || getEmptyRect();
  this.isIntersecting = !!entry.intersectionRect;

  // Calculates the intersection ratio.
  var targetRect = this.boundingClientRect;
  var targetArea = targetRect.width * targetRect.height;
  var intersectionRect = this.intersectionRect;
  var intersectionArea = intersectionRect.width * intersectionRect.height;

  // Sets intersection ratio.
  if (targetArea) {
    // Round the intersection ratio to avoid floating point math issues:
    // https://github.com/w3c/IntersectionObserver/issues/324
    this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));
  } else {
    // If area is zero and is intersecting, sets to 1, otherwise to 0
    this.intersectionRatio = this.isIntersecting ? 1 : 0;
  }
}


/**
 * Creates the global IntersectionObserver constructor.
 * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface
 * @param {Function} callback The function to be invoked after intersection
 *     changes have queued. The function is not invoked if the queue has
 *     been emptied by calling the `takeRecords` method.
 * @param {Object=} opt_options Optional configuration options.
 * @constructor
 */
function IntersectionObserver(callback, opt_options) {

  var options = opt_options || {};

  if (typeof callback != 'function') {
    throw new Error('callback must be a function');
  }

  if (options.root && options.root.nodeType != 1) {
    throw new Error('root must be an Element');
  }

  // Binds and throttles `this._checkForIntersections`.
  this._checkForIntersections = throttle(
      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);

  // Private properties.
  this._callback = callback;
  this._observationTargets = [];
  this._queuedEntries = [];
  this._rootMarginValues = this._parseRootMargin(options.rootMargin);

  // Public properties.
  this.thresholds = this._initThresholds(options.threshold);
  this.root = options.root || null;
  this.rootMargin = this._rootMarginValues.map(function(margin) {
    return margin.value + margin.unit;
  }).join(' ');
}


/**
 * The minimum interval within which the document will be checked for
 * intersection changes.
 */
IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;


/**
 * The frequency in which the polyfill polls for intersection changes.
 * this can be updated on a per instance basis and must be set prior to
 * calling `observe` on the first target.
 */
IntersectionObserver.prototype.POLL_INTERVAL = null;

/**
 * Use a mutation observer on the root element
 * to detect intersection changes.
 */
IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;


/**
 * Starts observing a target element for intersection changes based on
 * the thresholds values.
 * @param {Element} target The DOM element to observe.
 */
IntersectionObserver.prototype.observe = function(target) {
  var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
    return item.element == target;
  });

  if (isTargetAlreadyObserved) {
    return;
  }

  if (!(target && target.nodeType == 1)) {
    throw new Error('target must be an Element');
  }

  this._registerInstance();
  this._observationTargets.push({element: target, entry: null});
  this._monitorIntersections();
  this._checkForIntersections();
};


/**
 * Stops observing a target element for intersection changes.
 * @param {Element} target The DOM element to observe.
 */
IntersectionObserver.prototype.unobserve = function(target) {
  this._observationTargets =
      this._observationTargets.filter(function(item) {

    return item.element != target;
  });
  if (!this._observationTargets.length) {
    this._unmonitorIntersections();
    this._unregisterInstance();
  }
};


/**
 * Stops observing all target elements for intersection changes.
 */
IntersectionObserver.prototype.disconnect = function() {
  this._observationTargets = [];
  this._unmonitorIntersections();
  this._unregisterInstance();
};


/**
 * Returns any queue entries that have not yet been reported to the
 * callback and clears the queue. This can be used in conjunction with the
 * callback to obtain the absolute most up-to-date intersection information.
 * @return {Array} The currently queued entries.
 */
IntersectionObserver.prototype.takeRecords = function() {
  var records = this._queuedEntries.slice();
  this._queuedEntries = [];
  return records;
};


/**
 * Accepts the threshold value from the user configuration object and
 * returns a sorted array of unique threshold values. If a value is not
 * between 0 and 1 and error is thrown.
 * @private
 * @param {Array|number=} opt_threshold An optional threshold value or
 *     a list of threshold values, defaulting to [0].
 * @return {Array} A sorted list of unique and valid threshold values.
 */
IntersectionObserver.prototype._initThresholds = function(opt_threshold) {
  var threshold = opt_threshold || [0];
  if (!Array.isArray(threshold)) threshold = [threshold];

  return threshold.sort().filter(function(t, i, a) {
    if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {
      throw new Error('threshold must be a number between 0 and 1 inclusively');
    }
    return t !== a[i - 1];
  });
};


/**
 * Accepts the rootMargin value from the user configuration object
 * and returns an array of the four margin values as an object containing
 * the value and unit properties. If any of the values are not properly
 * formatted or use a unit other than px or %, and error is thrown.
 * @private
 * @param {string=} opt_rootMargin An optional rootMargin value,
 *     defaulting to '0px'.
 * @return {Array<Object>} An array of margin objects with the keys
 *     value and unit.
 */
IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
  var marginString = opt_rootMargin || '0px';
  var margins = marginString.split(/\s+/).map(function(margin) {
    var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
    if (!parts) {
      throw new Error('rootMargin must be specified in pixels or percent');
    }
    return {value: parseFloat(parts[1]), unit: parts[2]};
  });

  // Handles shorthand.
  margins[1] = margins[1] || margins[0];
  margins[2] = margins[2] || margins[0];
  margins[3] = margins[3] || margins[1];

  return margins;
};


/**
 * Starts polling for intersection changes if the polling is not already
 * happening, and if the page's visibility state is visible.
 * @private
 */
IntersectionObserver.prototype._monitorIntersections = function() {
  if (!this._monitoringIntersections) {
    this._monitoringIntersections = true;

    // If a poll interval is set, use polling instead of listening to
    // resize and scroll events or DOM mutations.
    if (this.POLL_INTERVAL) {
      this._monitoringInterval = setInterval(
          this._checkForIntersections, this.POLL_INTERVAL);
    }
    else {
      addEvent(window, 'resize', this._checkForIntersections, true);
      addEvent(document, 'scroll', this._checkForIntersections, true);

      if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {
        this._domObserver = new MutationObserver(this._checkForIntersections);
        this._domObserver.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      }
    }
  }
};


/**
 * Stops polling for intersection changes.
 * @private
 */
IntersectionObserver.prototype._unmonitorIntersections = function() {
  if (this._monitoringIntersections) {
    this._monitoringIntersections = false;

    clearInterval(this._monitoringInterval);
    this._monitoringInterval = null;

    removeEvent(window, 'resize', this._checkForIntersections, true);
    removeEvent(document, 'scroll', this._checkForIntersections, true);

    if (this._domObserver) {
      this._domObserver.disconnect();
      this._domObserver = null;
    }
  }
};


/**
 * Scans each observation target for intersection changes and adds them
 * to the internal entries queue. If new entries are found, it
 * schedules the callback to be invoked.
 * @private
 */
IntersectionObserver.prototype._checkForIntersections = function() {
  var rootIsInDom = this._rootIsInDom();
  var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();

  this._observationTargets.forEach(function(item) {
    var target = item.element;
    var targetRect = getBoundingClientRect(target);
    var rootContainsTarget = this._rootContainsTarget(target);
    var oldEntry = item.entry;
    var intersectionRect = rootIsInDom && rootContainsTarget &&
        this._computeTargetAndRootIntersection(target, rootRect);

    var newEntry = item.entry = new IntersectionObserverEntry({
      time: now(),
      target: target,
      boundingClientRect: targetRect,
      rootBounds: rootRect,
      intersectionRect: intersectionRect
    });

    if (!oldEntry) {
      this._queuedEntries.push(newEntry);
    } else if (rootIsInDom && rootContainsTarget) {
      // If the new entry intersection ratio has crossed any of the
      // thresholds, add a new entry.
      if (this._hasCrossedThreshold(oldEntry, newEntry)) {
        this._queuedEntries.push(newEntry);
      }
    } else {
      // If the root is not in the DOM or target is not contained within
      // root but the previous entry for this target had an intersection,
      // add a new record indicating removal.
      if (oldEntry && oldEntry.isIntersecting) {
        this._queuedEntries.push(newEntry);
      }
    }
  }, this);

  if (this._queuedEntries.length) {
    this._callback(this.takeRecords(), this);
  }
};


/**
 * Accepts a target and root rect computes the intersection between then
 * following the algorithm in the spec.
 * TODO(philipwalton): at this time clip-path is not considered.
 * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo
 * @param {Element} target The target DOM element
 * @param {Object} rootRect The bounding rect of the root after being
 *     expanded by the rootMargin value.
 * @return {?Object} The final intersection rect object or undefined if no
 *     intersection is found.
 * @private
 */
IntersectionObserver.prototype._computeTargetAndRootIntersection =
    function(target, rootRect) {

  // If the element isn't displayed, an intersection can't happen.
  if (window.getComputedStyle(target).display == 'none') return;

  var targetRect = getBoundingClientRect(target);
  var intersectionRect = targetRect;
  var parent = getParentNode(target);
  var atRoot = false;

  while (!atRoot) {
    var parentRect = null;
    var parentComputedStyle = parent.nodeType == 1 ?
        window.getComputedStyle(parent) : {};

    // If the parent isn't displayed, an intersection can't happen.
    if (parentComputedStyle.display == 'none') return;

    if (parent == this.root || parent == document) {
      atRoot = true;
      parentRect = rootRect;
    } else {
      // If the element has a non-visible overflow, and it's not the <body>
      // or <html> element, update the intersection rect.
      // Note: <body> and <html> cannot be clipped to a rect that's not also
      // the document rect, so no need to compute a new intersection.
      if (parent != document.body &&
          parent != document.documentElement &&
          parentComputedStyle.overflow != 'visible') {
        parentRect = getBoundingClientRect(parent);
      }
    }

    // If either of the above conditionals set a new parentRect,
    // calculate new intersection data.
    if (parentRect) {
      intersectionRect = computeRectIntersection(parentRect, intersectionRect);

      if (!intersectionRect) break;
    }
    parent = getParentNode(parent);
  }
  return intersectionRect;
};


/**
 * Returns the root rect after being expanded by the rootMargin value.
 * @return {Object} The expanded root rect.
 * @private
 */
IntersectionObserver.prototype._getRootRect = function() {
  var rootRect;
  if (this.root) {
    rootRect = getBoundingClientRect(this.root);
  } else {
    // Use <html>/<body> instead of window since scroll bars affect size.
    var html = document.documentElement;
    var body = document.body;
    rootRect = {
      top: 0,
      left: 0,
      right: html.clientWidth || body.clientWidth,
      width: html.clientWidth || body.clientWidth,
      bottom: html.clientHeight || body.clientHeight,
      height: html.clientHeight || body.clientHeight
    };
  }
  return this._expandRectByRootMargin(rootRect);
};


/**
 * Accepts a rect and expands it by the rootMargin value.
 * @param {Object} rect The rect object to expand.
 * @return {Object} The expanded rect.
 * @private
 */
IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {
  var margins = this._rootMarginValues.map(function(margin, i) {
    return margin.unit == 'px' ? margin.value :
        margin.value * (i % 2 ? rect.width : rect.height) / 100;
  });
  var newRect = {
    top: rect.top - margins[0],
    right: rect.right + margins[1],
    bottom: rect.bottom + margins[2],
    left: rect.left - margins[3]
  };
  newRect.width = newRect.right - newRect.left;
  newRect.height = newRect.bottom - newRect.top;

  return newRect;
};


/**
 * Accepts an old and new entry and returns true if at least one of the
 * threshold values has been crossed.
 * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
 *    particular target element or null if no previous entry exists.
 * @param {IntersectionObserverEntry} newEntry The current entry for a
 *    particular target element.
 * @return {boolean} Returns true if a any threshold has been crossed.
 * @private
 */
IntersectionObserver.prototype._hasCrossedThreshold =
    function(oldEntry, newEntry) {

  // To make comparing easier, an entry that has a ratio of 0
  // but does not actually intersect is given a value of -1
  var oldRatio = oldEntry && oldEntry.isIntersecting ?
      oldEntry.intersectionRatio || 0 : -1;
  var newRatio = newEntry.isIntersecting ?
      newEntry.intersectionRatio || 0 : -1;

  // Ignore unchanged ratios
  if (oldRatio === newRatio) return;

  for (var i = 0; i < this.thresholds.length; i++) {
    var threshold = this.thresholds[i];

    // Return true if an entry matches a threshold or if the new ratio
    // and the old ratio are on the opposite sides of a threshold.
    if (threshold == oldRatio || threshold == newRatio ||
        threshold < oldRatio !== threshold < newRatio) {
      return true;
    }
  }
};


/**
 * Returns whether or not the root element is an element and is in the DOM.
 * @return {boolean} True if the root element is an element and is in the DOM.
 * @private
 */
IntersectionObserver.prototype._rootIsInDom = function() {
  return !this.root || containsDeep(document, this.root);
};


/**
 * Returns whether or not the target element is a child of root.
 * @param {Element} target The target element to check.
 * @return {boolean} True if the target element is a child of root.
 * @private
 */
IntersectionObserver.prototype._rootContainsTarget = function(target) {
  return containsDeep(this.root || document, target);
};


/**
 * Adds the instance to the global IntersectionObserver registry if it isn't
 * already present.
 * @private
 */
IntersectionObserver.prototype._registerInstance = function() {
  if (registry.indexOf(this) < 0) {
    registry.push(this);
  }
};


/**
 * Removes the instance from the global IntersectionObserver registry.
 * @private
 */
IntersectionObserver.prototype._unregisterInstance = function() {
  var index = registry.indexOf(this);
  if (index != -1) registry.splice(index, 1);
};


/**
 * Returns the result of the performance.now() method or null in browsers
 * that don't support the API.
 * @return {number} The elapsed time since the page was requested.
 */
function now() {
  return window.performance && performance.now && performance.now();
}


/**
 * Throttles a function and delays its execution, so it's only called at most
 * once within a given time period.
 * @param {Function} fn The function to throttle.
 * @param {number} timeout The amount of time that must pass before the
 *     function can be called again.
 * @return {Function} The throttled function.
 */
function throttle(fn, timeout) {
  var timer = null;
  return function () {
    if (!timer) {
      timer = setTimeout(function() {
        fn();
        timer = null;
      }, timeout);
    }
  };
}


/**
 * Adds an event handler to a DOM node ensuring cross-browser compatibility.
 * @param {Node} node The DOM node to add the event handler to.
 * @param {string} event The event name.
 * @param {Function} fn The event handler to add.
 * @param {boolean} opt_useCapture Optionally adds the even to the capture
 *     phase. Note: this only works in modern browsers.
 */
function addEvent(node, event, fn, opt_useCapture) {
  if (typeof node.addEventListener == 'function') {
    node.addEventListener(event, fn, opt_useCapture || false);
  }
  else if (typeof node.attachEvent == 'function') {
    node.attachEvent('on' + event, fn);
  }
}


/**
 * Removes a previously added event handler from a DOM node.
 * @param {Node} node The DOM node to remove the event handler from.
 * @param {string} event The event name.
 * @param {Function} fn The event handler to remove.
 * @param {boolean} opt_useCapture If the event handler was added with this
 *     flag set to true, it should be set to true here in order to remove it.
 */
function removeEvent(node, event, fn, opt_useCapture) {
  if (typeof node.removeEventListener == 'function') {
    node.removeEventListener(event, fn, opt_useCapture || false);
  }
  else if (typeof node.detatchEvent == 'function') {
    node.detatchEvent('on' + event, fn);
  }
}


/**
 * Returns the intersection between two rect objects.
 * @param {Object} rect1 The first rect.
 * @param {Object} rect2 The second rect.
 * @return {?Object} The intersection rect or undefined if no intersection
 *     is found.
 */
function computeRectIntersection(rect1, rect2) {
  var top = Math.max(rect1.top, rect2.top);
  var bottom = Math.min(rect1.bottom, rect2.bottom);
  var left = Math.max(rect1.left, rect2.left);
  var right = Math.min(rect1.right, rect2.right);
  var width = right - left;
  var height = bottom - top;

  return (width >= 0 && height >= 0) && {
    top: top,
    bottom: bottom,
    left: left,
    right: right,
    width: width,
    height: height
  };
}


/**
 * Shims the native getBoundingClientRect for compatibility with older IE.
 * @param {Element} el The element whose bounding rect to get.
 * @return {Object} The (possibly shimmed) rect of the element.
 */
function getBoundingClientRect(el) {
  var rect;

  try {
    rect = el.getBoundingClientRect();
  } catch (err) {
    // Ignore Windows 7 IE11 "Unspecified error"
    // https://github.com/w3c/IntersectionObserver/pull/205
  }

  if (!rect) return getEmptyRect();

  // Older IE
  if (!(rect.width && rect.height)) {
    rect = {
      top: rect.top,
      right: rect.right,
      bottom: rect.bottom,
      left: rect.left,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };
  }
  return rect;
}


/**
 * Returns an empty rect object. An empty rect is returned when an element
 * is not in the DOM.
 * @return {Object} The empty rect.
 */
function getEmptyRect() {
  return {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    width: 0,
    height: 0
  };
}

/**
 * Checks to see if a parent element contains a child element (including inside
 * shadow DOM).
 * @param {Node} parent The parent element.
 * @param {Node} child The child element.
 * @return {boolean} True if the parent node contains the child node.
 */
function containsDeep(parent, child) {
  var node = child;
  while (node) {
    if (node == parent) return true;

    node = getParentNode(node);
  }
  return false;
}


/**
 * Gets the parent node of an element or its host element if the parent node
 * is a shadow root.
 * @param {Node} node The node whose parent to get.
 * @return {Node|null} The parent node or null if no parent exists.
 */
function getParentNode(node) {
  var parent = node.parentNode;

  if (parent && parent.nodeType == 11 && parent.host) {
    // If the parent is a shadow root, return the host element.
    return parent.host;
  }
  return parent;
}


// Exposes the constructors globally.
window.IntersectionObserver = IntersectionObserver;
window.IntersectionObserverEntry = IntersectionObserverEntry;

}(window, document));

/*!
 * JavaScript Cookie v2.2.1
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
;(function (factory) {
	var registeredInModuleLoader;
	if (typeof define === 'function' && define.amd) {
		define(factory);
		registeredInModuleLoader = true;
	}
	if (typeof exports === 'object') {
		module.exports = factory();
		registeredInModuleLoader = true;
	}
	if (!registeredInModuleLoader) {
		var OldCookies = window.Cookies;
		var api = window.Cookies = factory();
		api.noConflict = function () {
			window.Cookies = OldCookies;
			return api;
		};
	}
}(function () {
	function extend () {
		var i = 0;
		var result = {};
		for (; i < arguments.length; i++) {
			var attributes = arguments[ i ];
			for (var key in attributes) {
				result[key] = attributes[key];
			}
		}
		return result;
	}

	function decode (s) {
		return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
	}

	function init (converter) {
		function api() {}

		function set (key, value, attributes) {
			if (typeof document === 'undefined') {
				return;
			}

			attributes = extend({
				path: '/'
			}, api.defaults, attributes);

			if (typeof attributes.expires === 'number') {
				attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
			}

			// We're using "expires" because "max-age" is not supported by IE
			attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

			try {
				var result = JSON.stringify(value);
				if (/^[\{\[]/.test(result)) {
					value = result;
				}
			} catch (e) {}

			value = converter.write ?
				converter.write(value, key) :
				encodeURIComponent(String(value))
					.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);

			key = encodeURIComponent(String(key))
				.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)
				.replace(/[\(\)]/g, escape);

			var stringifiedAttributes = '';
			for (var attributeName in attributes) {
				if (!attributes[attributeName]) {
					continue;
				}
				stringifiedAttributes += '; ' + attributeName;
				if (attributes[attributeName] === true) {
					continue;
				}

				// Considers RFC 6265 section 5.2:
				// ...
				// 3.  If the remaining unparsed-attributes contains a %x3B (";")
				//     character:
				// Consume the characters of the unparsed-attributes up to,
				// not including, the first %x3B (";") character.
				// ...
				stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
			}

			return (document.cookie = key + '=' + value + stringifiedAttributes);
		}

		function get (key, json) {
			if (typeof document === 'undefined') {
				return;
			}

			var jar = {};
			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all.
			var cookies = document.cookie ? document.cookie.split('; ') : [];
			var i = 0;

			for (; i < cookies.length; i++) {
				var parts = cookies[i].split('=');
				var cookie = parts.slice(1).join('=');

				if (!json && cookie.charAt(0) === '"') {
					cookie = cookie.slice(1, -1);
				}

				try {
					var name = decode(parts[0]);
					cookie = (converter.read || converter)(cookie, name) ||
						decode(cookie);

					if (json) {
						try {
							cookie = JSON.parse(cookie);
						} catch (e) {}
					}

					jar[name] = cookie;

					if (key === name) {
						break;
					}
				} catch (e) {}
			}

			return key ? jar[key] : jar;
		}

		api.set = set;
		api.get = function (key) {
			return get(key, false /* read as raw */);
		};
		api.getJSON = function (key) {
			return get(key, true /* read as json */);
		};
		api.remove = function (key, attributes) {
			set(key, '', extend(attributes, {
				expires: -1
			}));
		};

		api.defaults = {};

		api.withConverter = init;

		return api;
	}

	return init(function () {});
}));

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.scrollama = factory());
}(this, (function () { 'use strict';

// DOM helper functions

// private
function selectionToArray(selection) {
  var len = selection.length;
  var result = [];
  for (var i = 0; i < len; i += 1) {
    result.push(selection[i]);
  }
  return result;
}

// public
function select(selector) {
  if (selector instanceof Element) { return selector; }
  else if (typeof selector === 'string')
    { return document.querySelector(selector); }
  return null;
}

function selectAll(selector, parent) {
  if ( parent === void 0 ) parent = document;

  if (typeof selector === 'string') {
    return selectionToArray(parent.querySelectorAll(selector));
  } else if (selector instanceof Element) {
    return selectionToArray([selector]);
  } else if (selector instanceof NodeList) {
    return selectionToArray(selector);
  } else if (selector instanceof Array) {
    return selector;
  }
  return [];
}

function getStepId(ref) {
  var id = ref.id;
  var i = ref.i;

  return ("scrollama__debug-step--" + id + "-" + i);
}

function getOffsetId(ref) {
  var id = ref.id;

  return ("scrollama__debug-offset--" + id);
}

// SETUP

function setupOffset(ref) {
  var id = ref.id;
  var offsetVal = ref.offsetVal;
  var stepClass = ref.stepClass;

  var el = document.createElement('div');
  el.setAttribute('id', getOffsetId({ id: id }));
  el.setAttribute('class', 'scrollama__debug-offset');

  el.style.position = 'fixed';
  el.style.left = '0';
  el.style.width = '100%';
  el.style.height = '0px';
  el.style.borderTop = '2px dashed black';
  el.style.zIndex = '9999';

  var text = document.createElement('p');
  text.innerText = "\"." + stepClass + "\" trigger: " + offsetVal;
  text.style.fontSize = '12px';
  text.style.fontFamily = 'monospace';
  text.style.color = 'black';
  text.style.margin = '0';
  text.style.padding = '6px';
  el.appendChild(text);
  document.body.appendChild(el);
}

function setup(ref) {
  var id = ref.id;
  var offsetVal = ref.offsetVal;
  var stepEl = ref.stepEl;

  var stepClass = stepEl[0].getAttribute('class');
  setupOffset({ id: id, offsetVal: offsetVal, stepClass: stepClass });
}

// UPDATE
function updateOffset(ref) {
  var id = ref.id;
  var offsetMargin = ref.offsetMargin;
  var offsetVal = ref.offsetVal;

  var idVal = getOffsetId({ id: id });
  var el = document.querySelector(("#" + idVal));
  el.style.top = offsetMargin + "px";
}

function update(ref) {
  var id = ref.id;
  var stepOffsetHeight = ref.stepOffsetHeight;
  var offsetMargin = ref.offsetMargin;
  var offsetVal = ref.offsetVal;

  updateOffset({ id: id, offsetMargin: offsetMargin });
}

function notifyStep(ref) {
  var id = ref.id;
  var index = ref.index;
  var state = ref.state;

  var idVal = getStepId({ id: id, i: index });
  var elA = document.querySelector(("#" + idVal + "_above"));
  var elB = document.querySelector(("#" + idVal + "_below"));
  var display = state === 'enter' ? 'block' : 'none';

  if (elA) { elA.style.display = display; }
  if (elB) { elB.style.display = display; }
}

function scrollama() {
  var ZERO_MOE = 1; // zero with some rounding margin of error
  var callback = {};
  var io = {};

  var containerEl = null;
  var graphicEl = null;
  var stepEl = null;

  var id = null;
  var offsetVal = 0;
  var offsetMargin = 0;
  var vh = 0;
  var ph = 0;
  var stepOffsetHeight = null;
  var stepOffsetTop = null;
  var bboxGraphic = null;

  var isReady = false;
  var isEnabled = false;
  var debugMode = false;
  var progressMode = false;
  var progressThreshold = 0;
  var preserveOrder = false;
  var triggerOnce = false;

  var stepStates = null;
  var containerState = null;
  var previousYOffset = -1;
  var direction = null;

  var exclude = [];

  // HELPERS
  function generateId() {
    var a = 'abcdefghijklmnopqrstuv';
    var l = a.length;
    var t = new Date().getTime();
    var r = [0, 0, 0].map(function (d) { return a[Math.floor(Math.random() * l)]; }).join('');
    return ("" + r + t);
  }

  //www.gomakethings.com/how-to-get-an-elements-distance-from-the-top-of-the-page-with-vanilla-javascript/
  function getOffsetTop(el) {
    // Set our distance placeholder
    var distance = 0;

    // Loop up the DOM
    if (el.offsetParent) {
      do {
        distance += el.offsetTop;
        el = el.offsetParent;
      } while (el);
    }

    // Return our distance
    return distance < 0 ? 0 : distance;
  }

  function getPageHeight() {
    var body = document.body;
    var html = document.documentElement;

    return Math.max(
      body.scrollHeight,
      body.offsetHeight,
      html.clientHeight,
      html.scrollHeight,
      html.offsetHeight
    );
  }

  function getIndex(element) {
    return +element.getAttribute('data-scrollama-index');
  }

  function updateDirection() {
    if (window.pageYOffset > previousYOffset) { direction = 'down'; }
    else if (window.pageYOffset < previousYOffset) { direction = 'up'; }
    previousYOffset = window.pageYOffset;
  }

  function handleResize() {
    vh = window.innerHeight;
    ph = getPageHeight();

    bboxGraphic = graphicEl ? graphicEl.getBoundingClientRect() : null;

    offsetMargin = offsetVal * vh;

    stepOffsetHeight = stepEl ? stepEl.map(function (el) { return el.offsetHeight; }) : [];

    stepOffsetTop = stepEl ? stepEl.map(getOffsetTop) : [];

    if (isEnabled && isReady) { updateIO(); }

    if (debugMode)
      { update({ id: id, stepOffsetHeight: stepOffsetHeight, offsetMargin: offsetMargin, offsetVal: offsetVal }); }
  }

  function handleEnable(enable) {
    if (enable && !isEnabled) {
      if (isReady) { updateIO(); }
      isEnabled = true;
    } else if (!enable) {
      if (io.top) { io.top.disconnect(); }
      if (io.bottom) { io.bottom.disconnect(); }
      if (io.stepAbove) { io.stepAbove.forEach(function (d) { return d.disconnect(); }); }
      if (io.stepBelow) { io.stepBelow.forEach(function (d) { return d.disconnect(); }); }
      if (io.stepProgress) { io.stepProgress.forEach(function (d) { return d.disconnect(); }); }
      if (io.viewportAbove) { io.viewportAbove.forEach(function (d) { return d.disconnect(); }); }
      if (io.viewportBelow) { io.viewportBelow.forEach(function (d) { return d.disconnect(); }); }
      isEnabled = false;
    }
  }

  function createThreshold(height) {
    var count = Math.ceil(height / progressThreshold);
    var t = [];
    var ratio = 1 / count;
    for (var i = 0; i < count; i++) {
      t.push(i * ratio);
    }
    return t;
  }

  // NOTIFY CALLBACKS
  function notifyOthers(index, location) {
    if (location === 'above') {
      // check if steps above/below were skipped and should be notified first
      for (var i = 0; i < index; i++) {
        var ss = stepStates[i];
        if (ss.state === 'enter') { notifyStepExit(stepEl[i], 'down'); }
        if (ss.direction === 'up') {
          notifyStepEnter(stepEl[i], 'down', false);
          notifyStepExit(stepEl[i], 'down');
        }
      }
    } else if (location === 'below') {
      for (var i$1 = stepStates.length - 1; i$1 > index; i$1--) {
        var ss$1 = stepStates[i$1];
        if (ss$1.state === 'enter') {
          notifyStepExit(stepEl[i$1], 'up');
        }
        if (ss$1.direction === 'down') {
          notifyStepEnter(stepEl[i$1], 'up', false);
          notifyStepExit(stepEl[i$1], 'up');
        }
      }
    }
  }

  function notifyStepEnter(element, direction, check) {
    if ( check === void 0 ) check = true;

    var index = getIndex(element);
    var resp = { element: element, index: index, direction: direction };

    // store most recent trigger
    stepStates[index].direction = direction;
    stepStates[index].state = 'enter';

    if (preserveOrder && check && direction === 'down')
      { notifyOthers(index, 'above'); }

    if (preserveOrder && check && direction === 'up')
      { notifyOthers(index, 'below'); }

    if (
      callback.stepEnter &&
      typeof callback.stepEnter === 'function' &&
      !exclude[index]
    ) {
      callback.stepEnter(resp, stepStates);
      if (debugMode) { notifyStep({ id: id, index: index, state: 'enter' }); }
      if (triggerOnce) { exclude[index] = true; }
    }

    if (progressMode) {
      if (direction === 'down') { notifyStepProgress(element, 0); }
      else { notifyStepProgress(element, 1); }
    }
  }

  function notifyStepExit(element, direction) {
    var index = getIndex(element);
    var resp = { element: element, index: index, direction: direction };

    // store most recent trigger
    stepStates[index].direction = direction;
    stepStates[index].state = 'exit';

    if (progressMode) {
      if (direction === 'down') { notifyStepProgress(element, 1); }
      else { notifyStepProgress(element, 0); }
    }

    if (callback.stepExit && typeof callback.stepExit === 'function') {
      callback.stepExit(resp, stepStates);
      if (debugMode) { notifyStep({ id: id, index: index, state: 'exit' }); }
    }
  }

  function notifyStepProgress(element, progress) {
    var index = getIndex(element);
    var resp = { element: element, index: index, progress: progress };
    if (callback.stepProgress && typeof callback.stepProgress === 'function')
      { callback.stepProgress(resp); }
  }

  function notifyContainerEnter() {
    var resp = { direction: direction };
    containerState.direction = direction;
    containerState.state = 'enter';
    if (
      callback.containerEnter &&
      typeof callback.containerEnter === 'function'
    )
      { callback.containerEnter(resp); }
  }

  function notifyContainerExit() {
    var resp = { direction: direction };
    containerState.direction = direction;
    containerState.state = 'exit';
    if (callback.containerExit && typeof callback.containerExit === 'function')
      { callback.containerExit(resp); }
  }

  // OBSERVER - INTERSECT HANDLING

  // if TOP edge of step crosses threshold,
  // bottom must be > 0 which means it is on "screen" (shifted by offset)
  function intersectStepAbove(entries) {
    updateDirection();
    entries.forEach(function (entry) {
      var isIntersecting = entry.isIntersecting;
      var boundingClientRect = entry.boundingClientRect;
      var target = entry.target;

      // bottom is how far bottom edge of el is from top of viewport
      var bottom = boundingClientRect.bottom;
      var height = boundingClientRect.height;
      var bottomAdjusted = bottom - offsetMargin;
      var index = getIndex(target);
      var ss = stepStates[index];

      if (bottomAdjusted >= -ZERO_MOE) {
        if (isIntersecting && direction === 'down' && ss.state !== 'enter')
          { notifyStepEnter(target, direction); }
        else if (!isIntersecting && direction === 'up' && ss.state === 'enter')
          { notifyStepExit(target, direction); }
        else if (
          !isIntersecting &&
          bottomAdjusted >= height &&
          direction === 'down' &&
          ss.state === 'enter'
        ) {
          notifyStepExit(target, direction);
        }
      }
    });
  }

  function intersectStepBelow(entries) {
    updateDirection();
    entries.forEach(function (entry) {
      var isIntersecting = entry.isIntersecting;
      var boundingClientRect = entry.boundingClientRect;
      var target = entry.target;

      var bottom = boundingClientRect.bottom;
      var height = boundingClientRect.height;
      var bottomAdjusted = bottom - offsetMargin;
      var index = getIndex(target);
      var ss = stepStates[index];

      if (
        bottomAdjusted >= -ZERO_MOE &&
        bottomAdjusted < height &&
        isIntersecting &&
        direction === 'up' &&
        ss.state !== 'enter'
      ) {
        notifyStepEnter(target, direction);
      } else if (
        bottomAdjusted <= ZERO_MOE &&
        !isIntersecting &&
        direction === 'down' &&
        ss.state === 'enter'
      ) {
        notifyStepExit(target, direction);
      }
    });
  }

  /*
	if there is a scroll event where a step never intersects (therefore
	skipping an enter/exit trigger), use this fallback to detect if it is
	in view
	*/
  function intersectViewportAbove(entries) {
    updateDirection();
    entries.forEach(function (entry) {
      var isIntersecting = entry.isIntersecting;
      var target = entry.target;
      var index = getIndex(target);
      var ss = stepStates[index];
      if (
        isIntersecting &&
        direction === 'down' &&
        ss.state !== 'enter' &&
        ss.direction !== 'down'
      ) {
        notifyStepEnter(target, 'down');
        notifyStepExit(target, 'down');
      }
    });
  }

  function intersectViewportBelow(entries) {
    updateDirection();
    entries.forEach(function (entry) {
      var isIntersecting = entry.isIntersecting;
      var target = entry.target;
      var index = getIndex(target);
      var ss = stepStates[index];
      if (
        isIntersecting &&
        direction === 'up' &&
        ss.state !== 'enter' &&
        ss.direction !== 'up'
      ) {
        notifyStepEnter(target, 'up');
        notifyStepExit(target, 'up');
      }
    });
  }

  function intersectStepProgress(entries) {
    updateDirection();
    entries.forEach(
      function (ref) {
        var isIntersecting = ref.isIntersecting;
        var intersectionRatio = ref.intersectionRatio;
        var boundingClientRect = ref.boundingClientRect;
        var target = ref.target;

        var bottom = boundingClientRect.bottom;
        var bottomAdjusted = bottom - offsetMargin;

        if (isIntersecting && bottomAdjusted >= -ZERO_MOE) {
          notifyStepProgress(target, +intersectionRatio.toFixed(3));
        }
      }
    );
  }

  function intersectTop(entries) {
    updateDirection();
    var ref = entries[0];
    var isIntersecting = ref.isIntersecting;
    var boundingClientRect = ref.boundingClientRect;
    var top = boundingClientRect.top;
    var bottom = boundingClientRect.bottom;

    if (bottom > -ZERO_MOE) {
      if (isIntersecting) { notifyContainerEnter(direction); }
      else if (containerState.state === 'enter') { notifyContainerExit(direction); }
    }
  }

  function intersectBottom(entries) {
    updateDirection();
    var ref = entries[0];
    var isIntersecting = ref.isIntersecting;
    var boundingClientRect = ref.boundingClientRect;
    var top = boundingClientRect.top;

    if (top < ZERO_MOE) {
      if (isIntersecting) { notifyContainerEnter(direction); }
      else if (containerState.state === 'enter') { notifyContainerExit(direction); }
    }
  }

  // OBSERVER - CREATION

  function updateTopIO() {
    if (io.top) { io.top.unobserve(containerEl); }

    var options = {
      root: null,
      rootMargin: (vh + "px 0px -" + vh + "px 0px"),
      threshold: 0
    };

    io.top = new IntersectionObserver(intersectTop, options);
    io.top.observe(containerEl);
  }

  function updateBottomIO() {
    if (io.bottom) { io.bottom.unobserve(containerEl); }
    var options = {
      root: null,
      rootMargin: ("-" + (bboxGraphic.height) + "px 0px " + (bboxGraphic.height) + "px 0px"),
      threshold: 0
    };

    io.bottom = new IntersectionObserver(intersectBottom, options);
    io.bottom.observe(containerEl);
  }

  // top edge
  function updateStepAboveIO() {
    if (io.stepAbove) { io.stepAbove.forEach(function (d) { return d.disconnect(); }); }

    io.stepAbove = stepEl.map(function (el, i) {
      var marginTop = stepOffsetHeight[i];
      var marginBottom = -vh + offsetMargin;
      var rootMargin = marginTop + "px 0px " + marginBottom + "px 0px";

      var options = {
        root: null,
        rootMargin: rootMargin,
        threshold: 0
      };

      var obs = new IntersectionObserver(intersectStepAbove, options);
      obs.observe(el);
      return obs;
    });
  }

  // bottom edge
  function updateStepBelowIO() {
    if (io.stepBelow) { io.stepBelow.forEach(function (d) { return d.disconnect(); }); }

    io.stepBelow = stepEl.map(function (el, i) {
      var marginTop = -offsetMargin;
      var marginBottom = ph - vh + stepOffsetHeight[i] + offsetMargin;
      var rootMargin = marginTop + "px 0px " + marginBottom + "px 0px";

      var options = {
        root: null,
        rootMargin: rootMargin,
        threshold: 0
      };

      var obs = new IntersectionObserver(intersectStepBelow, options);
      obs.observe(el);
      return obs;
    });
  }

  // jump into viewport
  function updateViewportAboveIO() {
    if (io.viewportAbove) { io.viewportAbove.forEach(function (d) { return d.disconnect(); }); }
    io.viewportAbove = stepEl.map(function (el, i) {
      var marginTop = stepOffsetTop[i];
      var marginBottom = -(vh - offsetMargin + stepOffsetHeight[i]);
      var rootMargin = marginTop + "px 0px " + marginBottom + "px 0px";
      var options = {
        root: null,
        rootMargin: rootMargin,
        threshold: 0
      };

      var obs = new IntersectionObserver(intersectViewportAbove, options);
      obs.observe(el);
      return obs;
    });
  }

  function updateViewportBelowIO() {
    if (io.viewportBelow) { io.viewportBelow.forEach(function (d) { return d.disconnect(); }); }
    io.viewportBelow = stepEl.map(function (el, i) {
      var marginTop = -(offsetMargin + stepOffsetHeight[i]);
      var marginBottom =
        ph - stepOffsetTop[i] - stepOffsetHeight[i] - offsetMargin;
      var rootMargin = marginTop + "px 0px " + marginBottom + "px 0px";
      var options = {
        root: null,
        rootMargin: rootMargin,
        threshold: 0
      };

      var obs = new IntersectionObserver(intersectViewportBelow, options);
      obs.observe(el);
      return obs;
    });
  }

  // progress progress tracker
  function updateStepProgressIO() {
    if (io.stepProgress) { io.stepProgress.forEach(function (d) { return d.disconnect(); }); }

    io.stepProgress = stepEl.map(function (el, i) {
      var marginTop = stepOffsetHeight[i] - offsetMargin;
      var marginBottom = -vh + offsetMargin;
      var rootMargin = marginTop + "px 0px " + marginBottom + "px 0px";

      var threshold = createThreshold(stepOffsetHeight[i]);
      var options = {
        root: null,
        rootMargin: rootMargin,
        threshold: threshold
      };

      var obs = new IntersectionObserver(intersectStepProgress, options);
      obs.observe(el);
      return obs;
    });
  }

  function updateIO() {
    updateViewportAboveIO();
    updateViewportBelowIO();
    updateStepAboveIO();
    updateStepBelowIO();

    if (progressMode) { updateStepProgressIO(); }

    if (containerEl && graphicEl) {
      updateTopIO();
      updateBottomIO();
    }
  }

  // SETUP FUNCTIONS

  function indexSteps() {
    stepEl.forEach(function (el, i) { return el.setAttribute('data-scrollama-index', i); });
  }

  function setupStates() {
    stepStates = stepEl.map(function () { return ({
      direction: null,
      state: null
    }); });

    containerState = { direction: null, state: null };
  }

  function addDebug() {
    if (debugMode) { setup({ id: id, stepEl: stepEl, offsetVal: offsetVal }); }
  }

  var S = {};

  S.setup = function (ref) {
    var container = ref.container;
    var graphic = ref.graphic;
    var step = ref.step;
    var offset = ref.offset; if ( offset === void 0 ) offset = 0.5;
    var progress = ref.progress; if ( progress === void 0 ) progress = false;
    var threshold = ref.threshold; if ( threshold === void 0 ) threshold = 4;
    var debug = ref.debug; if ( debug === void 0 ) debug = false;
    var order = ref.order; if ( order === void 0 ) order = true;
    var once = ref.once; if ( once === void 0 ) once = false;

    id = generateId();
    // elements
    stepEl = selectAll(step);
    containerEl = container ? select(container) : null;
    graphicEl = graphic ? select(graphic) : null;

    // error if no step selected
    if (!stepEl.length) {
      console.error('scrollama error: no step elements');
      return S;
    }

    // options
    debugMode = debug;
    progressMode = progress;
    preserveOrder = order;
    triggerOnce = once;

    S.offsetTrigger(offset);
    progressThreshold = Math.max(1, +threshold);

    isReady = true;

    // customize
    addDebug();
    indexSteps();
    setupStates();
    handleResize();
    handleEnable(true);
    return S;
  };

  S.resize = function () {
    handleResize();
    return S;
  };

  S.enable = function () {
    handleEnable(true);
    return S;
  };

  S.disable = function () {
    handleEnable(false);
    return S;
  };

  S.destroy = function () {
    handleEnable(false);
    Object.keys(callback).forEach(function (c) { return (callback[c] = null); });
    Object.keys(io).forEach(function (i) { return (io[i] = null); });
  };

  S.offsetTrigger = function(x) {
    if (x && !isNaN(x)) {
      offsetVal = Math.min(Math.max(0, x), 1);
      return S;
    }
    return offsetVal;
  };

  S.onStepEnter = function (cb) {
    callback.stepEnter = cb;
    return S;
  };

  S.onStepExit = function (cb) {
    callback.stepExit = cb;
    return S;
  };

  S.onStepProgress = function (cb) {
    callback.stepProgress = cb;
    return S;
  };

  S.onContainerEnter = function (cb) {
    callback.containerEnter = cb;
    return S;
  };

  S.onContainerExit = function (cb) {
    callback.containerExit = cb;
    return S;
  };

  return S;
}

return scrollama;

})));

/**
 * author Christopher Blum
 *    - based on the idea of Remy Sharp, http://remysharp.com/2009/01/26/element-in-view-event-plugin/
 *    - forked from http://github.com/zuk/jquery.inview/
 */
(function (factory) {
  if (typeof define == 'function' && define.amd) {
    // AMD
    define(['jquery'], factory);
  } else if (typeof exports === 'object') {
    // Node, CommonJS
    module.exports = factory(require('jquery'));
  } else {
      // Browser globals
    factory(jQuery);
  }
}(function ($) {

  var inviewObjects = [], viewportSize, viewportOffset,
      d = document, w = window, documentElement = d.documentElement, timer;

  $.event.special.inview = {
    add: function(data) {
      inviewObjects.push({ data: data, $element: $(this), element: this });
      // Use setInterval in order to also make sure this captures elements within
      // "overflow:scroll" elements or elements that appeared in the dom tree due to
      // dom manipulation and reflow
      // old: $(window).scroll(checkInView);
      //
      // By the way, iOS (iPad, iPhone, ...) seems to not execute, or at least delays
      // intervals while the user scrolls. Therefore the inview event might fire a bit late there
      //
      // Don't waste cycles with an interval until we get at least one element that
      // has bound to the inview event.
      if (!timer && inviewObjects.length) {
         timer = setInterval(checkInView, 250);
      }
    },

    remove: function(data) {
      for (var i=0; i<inviewObjects.length; i++) {
        var inviewObject = inviewObjects[i];
        if (inviewObject.element === this && inviewObject.data.guid === data.guid) {
          inviewObjects.splice(i, 1);
          break;
        }
      }

      // Clear interval when we no longer have any elements listening
      if (!inviewObjects.length) {
         clearInterval(timer);
         timer = null;
      }
    }
  };

  function getViewportSize() {
    var mode, domObject, size = { height: w.innerHeight, width: w.innerWidth };

    // if this is correct then return it. iPad has compat Mode, so will
    // go into check clientHeight/clientWidth (which has the wrong value).
    if (!size.height) {
      mode = d.compatMode;
      if (mode || !$.support.boxModel) { // IE, Gecko
        domObject = mode === 'CSS1Compat' ?
          documentElement : // Standards
          d.body; // Quirks
        size = {
          height: domObject.clientHeight,
          width:  domObject.clientWidth
        };
      }
    }

    return size;
  }

  function getViewportOffset() {
    return {
      top:  w.pageYOffset || documentElement.scrollTop   || d.body.scrollTop,
      left: w.pageXOffset || documentElement.scrollLeft  || d.body.scrollLeft
    };
  }

  function checkInView() {
    if (!inviewObjects.length) {
      return;
    }

    var i = 0, $elements = $.map(inviewObjects, function(inviewObject) {
      var selector  = inviewObject.data.selector,
          $element  = inviewObject.$element;
      return selector ? $element.find(selector) : $element;
    });

    viewportSize   = viewportSize   || getViewportSize();
    viewportOffset = viewportOffset || getViewportOffset();

    for (; i<inviewObjects.length; i++) {
      // Ignore elements that are not in the DOM tree
      if (!$.contains(documentElement, $elements[i][0])) {
        continue;
      }

      var $element      = $($elements[i]),
          elementSize   = { height: $element[0].offsetHeight, width: $element[0].offsetWidth },
          elementOffset = $element.offset(),
          inView        = $element.data('inview');

      // Don't ask me why because I haven't figured out yet:
      // viewportOffset and viewportSize are sometimes suddenly null in Firefox 5.
      // Even though it sounds weird:
      // It seems that the execution of this function is interferred by the onresize/onscroll event
      // where viewportOffset and viewportSize are unset
      if (!viewportOffset || !viewportSize) {
        return;
      }

      if (elementOffset.top + elementSize.height > viewportOffset.top &&
          elementOffset.top < viewportOffset.top + viewportSize.height &&
          elementOffset.left + elementSize.width > viewportOffset.left &&
          elementOffset.left < viewportOffset.left + viewportSize.width) {
        if (!inView) {
          $element.data('inview', true).trigger('inview', [true]);
        }
      } else if (inView) {
        $element.data('inview', false).trigger('inview', [false]);
      }
    }
  }

  $(w).bind("scroll resize scrollstop", function() {
    viewportSize = viewportOffset = null;
  });

  // IE < 9 scrolls to focused elements without firing the "scroll" event
  if (!documentElement.addEventListener && documentElement.attachEvent) {
    documentElement.attachEvent("onfocusin", function() {
      viewportOffset = null;
    });
  }
}));

/**
 * velocity-animate (C) 2014-2017 Julian Shapiro.
 *
 * Licensed under the MIT license. See LICENSE file in the project root for details.
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.Velocity = factory());
}(this, (function () { 'use strict';

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  /**
   * Check if a variable is a boolean.
   */
  function isBoolean(variable) {
      return variable === true || variable === false;
  }
  /**
   * Check if a variable is a function.
   */
  function isFunction(variable) {
      return Object.prototype.toString.call(variable) === "[object Function]";
  }
  /**
   * Check if a variable is an HTMLElement or SVGElement.
   */
  function isNode(variable) {
      return !!(variable && variable.nodeType);
  }
  /**
   * Check if a variable is a number.
   */
  function isNumber(variable) {
      return typeof variable === "number";
  }
  /**
   * Check if a variable is a plain object (and not an instance).
   */
  function isPlainObject(variable) {
      if (!variable || (typeof variable === "undefined" ? "undefined" : _typeof(variable)) !== "object" || variable.nodeType || Object.prototype.toString.call(variable) !== "[object Object]") {
          return false;
      }
      var proto = Object.getPrototypeOf(variable);
      return !proto || proto.hasOwnProperty("constructor") && proto.constructor === Object;
  }
  /**
   * Check if a variable is a string.
   */
  function isString(variable) {
      return typeof variable === "string";
  }
  /**
   * Check if a variable is the result of calling Velocity.
   */
  function isVelocityResult(variable) {
      return variable && isNumber(variable.length) && isFunction(variable.velocity);
  }
  /**
   * Check if a variable is an array-like wrapped jQuery, Zepto or similar, where
   * each indexed value is a Node.
   */
  function isWrapped(variable) {
      return variable && variable !== window && isNumber(variable.length) && !isString(variable) && !isFunction(variable) && !isNode(variable) && (variable.length === 0 || isNode(variable[0]));
  }
  /**
   * Check is a property is an enumerable member of an object.
   */
  function propertyIsEnumerable(obj, property) {
      return Object.prototype.propertyIsEnumerable.call(obj, property);
  }

  // Project
  /**
   * Add a single className to an Element.
   */
  function addClass(element, className) {
      if (element instanceof Element) {
          if (element.classList) {
              element.classList.add(className);
          } else {
              removeClass(element, className);
              element.className += (element.className.length ? " " : "") + className;
          }
      }
  }
  /**
   * Clone an array, works for array-like too.
   */
  function cloneArray(arrayLike) {
      return Array.prototype.slice.call(arrayLike, 0);
  }
  /**
   * The <strong><code>defineProperty()</code></strong> function provides a
   * shortcut to defining a property that cannot be accidentally iterated across.
   */
  function defineProperty$1(proto, name, value, readonly) {
      if (proto) {
          Object.defineProperty(proto, name, {
              configurable: !readonly,
              writable: !readonly,
              value: value
          });
      }
  }
  /**
   * When there are multiple locations for a value pass them all in, then get the
   * first value that is valid.
   */
  function getValue() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
          for (var _iterator = arguments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var arg = _step.value;

              if (arg !== undefined && arg === arg) {
                  return arg;
              }
          }
      } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
      } finally {
          try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
              }
          } finally {
              if (_didIteratorError) {
                  throw _iteratorError;
              }
          }
      }
  }
  /**
   * Shim to get the current milliseconds - on anything except old IE it'll use
   * Date.now() and save creating an object. If that doesn't exist then it'll
   * create one that gets GC.
   */
  var now = Date.now ? Date.now : function () {
      return new Date().getTime();
  };
  /**
   * Remove a single className from an Element.
   */
  function removeClass(element, className) {
      if (element instanceof Element) {
          if (element.classList) {
              element.classList.remove(className);
          } else {
              // TODO: Need some jsperf tests on performance - can we get rid of the regex and maybe use split / array manipulation?
              element.className = element.className.replace(new RegExp("(^|\\s)" + className + "(\\s|$)", "gi"), " ");
          }
      }
  }

  // Project
  // Constants
  var Actions = {};
  /**
   * Used to register an action. This should never be called by users
   * directly, instead it should be called via  an action:<br/>
   * <code>Velocity("registerAction", "name", VelocityActionFn);</code>
   */
  function registerAction(args, internal) {
      var name = args[0],
          callback = args[1];
      if (!isString(name)) {
          console.warn("VelocityJS: Trying to set 'registerAction' name to an invalid value:", name);
      } else if (!isFunction(callback)) {
          console.warn("VelocityJS: Trying to set 'registerAction' callback to an invalid value:", name, callback);
      } else if (Actions[name] && !propertyIsEnumerable(Actions, name)) {
          console.warn("VelocityJS: Trying to override internal 'registerAction' callback", name);
      } else if (internal === true) {
          defineProperty$1(Actions, name, callback);
      } else {
          Actions[name] = callback;
      }
  }
  registerAction(["registerAction", registerAction], true);

  /**
   * Without this it will only un-prefix properties that have a valid "normal"
   * version.
   */
  var DURATION_FAST = 200;
  var DURATION_NORMAL = 400;
  var DURATION_SLOW = 600;
  var FUZZY_MS_PER_SECOND = 980;
  var DEFAULT_CACHE = true;
  var DEFAULT_DELAY = 0;
  var DEFAULT_DURATION = DURATION_NORMAL;
  var DEFAULT_EASING = "swing";
  var DEFAULT_FPSLIMIT = 60;
  var DEFAULT_LOOP = 0;
  var DEFAULT_PROMISE = true;
  var DEFAULT_PROMISE_REJECT_EMPTY = true;
  var DEFAULT_QUEUE = "";
  var DEFAULT_REPEAT = 0;
  var DEFAULT_SPEED = 1;
  var DEFAULT_SYNC = true;
  var CLASSNAME = "velocity-animating";
  var Duration = {
    fast: DURATION_FAST,
    normal: DURATION_NORMAL,
    slow: DURATION_SLOW
  };

  // Project
  // Constants
  var Easings = {};
  /**
   * Used to register a easing. This should never be called by users
   * directly, instead it should be called via an action:<br/>
   * <code>Velocity("registerEasing", "name", VelocityEasingFn);</code>
   */
  function registerEasing(args) {
      var name = args[0],
          callback = args[1];
      if (!isString(name)) {
          console.warn("VelocityJS: Trying to set 'registerEasing' name to an invalid value:", name);
      } else if (!isFunction(callback)) {
          console.warn("VelocityJS: Trying to set 'registerEasing' callback to an invalid value:", name, callback);
      } else if (Easings[name]) {
          console.warn("VelocityJS: Trying to override 'registerEasing' callback", name);
      } else {
          Easings[name] = callback;
      }
  }
  registerAction(["registerEasing", registerEasing], true);
  /**
   * Linear easing, used for sequence parts that don't have an actual easing
   * function.
   */
  function linearEasing(percentComplete, startValue, endValue, property) {
      return startValue + percentComplete * (endValue - startValue);
  }
  /**
   * Swing is the default for jQuery and Velocity.
   */
  function swingEasing(percentComplete, startValue, endValue) {
      return startValue + (0.5 - Math.cos(percentComplete * Math.PI) / 2) * (endValue - startValue);
  }
  /**
   * A less exaggerated version of easeInOutElastic.
   */
  function springEasing(percentComplete, startValue, endValue) {
      return startValue + (1 - Math.cos(percentComplete * 4.5 * Math.PI) * Math.exp(-percentComplete * 6)) * (endValue - startValue);
  }
  registerEasing(["linear", linearEasing]);
  registerEasing(["swing", swingEasing]);
  registerEasing(["spring", springEasing]);

  // Project
  /**
   * Fix to a range of <code>0 <= num <= 1</code>.
   */
  function fixRange(num) {
      return Math.min(Math.max(num, 0), 1);
  }
  function A(aA1, aA2) {
      return 1 - 3 * aA2 + 3 * aA1;
  }
  function B(aA1, aA2) {
      return 3 * aA2 - 6 * aA1;
  }
  function C(aA1) {
      return 3 * aA1;
  }
  function calcBezier(aT, aA1, aA2) {
      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }
  function getSlope(aT, aA1, aA2) {
      return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
  }
  function generateBezier(mX1, mY1, mX2, mY2) {
      var NEWTON_ITERATIONS = 4,
          NEWTON_MIN_SLOPE = 0.001,
          SUBDIVISION_PRECISION = 0.0000001,
          SUBDIVISION_MAX_ITERATIONS = 10,
          kSplineTableSize = 11,
          kSampleStepSize = 1 / (kSplineTableSize - 1),
          float32ArraySupported = "Float32Array" in window;
      /* Must contain four arguments. */
      if (arguments.length !== 4) {
          return;
      }
      /* Arguments must be numbers. */
      for (var i = 0; i < 4; ++i) {
          if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
              return;
          }
      }
      /* X values must be in the [0, 1] range. */
      mX1 = fixRange(mX1);
      mX2 = fixRange(mX2);
      var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
      function newtonRaphsonIterate(aX, aGuessT) {
          for (var _i = 0; _i < NEWTON_ITERATIONS; ++_i) {
              var currentSlope = getSlope(aGuessT, mX1, mX2);
              if (currentSlope === 0) {
                  return aGuessT;
              }
              var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
              aGuessT -= currentX / currentSlope;
          }
          return aGuessT;
      }
      function calcSampleValues() {
          for (var _i2 = 0; _i2 < kSplineTableSize; ++_i2) {
              mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);
          }
      }
      function binarySubdivide(aX, aA, aB) {
          var currentX = void 0,
              currentT = void 0,
              i = 0;
          do {
              currentT = aA + (aB - aA) / 2;
              currentX = calcBezier(currentT, mX1, mX2) - aX;
              if (currentX > 0) {
                  aB = currentT;
              } else {
                  aA = currentT;
              }
          } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
          return currentT;
      }
      function getTForX(aX) {
          var lastSample = kSplineTableSize - 1;
          var intervalStart = 0,
              currentSample = 1;
          for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
              intervalStart += kSampleStepSize;
          }
          --currentSample;
          var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),
              guessForT = intervalStart + dist * kSampleStepSize,
              initialSlope = getSlope(guessForT, mX1, mX2);
          if (initialSlope >= NEWTON_MIN_SLOPE) {
              return newtonRaphsonIterate(aX, guessForT);
          } else if (initialSlope === 0) {
              return guessForT;
          } else {
              return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
          }
      }
      var precomputed = false;
      function precompute() {
          precomputed = true;
          if (mX1 !== mY1 || mX2 !== mY2) {
              calcSampleValues();
          }
      }
      var str = "generateBezier(" + [mX1, mY1, mX2, mY2] + ")",
          f = function f(percentComplete, startValue, endValue, property) {
          if (!precomputed) {
              precompute();
          }
          if (percentComplete === 0) {
              return startValue;
          }
          if (percentComplete === 1) {
              return endValue;
          }
          if (mX1 === mY1 && mX2 === mY2) {
              return startValue + percentComplete * (endValue - startValue);
          }
          return startValue + calcBezier(getTForX(percentComplete), mY1, mY2) * (endValue - startValue);
      };
      f.getControlPoints = function () {
          return [{ x: mX1, y: mY1 }, { x: mX2, y: mY2 }];
      };
      f.toString = function () {
          return str;
      };
      return f;
  }
  /* Common easings */
  var easeIn = generateBezier(0.42, 0, 1, 1),
      easeOut = generateBezier(0, 0, 0.58, 1),
      easeInOut = generateBezier(0.42, 0, 0.58, 1);
  registerEasing(["ease", generateBezier(0.25, 0.1, 0.25, 1)]);
  registerEasing(["easeIn", easeIn]);
  registerEasing(["ease-in", easeIn]);
  registerEasing(["easeOut", easeOut]);
  registerEasing(["ease-out", easeOut]);
  registerEasing(["easeInOut", easeInOut]);
  registerEasing(["ease-in-out", easeInOut]);
  registerEasing(["easeInSine", generateBezier(0.47, 0, 0.745, 0.715)]);
  registerEasing(["easeOutSine", generateBezier(0.39, 0.575, 0.565, 1)]);
  registerEasing(["easeInOutSine", generateBezier(0.445, 0.05, 0.55, 0.95)]);
  registerEasing(["easeInQuad", generateBezier(0.55, 0.085, 0.68, 0.53)]);
  registerEasing(["easeOutQuad", generateBezier(0.25, 0.46, 0.45, 0.94)]);
  registerEasing(["easeInOutQuad", generateBezier(0.455, 0.03, 0.515, 0.955)]);
  registerEasing(["easeInCubic", generateBezier(0.55, 0.055, 0.675, 0.19)]);
  registerEasing(["easeOutCubic", generateBezier(0.215, 0.61, 0.355, 1)]);
  registerEasing(["easeInOutCubic", generateBezier(0.645, 0.045, 0.355, 1)]);
  registerEasing(["easeInQuart", generateBezier(0.895, 0.03, 0.685, 0.22)]);
  registerEasing(["easeOutQuart", generateBezier(0.165, 0.84, 0.44, 1)]);
  registerEasing(["easeInOutQuart", generateBezier(0.77, 0, 0.175, 1)]);
  registerEasing(["easeInQuint", generateBezier(0.755, 0.05, 0.855, 0.06)]);
  registerEasing(["easeOutQuint", generateBezier(0.23, 1, 0.32, 1)]);
  registerEasing(["easeInOutQuint", generateBezier(0.86, 0, 0.07, 1)]);
  registerEasing(["easeInExpo", generateBezier(0.95, 0.05, 0.795, 0.035)]);
  registerEasing(["easeOutExpo", generateBezier(0.19, 1, 0.22, 1)]);
  registerEasing(["easeInOutExpo", generateBezier(1, 0, 0, 1)]);
  registerEasing(["easeInCirc", generateBezier(0.6, 0.04, 0.98, 0.335)]);
  registerEasing(["easeOutCirc", generateBezier(0.075, 0.82, 0.165, 1)]);
  registerEasing(["easeInOutCirc", generateBezier(0.785, 0.135, 0.15, 0.86)]);

  /* Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */
  /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
   then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */
  function springAccelerationForState(state) {
      return -state.tension * state.x - state.friction * state.v;
  }
  function springEvaluateStateWithDerivative(initialState, dt, derivative) {
      var state = {
          x: initialState.x + derivative.dx * dt,
          v: initialState.v + derivative.dv * dt,
          tension: initialState.tension,
          friction: initialState.friction
      };
      return {
          dx: state.v,
          dv: springAccelerationForState(state)
      };
  }
  function springIntegrateState(state, dt) {
      var a = {
          dx: state.v,
          dv: springAccelerationForState(state)
      },
          b = springEvaluateStateWithDerivative(state, dt * 0.5, a),
          c = springEvaluateStateWithDerivative(state, dt * 0.5, b),
          d = springEvaluateStateWithDerivative(state, dt, c),
          dxdt = 1 / 6 * (a.dx + 2 * (b.dx + c.dx) + d.dx),
          dvdt = 1 / 6 * (a.dv + 2 * (b.dv + c.dv) + d.dv);
      state.x = state.x + dxdt * dt;
      state.v = state.v + dvdt * dt;
      return state;
  }
  function generateSpringRK4(tension, friction, duration) {
      var initState = {
          x: -1,
          v: 0,
          tension: parseFloat(tension) || 500,
          friction: parseFloat(friction) || 20
      },
          path = [0],
          tolerance = 1 / 10000,
          DT = 16 / 1000,
          haveDuration = duration != null; // deliberate "==", as undefined == null != 0
      var timeLapsed = 0,
          dt = void 0,
          lastState = void 0;
      /* Calculate the actual time it takes for this animation to complete with the provided conditions. */
      if (haveDuration) {
          /* Run the simulation without a duration. */
          timeLapsed = generateSpringRK4(initState.tension, initState.friction);
          /* Compute the adjusted time delta. */
          dt = timeLapsed / duration * DT;
      } else {
          dt = DT;
      }
      while (true) {
          /* Next/step function .*/
          lastState = springIntegrateState(lastState || initState, dt);
          /* Store the position. */
          path.push(1 + lastState.x);
          timeLapsed += 16;
          /* If the change threshold is reached, break. */
          if (!(Math.abs(lastState.x) > tolerance && Math.abs(lastState.v) > tolerance)) {
              break;
          }
      }
      /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
       computed path and returns a snapshot of the position according to a given percentComplete. */
      return !haveDuration ? timeLapsed : function (percentComplete, startValue, endValue) {
          if (percentComplete === 0) {
              return startValue;
          }
          if (percentComplete === 1) {
              return endValue;
          }
          return startValue + path[Math.floor(percentComplete * (path.length - 1))] * (endValue - startValue);
      };
  }

  // Constants
  var cache = {};
  function generateStep(steps) {
      var fn = cache[steps];
      if (fn) {
          return fn;
      }
      return cache[steps] = function (percentComplete, startValue, endValue) {
          if (percentComplete === 0) {
              return startValue;
          }
          if (percentComplete === 1) {
              return endValue;
          }
          return startValue + Math.round(percentComplete * steps) * (1 / steps) * (endValue - startValue);
      };
  }

  // Project
  /**
   * Parse a duration value and return an ms number. Optionally return a
   * default value if the number is not valid.
   */
  function parseDuration(duration, def) {
      if (isNumber(duration)) {
          return duration;
      }
      if (isString(duration)) {
          return Duration[duration.toLowerCase()] || parseFloat(duration.replace("ms", "").replace("s", "000"));
      }
      return def == null ? undefined : parseDuration(def);
  }
  /**
   * Validate a <code>cache</code> option.
   */
  function validateCache(value) {
      if (isBoolean(value)) {
          return value;
      }
      if (value != null) {
          console.warn("VelocityJS: Trying to set 'cache' to an invalid value:", value);
      }
  }
  /**
   * Validate a <code>begin</code> option.
   */
  function validateBegin(value) {
      if (isFunction(value)) {
          return value;
      }
      if (value != null) {
          console.warn("VelocityJS: Trying to set 'begin' to an invalid value:", value);
      }
  }
  /**
   * Validate a <code>complete</code> option.
   */
  function validateComplete(value, noError) {
      if (isFunction(value)) {
          return value;
      }
      if (value != null && !noError) {
          console.warn("VelocityJS: Trying to set 'complete' to an invalid value:", value);
      }
  }
  /**
   * Validate a <code>delay</code> option.
   */
  function validateDelay(value) {
      var parsed = parseDuration(value);
      if (!isNaN(parsed)) {
          return parsed;
      }
      if (value != null) {
          console.error("VelocityJS: Trying to set 'delay' to an invalid value:", value);
      }
  }
  /**
   * Validate a <code>duration</code> option.
   */
  function validateDuration(value, noError) {
      var parsed = parseDuration(value);
      if (!isNaN(parsed) && parsed >= 0) {
          return parsed;
      }
      if (value != null && !noError) {
          console.error("VelocityJS: Trying to set 'duration' to an invalid value:", value);
      }
  }
  /**
   * Validate a <code>easing</code> option.
   */
  function validateEasing(value, duration, noError) {
      if (isString(value)) {
          // Named easing
          return Easings[value];
      }
      if (isFunction(value)) {
          return value;
      }
      // TODO: We should only do these if the correct function exists - don't force loading.
      if (Array.isArray(value)) {
          if (value.length === 1) {
              // Steps
              return generateStep(value[0]);
          }
          if (value.length === 2) {
              // springRK4 must be passed the animation's duration.
              // Note: If the springRK4 array contains non-numbers,
              // generateSpringRK4() returns an easing function generated with
              // default tension and friction values.
              return generateSpringRK4(value[0], value[1], duration);
          }
          if (value.length === 4) {
              // Note: If the bezier array contains non-numbers, generateBezier()
              // returns undefined.
              return generateBezier.apply(null, value) || false;
          }
      }
      if (value != null && !noError) {
          console.error("VelocityJS: Trying to set 'easing' to an invalid value:", value);
      }
  }
  /**
   * Validate a <code>fpsLimit</code> option.
   */
  function validateFpsLimit(value) {
      if (value === false) {
          return 0;
      } else {
          var parsed = parseInt(value, 10);
          if (!isNaN(parsed) && parsed >= 0) {
              return Math.min(parsed, 60);
          }
      }
      if (value != null) {
          console.warn("VelocityJS: Trying to set 'fpsLimit' to an invalid value:", value);
      }
  }
  /**
   * Validate a <code>loop</code> option.
   */
  function validateLoop(value) {
      switch (value) {
          case false:
              return 0;
          case true:
              return true;
          default:
              var parsed = parseInt(value, 10);
              if (!isNaN(parsed) && parsed >= 0) {
                  return parsed;
              }
              break;
      }
      if (value != null) {
          console.warn("VelocityJS: Trying to set 'loop' to an invalid value:", value);
      }
  }
  /**
   * Validate a <code>progress</code> option.
   */
  function validateProgress(value) {
      if (isFunction(value)) {
          return value;
      }
      if (value != null) {
          console.warn("VelocityJS: Trying to set 'progress' to an invalid value:", value);
      }
  }
  /**
   * Validate a <code>promise</code> option.
   */
  function validatePromise(value) {
      if (isBoolean(value)) {
          return value;
      }
      if (value != null) {
          console.warn("VelocityJS: Trying to set 'promise' to an invalid value:", value);
      }
  }
  /**
   * Validate a <code>promiseRejectEmpty</code> option.
   */
  function validatePromiseRejectEmpty(value) {
      if (isBoolean(value)) {
          return value;
      }
      if (value != null) {
          console.warn("VelocityJS: Trying to set 'promiseRejectEmpty' to an invalid value:", value);
      }
  }
  /**
   * Validate a <code>queue</code> option.
   */
  function validateQueue(value, noError) {
      if (value === false || isString(value)) {
          return value;
      }
      if (value != null && !noError) {
          console.warn("VelocityJS: Trying to set 'queue' to an invalid value:", value);
      }
  }
  /**
   * Validate a <code>repeat</code> option.
   */
  function validateRepeat(value) {
      switch (value) {
          case false:
              return 0;
          case true:
              return true;
          default:
              var parsed = parseInt(value, 10);
              if (!isNaN(parsed) && parsed >= 0) {
                  return parsed;
              }
              break;
      }
      if (value != null) {
          console.warn("VelocityJS: Trying to set 'repeat' to an invalid value:", value);
      }
  }
  /**
   * Validate a <code>speed</code> option.
   */
  function validateSpeed(value) {
      if (isNumber(value)) {
          return value;
      }
      if (value != null) {
          console.error("VelocityJS: Trying to set 'speed' to an invalid value:", value);
      }
  }
  /**
   * Validate a <code>sync</code> option.
   */
  function validateSync(value) {
      if (isBoolean(value)) {
          return value;
      }
      if (value != null) {
          console.error("VelocityJS: Trying to set 'sync' to an invalid value:", value);
      }
  }

  // Project
  // NOTE: Add the variable here, then add the default state in "reset" below.
  var cache$1 = void 0,
      begin = void 0,
      complete = void 0,
      delay = void 0,
      duration = void 0,
      easing = void 0,
      fpsLimit = void 0,
      loop = void 0,
      mobileHA = void 0,
      minFrameTime = void 0,
      promise = void 0,
      promiseRejectEmpty = void 0,
      queue = void 0,
      repeat = void 0,
      speed = void 0,
      sync = void 0;
  var defaults$1 = function () {
      function defaults$$1() {
          classCallCheck(this, defaults$$1);
      }

      createClass(defaults$$1, null, [{
          key: "reset",
          value: function reset() {
              cache$1 = DEFAULT_CACHE;
              begin = undefined;
              complete = undefined;
              delay = DEFAULT_DELAY;
              duration = DEFAULT_DURATION;
              easing = validateEasing(DEFAULT_EASING, DEFAULT_DURATION);
              fpsLimit = DEFAULT_FPSLIMIT;
              loop = DEFAULT_LOOP;
              minFrameTime = FUZZY_MS_PER_SECOND / DEFAULT_FPSLIMIT;
              promise = DEFAULT_PROMISE;
              promiseRejectEmpty = DEFAULT_PROMISE_REJECT_EMPTY;
              queue = DEFAULT_QUEUE;
              repeat = DEFAULT_REPEAT;
              speed = DEFAULT_SPEED;
              sync = DEFAULT_SYNC;
          }
      }, {
          key: "cache",
          get: function get$$1() {
              return cache$1;
          },
          set: function set$$1(value) {
              value = validateCache(value);
              if (value !== undefined) {
                  cache$1 = value;
              }
          }
      }, {
          key: "begin",
          get: function get$$1() {
              return begin;
          },
          set: function set$$1(value) {
              value = validateBegin(value);
              if (value !== undefined) {
                  begin = value;
              }
          }
      }, {
          key: "complete",
          get: function get$$1() {
              return complete;
          },
          set: function set$$1(value) {
              value = validateComplete(value);
              if (value !== undefined) {
                  complete = value;
              }
          }
      }, {
          key: "delay",
          get: function get$$1() {
              return delay;
          },
          set: function set$$1(value) {
              value = validateDelay(value);
              if (value !== undefined) {
                  delay = value;
              }
          }
      }, {
          key: "duration",
          get: function get$$1() {
              return duration;
          },
          set: function set$$1(value) {
              value = validateDuration(value);
              if (value !== undefined) {
                  duration = value;
              }
          }
      }, {
          key: "easing",
          get: function get$$1() {
              return easing;
          },
          set: function set$$1(value) {
              value = validateEasing(value, duration);
              if (value !== undefined) {
                  easing = value;
              }
          }
      }, {
          key: "fpsLimit",
          get: function get$$1() {
              return fpsLimit;
          },
          set: function set$$1(value) {
              value = validateFpsLimit(value);
              if (value !== undefined) {
                  fpsLimit = value;
                  minFrameTime = FUZZY_MS_PER_SECOND / value;
              }
          }
      }, {
          key: "loop",
          get: function get$$1() {
              return loop;
          },
          set: function set$$1(value) {
              value = validateLoop(value);
              if (value !== undefined) {
                  loop = value;
              }
          }
      }, {
          key: "mobileHA",
          get: function get$$1() {
              return mobileHA;
          },
          set: function set$$1(value) {
              if (isBoolean(value)) {
                  mobileHA = value;
              }
          }
      }, {
          key: "minFrameTime",
          get: function get$$1() {
              return minFrameTime;
          }
      }, {
          key: "promise",
          get: function get$$1() {
              return promise;
          },
          set: function set$$1(value) {
              value = validatePromise(value);
              if (value !== undefined) {
                  promise = value;
              }
          }
      }, {
          key: "promiseRejectEmpty",
          get: function get$$1() {
              return promiseRejectEmpty;
          },
          set: function set$$1(value) {
              value = validatePromiseRejectEmpty(value);
              if (value !== undefined) {
                  promiseRejectEmpty = value;
              }
          }
      }, {
          key: "queue",
          get: function get$$1() {
              return queue;
          },
          set: function set$$1(value) {
              value = validateQueue(value);
              if (value !== undefined) {
                  queue = value;
              }
          }
      }, {
          key: "repeat",
          get: function get$$1() {
              return repeat;
          },
          set: function set$$1(value) {
              value = validateRepeat(value);
              if (value !== undefined) {
                  repeat = value;
              }
          }
      }, {
          key: "repeatAgain",
          get: function get$$1() {
              return repeat;
          }
      }, {
          key: "speed",
          get: function get$$1() {
              return speed;
          },
          set: function set$$1(value) {
              value = validateSpeed(value);
              if (value !== undefined) {
                  speed = value;
              }
          }
      }, {
          key: "sync",
          get: function get$$1() {
              return sync;
          },
          set: function set$$1(value) {
              value = validateSync(value);
              if (value !== undefined) {
                  sync = value;
              }
          }
      }]);
      return defaults$$1;
  }();
  Object.freeze(defaults$1);
  // Reset to our default values, currently everything is undefined.
  defaults$1.reset();

  /**
   * The highest type index for finding the best normalization for a property.
   */
  /**
   * Unlike "actions", normalizations can always be replaced by users.
   */
  var Normalizations = [];
  /**
   * Store a cross-reference to units to be added to specific normalization
   * functions if the user supplies a unit-less number.
   *
   * This is pretty much confined to adding "px" to several css properties.
   */
  var NormalizationUnits = {};
  /**
   * Any normalisations that should never be cached are listed here.
   * Faster than an array - https://jsperf.com/array-includes-and-find-methods-vs-set-has
   */
  var NoCacheNormalizations = new Set();
  /**
   * An array of classes used for the per-class normalizations. This
   * translates into a bitwise enum for quick cross-reference, and so that
   * the element doesn't need multiple <code>instanceof</code> calls every
   * frame.
   */
  var constructors = [];
  /**
   * A cache of the various constructors we've found and mapping to their real
   * name - saves expensive lookups.
   */
  var constructorCache = new Map();

  // Project
  // Constants
  var dataName = "velocityData";
  /**
   * Get (and create) the internal data store for an element.
   */
  function Data(element) {
      // Use a string member so Uglify doesn't mangle it.
      var data = element[dataName];
      if (data) {
          return data;
      }
      var window = element.ownerDocument.defaultView;
      var types = 0;
      for (var index = 0; index < constructors.length; index++) {
          var _constructor = constructors[index];
          if (isString(_constructor)) {
              if (element instanceof window[_constructor]) {
                  types |= 1 << index; // tslint:disable-line:no-bitwise
              }
          } else if (element instanceof _constructor) {
              types |= 1 << index; // tslint:disable-line:no-bitwise
          }
      }
      // Use an intermediate object so it errors on incorrect data.
      var newData = {
          types: types,
          count: 0,
          computedStyle: null,
          cache: {},
          queueList: {},
          lastAnimationList: {},
          lastFinishList: {},
          window: window
      };
      Object.defineProperty(element, dataName, {
          value: newData
      });
      return newData;
  }

  // Constants
  var isClient = window && window === window.window,
      windowScrollAnchor = isClient && window.pageYOffset !== undefined;
  var State = {
      isClient: isClient,
      isMobile: isClient && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
      isGingerbread: isClient && /Android 2\.3\.[3-7]/i.test(navigator.userAgent),
      prefixElement: isClient && document.createElement("div"),
      windowScrollAnchor: windowScrollAnchor,
      scrollAnchor: windowScrollAnchor ? window : !isClient || document.documentElement || document.body.parentNode || document.body,
      scrollPropertyLeft: windowScrollAnchor ? "pageXOffset" : "scrollLeft",
      scrollPropertyTop: windowScrollAnchor ? "pageYOffset" : "scrollTop",
      className: CLASSNAME,
      isTicking: false,
      first: undefined,
      last: undefined,
      firstNew: undefined
  };

  // Project
  /**
   * Simple queue management. Un-named queue is directly within the element data,
   * named queue is within an object within it.
   */
  function animate(animation) {
      var prev = State.last;
      animation._prev = prev;
      animation._next = undefined;
      if (prev) {
          prev._next = animation;
      } else {
          State.first = animation;
      }
      State.last = animation;
      if (!State.firstNew) {
          State.firstNew = animation;
      }
      var element = animation.element,
          data = Data(element);
      if (!data.count++) {
          ////////////////////////
          // Feature: Classname //
          ////////////////////////
          addClass(element, State.className);
      }
  }
  /**
   * Add an item to an animation queue.
   */
  function queue$1(element, animation, queueName) {
      var data = Data(element);
      if (queueName !== false) {
          // Store the last animation added so we can use it for the
          // beginning of the next one.
          data.lastAnimationList[queueName] = animation;
      }
      if (queueName === false) {
          animate(animation);
      } else {
          if (!isString(queueName)) {
              queueName = "";
          }
          var last = data.queueList[queueName];
          if (!last) {
              if (last === null) {
                  data.queueList[queueName] = animation;
              } else {
                  data.queueList[queueName] = null;
                  animate(animation);
              }
          } else {
              while (last._next) {
                  last = last._next;
              }
              last._next = animation;
              animation._prev = last;
          }
      }
  }
  /**
   * Start the next animation on this element's queue (named or default).
   *
   * @returns the next animation that is starting.
   */
  function dequeue(element, queueName, skip) {
      if (queueName !== false) {
          if (!isString(queueName)) {
              queueName = "";
          }
          var data = Data(element),
              animation = data.queueList[queueName];
          if (animation) {
              data.queueList[queueName] = animation._next || null;
              if (!skip) {
                  animate(animation);
              }
          } else if (animation === null) {
              delete data.queueList[queueName];
          }
          return animation;
      }
  }
  /**
   * Remove an animation from the active animation list. If it has a queue set
   * then remember it as the last animation for that queue, and free the one
   * that was previously there. If the animation list is completely empty then
   * mark us as finished.
   */
  function freeAnimationCall(animation) {
      var next = animation._next,
          prev = animation._prev,
          queueName = animation.queue == null ? animation.options.queue : animation.queue;
      if (State.firstNew === animation) {
          State.firstNew = next;
      }
      if (State.first === animation) {
          State.first = next;
      } else if (prev) {
          prev._next = next;
      }
      if (State.last === animation) {
          State.last = prev;
      } else if (next) {
          next._prev = prev;
      }
      if (queueName) {
          var data = Data(animation.element);
          if (data) {
              animation._next = animation._prev = undefined;
          }
      }
  }

  var SequencesObject = {};

  // Project
  /**
   * Call the complete method of an animation in a separate function so it can
   * benefit from JIT compiling while still having a try/catch block.
   */
  function callComplete(activeCall) {
      var callback = activeCall.complete || activeCall.options.complete;
      if (callback) {
          try {
              var elements = activeCall.elements;
              callback.call(elements, elements, activeCall);
          } catch (error) {
              setTimeout(function () {
                  throw error;
              }, 1);
          }
      }
  }
  /**
   * Complete an animation. This might involve restarting (for loop or repeat
   * options). Once it is finished we also check for any callbacks or Promises
   * that need updating.
   */
  function completeCall(activeCall) {
      // TODO: Check if it's not been completed already
      var options = activeCall.options,
          queue = getValue(activeCall.queue, options.queue),
          isLoop = getValue(activeCall.loop, options.loop, defaults$1.loop),
          isRepeat = getValue(activeCall.repeat, options.repeat, defaults$1.repeat),
          isStopped = activeCall._flags & 8 /* STOPPED */; // tslint:disable-line:no-bitwise
      if (!isStopped && (isLoop || isRepeat)) {
          ////////////////////
          // Option: Loop   //
          // Option: Repeat //
          ////////////////////
          if (isRepeat && isRepeat !== true) {
              activeCall.repeat = isRepeat - 1;
          } else if (isLoop && isLoop !== true) {
              activeCall.loop = isLoop - 1;
              activeCall.repeat = getValue(activeCall.repeatAgain, options.repeatAgain, defaults$1.repeatAgain);
          }
          if (isLoop) {
              activeCall._flags ^= 64 /* REVERSE */; // tslint:disable-line:no-bitwise
          }
          if (queue !== false) {
              // Can't be called when stopped so no need for an extra check.
              Data(activeCall.element).lastFinishList[queue] = activeCall.timeStart + getValue(activeCall.duration, options.duration, defaults$1.duration);
          }
          activeCall.timeStart = activeCall.ellapsedTime = activeCall.percentComplete = 0;
          activeCall._flags &= ~4 /* STARTED */; // tslint:disable-line:no-bitwise
      } else {
          var element = activeCall.element,
              data = Data(element);
          if (! --data.count && !isStopped) {
              ////////////////////////
              // Feature: Classname //
              ////////////////////////
              removeClass(element, State.className);
          }
          //////////////////////
          // Option: Complete //
          //////////////////////
          // If this is the last animation in this list then we can check for
          // and complete calls or Promises.
          // TODO: When deleting an element we need to adjust these values.
          if (options && ++options._completed === options._total) {
              if (!isStopped && options.complete) {
                  // We don't call the complete if the animation is stopped,
                  // and we clear the key to prevent it being called again.
                  callComplete(activeCall);
                  options.complete = null;
              }
              var resolver = options._resolver;
              if (resolver) {
                  // Fulfil the Promise
                  resolver(activeCall.elements);
                  delete options._resolver;
              }
          }
          ///////////////////
          // Option: Queue //
          ///////////////////
          if (queue !== false) {
              // We only do clever things with queues...
              if (!isStopped) {
                  // If we're not stopping an animation, we need to remember
                  // what time it finished so that the next animation in
                  // sequence gets the correct start time.
                  data.lastFinishList[queue] = activeCall.timeStart + getValue(activeCall.duration, options.duration, defaults$1.duration);
              }
              // Start the next animation in sequence, or delete the queue if
              // this was the last one.
              dequeue(element, queue);
          }
          // Cleanup any pointers, and remember the last animation etc.
          freeAnimationCall(activeCall);
      }
  }

  // Project
  /**
   * Used to register a normalization. This should never be called by users
   * directly, instead it should be called via an action:<br/>
   * <code>Velocity("registerNormalization", "Element", "name", VelocityNormalizationsFn[, false]);</code>
   *
   * The second argument is the class of the animatable object. If this is passed
   * as a class name (ie, `"Element"` -> `window["Element"]`) then this will work
   * cross-iframe. If passed as an actual class (ie `Element`) then it will
   * attempt to find the class on the window and use that name instead. If it
   * can't find it then it will use the class passed, which allows for custom
   * animation targets, but will not work cross-iframe boundary.
   *
   * The fourth argument can be an explicit <code>false</code>, which prevents
   * the property from being cached. Please note that this can be dangerous
   * for performance!
   */
  function registerNormalization(args) {
      var constructor = args[0],
          name = args[1],
          callback = args[2];
      if (isString(constructor) && !(window[constructor] instanceof Object) || !isString(constructor) && !(constructor instanceof Object)) {
          console.warn("VelocityJS: Trying to set 'registerNormalization' constructor to an invalid value:", constructor);
      } else if (!isString(name)) {
          console.warn("VelocityJS: Trying to set 'registerNormalization' name to an invalid value:", name);
      } else if (!isFunction(callback)) {
          console.warn("VelocityJS: Trying to set 'registerNormalization' callback to an invalid value:", name, callback);
      } else {
          var index = constructors.indexOf(constructor),
              nextArg = 3;
          if (index < 0 && !isString(constructor)) {
              if (constructorCache.has(constructor)) {
                  index = constructors.indexOf(constructorCache.get(constructor));
              } else {
                  for (var property in window) {
                      if (window[property] === constructor) {
                          index = constructors.indexOf(property);
                          if (index < 0) {
                              index = constructors.push(property) - 1;
                              Normalizations[index] = {};
                              constructorCache.set(constructor, property);
                          }
                          break;
                      }
                  }
              }
          }
          if (index < 0) {
              index = constructors.push(constructor) - 1;
              Normalizations[index] = {};
          }
          Normalizations[index][name] = callback;
          if (isString(args[nextArg])) {
              var unit = args[nextArg++];
              var units = NormalizationUnits[unit];
              if (!units) {
                  units = NormalizationUnits[unit] = [];
              }
              units.push(callback);
          }
          if (args[nextArg] === false) {
              NoCacheNormalizations.add(name);
          }
      }
  }
  /**
   * Used to check if a normalisation exists on a specific class.
   */
  function hasNormalization(args) {
      var constructor = args[0],
          name = args[1];
      var index = constructors.indexOf(constructor);
      if (index < 0 && !isString(constructor)) {
          if (constructorCache.has(constructor)) {
              index = constructors.indexOf(constructorCache.get(constructor));
          } else {
              for (var property in window) {
                  if (window[property] === constructor) {
                      index = constructors.indexOf(property);
                      break;
                  }
              }
          }
      }
      return index >= 0 && Normalizations[index].hasOwnProperty(name);
  }
  /**
   * Get the unit to add to a unitless number based on the normalization used.
   */
  function getNormalizationUnit(fn) {
      for (var unit in NormalizationUnits) {
          if (NormalizationUnits[unit].includes(fn)) {
              return unit;
          }
      }
      return "";
  }
  /**
   * Get the normalization for an element and propertyName combination. This
   * value should be cached at asking time, as it may change if the user adds
   * more normalizations.
   */
  function getNormalization(element, propertyName) {
      var data = Data(element);
      var fn = void 0;
      for (var index = constructors.length - 1, types = data.types; !fn && index >= 0; index--) {
          if (types & 1 << index) {
              // tslint:disable-line:no-bitwise
              fn = Normalizations[index][propertyName];
          }
      }
      return fn;
  }
  registerAction(["registerNormalization", registerNormalization]);
  registerAction(["hasNormalization", hasNormalization]);

  // Project
  /**
   * The singular setPropertyValue, which routes the logic for all
   * normalizations.
   */
  function setPropertyValue(element, propertyName, propertyValue, fn) {
      var noCache = NoCacheNormalizations.has(propertyName),
          data = !noCache && Data(element);
      if (noCache || data && data.cache[propertyName] !== propertyValue) {
          // By setting it to undefined we force a true "get" later
          if (!noCache) {
              data.cache[propertyName] = propertyValue || undefined;
          }
          fn = fn || getNormalization(element, propertyName);
          if (fn) {
              fn(element, propertyValue);
          }
          if (Velocity$$1.debug >= 2) {
              console.info("Set \"" + propertyName + "\": \"" + propertyValue + "\"", element);
          }
      }
  }

  /**
   * Cache every camelCase match to avoid repeating lookups.
   */
  var cache$2 = {};
  /**
   * Camelcase a property name into its JavaScript notation (e.g.
   * "background-color" ==> "backgroundColor"). Camelcasing is used to
   * normalize property names between and across calls.
   */
  function camelCase(property) {
    var fixed = cache$2[property];
    if (fixed) {
      return fixed;
    }
    return cache$2[property] = property.replace(/-([a-z])/g, function ($, letter) {
      return letter.toUpperCase();
    });
  }

  // Constants
  var rxColor6 = /#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})/gi,
      rxColor3 = /#([a-f\d])([a-f\d])([a-f\d])/gi,
      rxColorName = /(rgba?\(\s*)?(\b[a-z]+\b)/g,
      rxRGB = /rgb(a?)\(([^\)]+)\)/gi,
      rxSpaces = /\s+/g;
  /**
   * This is the list of color names -> rgb values. The object is in here so
   * that the actual name conversion can be in a separate file and not
   * included for custom builds.
   */
  var ColorNames = {};
  /**
   * Convert a hex list to an rgba value. Designed to be used in replace.
   */
  function makeRGBA(ignore, r, g, b) {
      return "rgba(" + parseInt(r, 16) + "," + parseInt(g, 16) + "," + parseInt(b, 16) + ",1)";
  }
  /**
   * Replace any css colour name with its rgba() value. It is possible to use
   * the name within an "rgba(blue, 0.4)" string this way.
   */
  function fixColors(str) {
      return str.replace(rxColor6, makeRGBA).replace(rxColor3, function ($0, r, g, b) {
          return makeRGBA($0, r + r, g + g, b + b);
      }).replace(rxColorName, function ($0, $1, $2) {
          if (ColorNames[$2]) {
              return ($1 ? $1 : "rgba(") + ColorNames[$2] + ($1 ? "" : ",1)");
          }
          return $0;
      }).replace(rxRGB, function ($0, $1, $2) {
          return "rgba(" + ($2.replace(rxSpaces, "") + ($1 ? "" : ",1")) + ")";
      });
  }

  // Project
  /**
   * Figure out the dimensions for this width / height based on the
   * potential borders and whether we care about them.
   */
  function augmentDimension(element, name, wantInner) {
      var isBorderBox = getPropertyValue(element, "boxSizing").toString().toLowerCase() === "border-box";
      if (isBorderBox === wantInner) {
          // in box-sizing mode, the CSS width / height accessors already
          // give the outerWidth / outerHeight.
          var sides = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"],
              fields = ["padding" + sides[0], "padding" + sides[1], "border" + sides[0] + "Width", "border" + sides[1] + "Width"];
          var augment = 0;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
              for (var _iterator = fields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var field = _step.value;

                  var value = parseFloat(getPropertyValue(element, field));
                  if (!isNaN(value)) {
                      augment += value;
                  }
              }
          } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
          } finally {
              try {
                  if (!_iteratorNormalCompletion && _iterator.return) {
                      _iterator.return();
                  }
              } finally {
                  if (_didIteratorError) {
                      throw _iteratorError;
                  }
              }
          }

          return wantInner ? -augment : augment;
      }
      return 0;
  }

  // Project
  /**
   * Get the width or height of an element, pulled out as it can be used when the
   * in two locations so don't want to repeat it.
   */
  function getWidthHeight(element, property) {
      return element.getBoundingClientRect()[property] + augmentDimension(element, property, true) + "px";
  }
  // TODO: This is still a complete mess
  function computePropertyValue(element, property) {
      var data = Data(element),

      // If computedStyle is cached, use it. If not then get the correct one
      // for the element to support cross-iframe boundaries.
      computedStyle = data.computedStyle ? data.computedStyle : data.window.getComputedStyle(element, null);
      var computedValue = 0;
      if (!data.computedStyle) {
          data.computedStyle = computedStyle;
      }
      if (computedStyle["display"] === "none") {
          switch (property) {
              case "width":
              case "height":
                  // Browsers do not return height and width values for elements
                  // that are set to display:"none". Thus, we temporarily toggle
                  // display to the element type's default value.
                  setPropertyValue(element, "display", "auto");
                  computedValue = getWidthHeight(element, property);
                  setPropertyValue(element, "display", "none");
                  return String(computedValue);
          }
      }
      /* IE and Firefox do not return a value for the generic borderColor -- they only return individual values for each border side's color.
       Also, in all browsers, when border colors aren't all the same, a compound value is returned that Velocity isn't setup to parse.
       So, as a polyfill for querying individual border side colors, we just return the top border's color and animate all borders from that value. */
      /* TODO: There is a borderColor normalisation in legacy/ - figure out where this is needed... */
      computedValue = computedStyle[property];
      /* Fall back to the property's style value (if defined) when computedValue returns nothing,
       which can happen when the element hasn't been painted. */
      if (!computedValue) {
          computedValue = element.style[property];
      }
      /* For top, right, bottom, and left (TRBL) values that are set to "auto" on elements of "fixed" or "absolute" position,
       defer to jQuery for converting "auto" to a numeric value. (For elements with a "static" or "relative" position, "auto" has the same
       effect as being set to 0, so no conversion is necessary.) */
      /* An example of why numeric conversion is necessary: When an element with "position:absolute" has an untouched "left"
       property, which reverts to "auto", left's value is 0 relative to its parent element, but is often non-zero relative
       to its *containing* (not parent) element, which is the nearest "position:relative" ancestor or the viewport (and always the viewport in the case of "position:fixed"). */
      if (computedValue === "auto") {
          switch (property) {
              case "width":
              case "height":
                  computedValue = getWidthHeight(element, property);
                  break;
              case "top":
              case "left":

              case "right":
              case "bottom":
                  var position = getPropertyValue(element, "position");
                  if (position === "fixed" || position === "absolute") {
                      // Note: this has no pixel unit on its returned values,
                      // we re-add it here to conform with
                      // computePropertyValue's behavior.
                      computedValue = element.getBoundingClientRect[property] + "px";
                      break;
                  }
              // Deliberate fallthrough!
              default:
                  computedValue = "0px";
                  break;
          }
      }
      return computedValue ? String(computedValue) : "";
  }
  /**
   * Get a property value. This will grab via the cache if it exists, then
   * via any normalisations.
   */
  function getPropertyValue(element, propertyName, fn, skipCache) {
      var data = Data(element);
      var propertyValue = void 0;
      if (NoCacheNormalizations.has(propertyName)) {
          skipCache = true;
      }
      if (!skipCache && data && data.cache[propertyName] != null) {
          propertyValue = data.cache[propertyName];
      } else {
          fn = fn || getNormalization(element, propertyName);
          if (fn) {
              propertyValue = fn(element);
              if (data) {
                  data.cache[propertyName] = propertyValue;
              }
          }
      }
      if (Velocity$$1.debug >= 2) {
          console.info("Get \"" + propertyName + "\": \"" + propertyValue + "\"", element);
      }
      return propertyValue;
  }

  // Project
  // Constants
  var rxHex = /^#([A-f\d]{3}){1,2}$/i,
      commands = {
      function: function _function(value, element, elements, elementArrayIndex, propertyName, tween) {
          return value.call(element, elementArrayIndex, elements.length, propertyName);
      },
      number: function number(value, element, elements, elementArrayIndex, propertyName, tween) {
          return String(value) + getNormalizationUnit(tween.fn);
      },
      string: function string(value, element, elements, elementArrayIndex, propertyName, tween) {
          return fixColors(value);
      },
      undefined: function undefined(value, element, elements, elementArrayIndex, propertyName, tween) {
          return fixColors(getPropertyValue(element, propertyName, tween.fn) || "");
      }
  };
  /**
   * Expand a VelocityProperty argument into a valid sparse Tween array. This
   * pre-allocates the array as it is then the correct size and slightly
   * faster to access.
   */
  function expandProperties(animation, properties) {
      var tweens = animation.tweens = Object.create(null),
          elements = animation.elements,
          element = animation.element,
          elementArrayIndex = elements.indexOf(element),
          data = Data(element),
          queue = getValue(animation.queue, animation.options.queue),
          duration = getValue(animation.options.duration, defaults$1.duration);
      for (var property in properties) {
          if (properties.hasOwnProperty(property)) {
              var propertyName = camelCase(property),
                  fn = getNormalization(element, propertyName);
              var valueData = properties[property];
              if (!fn && propertyName !== "tween") {
                  if (Velocity$$1.debug) {
                      console.log("Skipping \"" + property + "\" due to a lack of browser support.");
                  }
                  continue;
              }
              if (valueData == null) {
                  if (Velocity$$1.debug) {
                      console.log("Skipping \"" + property + "\" due to no value supplied.");
                  }
                  continue;
              }
              var tween = tweens[propertyName] = {};
              var endValue = void 0,
                  startValue = void 0;
              tween.fn = fn;
              if (isFunction(valueData)) {
                  // If we have a function as the main argument then resolve
                  // it first, in case it returns an array that needs to be
                  // split.
                  valueData = valueData.call(element, elementArrayIndex, elements.length, elements);
              }
              if (Array.isArray(valueData)) {
                  // valueData is an array in the form of
                  // [ endValue, [, easing] [, startValue] ]
                  var arr1 = valueData[1],
                      arr2 = valueData[2];
                  endValue = valueData[0];
                  if (isString(arr1) && (/^[\d-]/.test(arr1) || rxHex.test(arr1)) || isFunction(arr1) || isNumber(arr1)) {
                      startValue = arr1;
                  } else if (isString(arr1) && Easings[arr1] || Array.isArray(arr1)) {
                      tween.easing = validateEasing(arr1, duration);
                      startValue = arr2;
                  } else {
                      startValue = arr1 || arr2;
                  }
              } else {
                  endValue = valueData;
              }
              tween.end = commands[typeof endValue === "undefined" ? "undefined" : _typeof(endValue)](endValue, element, elements, elementArrayIndex, propertyName, tween);
              if (startValue != null || queue === false || data.queueList[queue] === undefined) {
                  tween.start = commands[typeof startValue === "undefined" ? "undefined" : _typeof(startValue)](startValue, element, elements, elementArrayIndex, propertyName, tween);
                  explodeTween(propertyName, tween, duration);
              }
          }
      }
  }
  // TODO: Needs a better match for "translate3d" etc - a number must be preceded by some form of break...
  var rxToken = /((?:[+\-*/]=)?(?:[+-]?\d*\.\d+|[+-]?\d+)[a-z%]*|(?:.(?!$|[+-]?\d|[+\-*/]=[+-]?\d))+.|.)/g,
      rxNumber = /^([+\-*/]=)?([+-]?\d*\.\d+|[+-]?\d+)(.*)$/;
  /**
   * Find a pattern between multiple strings, return a VelocitySequence with
   * the pattern and the tokenised values.
   *
   * If number then animate.
   * If a string then must match.
   * If units then convert between them by wrapping in a calc().
   * - If already in a calc then nest another layer.
   * If in an rgba() then the first three numbers are rounded.
   */
  function findPattern(parts, propertyName) {
      var partsLength = parts.length,
          tokens = [],
          indexes = [];
      var numbers = void 0;
      // First tokenise the strings - these have all values, we will pull
      // numbers later.
      for (var part = 0; part < partsLength; part++) {
          if (isString(parts[part])) {
              if (parts[part] === "") {
                  tokens[part] = [""];
              } else {
                  tokens[part] = cloneArray(parts[part].match(rxToken));
              }
              indexes[part] = 0;
              // If it matches more than one thing then we've got a number.
              numbers = numbers || tokens[part].length > 1;
              //console.log(`tokens:`, parts[part], tokens[part])
          } else {
              // We have an incomplete lineup, it will get tried again later...
              return;
          }
      }
      var sequence = [],
          pattern = sequence.pattern = [],
          addString = function addString(text) {
          if (isString(pattern[pattern.length - 1])) {
              pattern[pattern.length - 1] += text;
          } else if (text) {
              pattern.push(text);
              for (var _part = 0; _part < partsLength; _part++) {
                  sequence[_part].push(null);
              }
          }
      },
          returnStringType = function returnStringType() {
          if (numbers || pattern.length > 1) {
              //console.error(`Velocity: Trying to pattern match mis-matched strings "${propertyName}":`, parts);
              return;
          }
          var isDisplay = propertyName === "display",
              isVisibility = propertyName === "visibility";
          for (var _part2 = 0; _part2 < partsLength; _part2++) {
              var value = parts[_part2];
              sequence[_part2][0] = value;
              // Don't care about duration...
              sequence[_part2].easing = validateEasing(isDisplay && value === "none" || isVisibility && value === "hidden" || !isDisplay && !isVisibility ? "at-end" : "at-start", 400);
          }
          pattern[0] = false;
          return sequence;
      };
      var more = true;
      for (var _part3 = 0; _part3 < partsLength; _part3++) {
          sequence[_part3] = [];
      }
      while (more) {
          var bits = [],
              units = [];
          var text = void 0,
              isUnitless = false,
              hasNumbers = false;
          for (var _part4 = 0; _part4 < partsLength; _part4++) {
              var index = indexes[_part4]++,
                  token = tokens[_part4][index];
              if (token) {
                  var num = token.match(rxNumber); // [ignore, change, number, unit]
                  if (num) {
                      // It's a number, possibly with a += change and unit.
                      if (text) {
                          return returnStringType();
                      }
                      var digits = parseFloat(num[2]),
                          unit = num[3],
                          change = num[1] ? num[1][0] + unit : undefined,
                          changeOrUnit = change || unit;
                      if (digits && !units.includes(changeOrUnit)) {
                          // Will be an empty string at the least.
                          units.push(changeOrUnit);
                      }
                      if (!unit) {
                          if (digits) {
                              hasNumbers = true;
                          } else {
                              isUnitless = true;
                          }
                      }
                      bits[_part4] = change ? [digits, changeOrUnit, true] : [digits, changeOrUnit];
                  } else if (bits.length) {
                      return returnStringType();
                  } else {
                      // It's a string.
                      if (!text) {
                          text = token;
                      } else if (text !== token) {
                          return returnStringType();
                      }
                  }
              } else if (!_part4) {
                  for (; _part4 < partsLength; _part4++) {
                      var index2 = indexes[_part4]++;
                      if (tokens[_part4][index2]) {
                          return returnStringType();
                      }
                  }
                  // IMPORTANT: This is the exit point.
                  more = false;
                  break;
              } else {
                  // Different
                  return;
              }
          }
          if (text) {
              addString(text);
          } else if (units.length) {
              if (units.length === 2 && isUnitless && !hasNumbers) {
                  // If we only have two units, and one is empty, and it's only empty on "0", then treat us as having one unit
                  units.splice(units[0] ? 1 : 0, 1);
              }
              if (units.length === 1) {
                  // All the same units, so append number then unit.
                  var _unit = units[0],
                      firstLetter = _unit[0];
                  switch (firstLetter) {
                      case "+":
                      case "-":
                      case "*":
                      case "/":
                          if (propertyName) {
                              console.error("Velocity: The first property must not contain a relative function \"" + propertyName + "\":", parts);
                          }
                          return;
                  }
                  pattern.push(false);
                  for (var _part5 = 0; _part5 < partsLength; _part5++) {
                      sequence[_part5].push(bits[_part5][0]);
                  }
                  addString(_unit);
              } else {
                  // Multiple units, so must be inside a calc.
                  addString("calc(");
                  var patternCalc = pattern.length - 1; // Store the beginning of our calc.
                  for (var i = 0; i < units.length; i++) {
                      var _unit2 = units[i],
                          _firstLetter = _unit2[0],
                          isComplex = _firstLetter === "*" || _firstLetter === "/",
                          isMaths = isComplex || _firstLetter === "+" || _firstLetter === "-";
                      if (isComplex) {
                          // TODO: Not sure this should be done automatically!
                          pattern[patternCalc] += "(";
                          addString(")");
                      }
                      if (i) {
                          addString(" " + (isMaths ? _firstLetter : "+") + " ");
                      }
                      pattern.push(false);
                      for (var _part6 = 0; _part6 < partsLength; _part6++) {
                          var bit = bits[_part6],
                              value = bit[1] === _unit2 ? bit[0] : bit.length === 3 ? sequence[_part6 - 1][sequence[_part6 - 1].length - 1] : isComplex ? 1 : 0;
                          sequence[_part6].push(value);
                      }
                      addString(isMaths ? _unit2.substring(1) : _unit2);
                  }
                  addString(")");
              }
          }
      }
      // We've got here, so a valid sequence - now check and fix RGB rounding
      // and calc() nesting...
      // TODO: Nested calc(a + calc(b + c)) -> calc(a + (b + c))
      for (var _i = 0, inRGB = 0; _i < pattern.length; _i++) {
          var _text = pattern[_i];
          if (isString(_text)) {
              if (inRGB && _text.indexOf(",") >= 0) {
                  inRGB++;
              } else if (_text.indexOf("rgb") >= 0) {
                  inRGB = 1;
              }
          } else if (inRGB) {
              if (inRGB < 4) {
                  pattern[_i] = true;
              } else {
                  inRGB = 0;
              }
          }
      }
      return sequence;
  }
  /**
   * Convert a string-based tween with start and end strings, into a pattern
   * based tween with arrays.
   */
  function explodeTween(propertyName, tween, duration, starting) {
      var startValue = tween.start,
          endValue = tween.end;
      if (!isString(endValue) || !isString(startValue)) {
          return;
      }
      var sequence = findPattern([startValue, endValue], propertyName);
      if (!sequence && starting) {
          // This little piece will take a startValue, split out the
          // various numbers in it, then copy the endValue into the
          // startValue while replacing the numbers in it to match the
          // original start numbers as a repeating sequence.
          // Finally this function will run again with the new
          // startValue and a now matching pattern.
          var startNumbers = startValue.match(/\d\.?\d*/g) || ["0"],
              count = startNumbers.length;
          var index = 0;
          sequence = findPattern([endValue.replace(/\d+\.?\d*/g, function () {
              return startNumbers[index++ % count];
          }), endValue], propertyName);
      }
      if (sequence) {
          if (Velocity$$1.debug) {
              console.log("Velocity: Sequence found:", sequence);
          }
          sequence[0].percent = 0;
          sequence[1].percent = 1;
          tween.sequence = sequence;
          switch (tween.easing) {
              case Easings["at-start"]:
              case Easings["during"]:
              case Easings["at-end"]:
                  sequence[0].easing = sequence[1].easing = tween.easing;
                  break;
          }
      }
  }
  /**
   * Expand all queued animations that haven't gone yet
   *
   * This will automatically expand the properties map for any recently added
   * animations so that the start and end values are correct.
   */
  function validateTweens(activeCall) {
      // This might be called on an already-ready animation
      if (State.firstNew === activeCall) {
          State.firstNew = activeCall._next;
      }
      // Check if we're actually already ready
      if (activeCall._flags & 1 /* EXPANDED */) {
              // tslint:disable-line:no-bitwise
              return;
          }
      var element = activeCall.element,
          tweens = activeCall.tweens,
          duration = getValue(activeCall.options.duration, defaults$1.duration);
      // tslint:disable-next-line:forin
      for (var propertyName in tweens) {
          var tween = tweens[propertyName];
          if (tween.start == null) {
              // Get the start value as it's not been passed in
              var startValue = getPropertyValue(activeCall.element, propertyName);
              if (isString(startValue)) {
                  tween.start = fixColors(startValue);
                  explodeTween(propertyName, tween, duration, true);
              } else if (!Array.isArray(startValue)) {
                  console.warn("bad type", tween, propertyName, startValue);
              }
          }
          if (Velocity$$1.debug) {
              console.log("tweensContainer \"" + propertyName + "\": " + JSON.stringify(tween), element);
          }
      }
      activeCall._flags |= 1 /* EXPANDED */; // tslint:disable-line:no-bitwise
  }

  // Project
  /**
   * Call the begin method of an animation in a separate function so it can
   * benefit from JIT compiling while still having a try/catch block.
   */
  function beginCall(activeCall) {
      var callback = activeCall.begin || activeCall.options.begin;
      if (callback) {
          try {
              var elements = activeCall.elements;
              callback.call(elements, elements, activeCall);
          } catch (error) {
              setTimeout(function () {
                  throw error;
              }, 1);
          }
      }
  }
  /**
   * Call the progress method of an animation in a separate function so it can
   * benefit from JIT compiling while still having a try/catch block.
   */
  function progressCall(activeCall) {
      var callback = activeCall.progress || activeCall.options.progress;
      if (callback) {
          try {
              var elements = activeCall.elements,
                  percentComplete = activeCall.percentComplete,
                  options = activeCall.options,
                  tweenValue = activeCall.tween;
              callback.call(elements, elements, percentComplete, Math.max(0, activeCall.timeStart + (activeCall.duration != null ? activeCall.duration : options.duration != null ? options.duration : defaults$1.duration) - lastTick), tweenValue !== undefined ? tweenValue : String(percentComplete * 100), activeCall);
          } catch (error) {
              setTimeout(function () {
                  throw error;
              }, 1);
          }
      }
  }
  function asyncCallbacks() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
          for (var _iterator = progressed[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var activeCall = _step.value;

              progressCall(activeCall);
          }
      } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
      } finally {
          try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
              }
          } finally {
              if (_didIteratorError) {
                  throw _iteratorError;
              }
          }
      }

      progressed.clear();
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
          for (var _iterator2 = completed[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var _activeCall = _step2.value;

              completeCall(_activeCall);
          }
      } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
      } finally {
          try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
              }
          } finally {
              if (_didIteratorError2) {
                  throw _iteratorError2;
              }
          }
      }

      completed.clear();
  }
  /**************
   Timing
   **************/
  var FRAME_TIME = 1000 / 60,

  /**
   * Animations with a Complete callback.
   */
  completed = new Set(),

  /**
   * Animations with a Progress callback.
   */
  progressed = new Set(),

  /**
   * Shim for window.performance in case it doesn't exist
   */
  performance = function () {
      var perf = window.performance || {};
      if (typeof perf.now !== "function") {
          var nowOffset = perf.timing && perf.timing.navigationStart ? perf.timing.navigationStart : now();
          perf.now = function () {
              return now() - nowOffset;
          };
      }
      return perf;
  }(),

  /**
   * Proxy function for when rAF is not available.
   *
   * This should hopefully never be used as the browsers often throttle
   * this to less than one frame per second in the background, making it
   * completely unusable.
   */
  rAFProxy = function rAFProxy(callback) {
      return setTimeout(callback, Math.max(0, FRAME_TIME - (performance.now() - lastTick)));
  },

  /**
   * Either requestAnimationFrame, or a shim for it.
   */
  rAFShim = window.requestAnimationFrame || rAFProxy;
  /**
   * Set if we are currently inside a tick() to prevent double-calling.
   */
  var ticking = void 0,

  /**
   * A background WebWorker that sends us framerate messages when we're in
   * the background. Without this we cannot maintain frame accuracy.
   */
  worker = void 0;
  /**
   * The time that the last animation frame ran at. Set from tick(), and used
   * for missing rAF (ie, when not in focus etc).
   */
  var lastTick = 0;
  /**
   * WebWorker background function.
   *
   * When we're in the background this will send us a msg every tick, when in
   * the foreground it won't.
   *
   * When running in the background the browser reduces allowed CPU etc, so
   * we raun at 30fps instead of 60fps.
   */
  function workerFn() {
      var _this = this;

      var interval = void 0;
      this.onmessage = function (e) {
          switch (e.data) {
              case true:
                  if (!interval) {
                      interval = setInterval(function () {
                          _this.postMessage(true);
                      }, 1000 / 30);
                  }
                  break;
              case false:
                  if (interval) {
                      clearInterval(interval);
                      interval = 0;
                  }
                  break;
              default:
                  _this.postMessage(e.data);
                  break;
          }
      };
  }
  try {
      // Create the worker - this might not be supported, hence the try/catch.
      worker = new Worker(URL.createObjectURL(new Blob(["(" + workerFn + ")()"])));
      // Whenever the worker sends a message we tick()
      worker.onmessage = function (e) {
          if (e.data === true) {
              tick();
          } else {
              asyncCallbacks();
          }
      };
      // And watch for going to the background to start the WebWorker running.
      if (!State.isMobile && document.hidden !== undefined) {
          document.addEventListener("visibilitychange", function () {
              worker.postMessage(State.isTicking && document.hidden);
          });
      }
  } catch (e) {}
  /*
   * WebWorkers are not supported in this format. This can happen in IE10
   * where it can't create one from a blob this way. We fallback, but make
   * no guarantees towards accuracy in this case.
   */

  /**
   * Called on every tick, preferably through rAF. This is reponsible for
   * initialising any new animations, then starting any that need starting.
   * Finally it will expand any tweens and set the properties relating to
   * them. If there are any callbacks relating to the animations then they
   * will attempt to call at the end (with the exception of "begin").
   */
  function tick(timestamp) {
      if (ticking) {
          // Should never happen - but if we've swapped back from hidden to
          // visibile then we want to make sure
          return;
      }
      ticking = true;
      /* An empty timestamp argument indicates that this is the first tick occurence since ticking was turned on.
       We leverage this metadata to fully ignore the first tick pass since RAF's initial pass is fired whenever
       the browser's next tick sync time occurs, which results in the first elements subjected to Velocity
       calls being animated out of sync with any elements animated immediately thereafter. In short, we ignore
       the first RAF tick pass so that elements being immediately consecutively animated -- instead of simultaneously animated
       by the same Velocity call -- are properly batched into the same initial RAF tick and consequently remain in sync thereafter. */
      if (timestamp !== false) {
          var timeCurrent = performance.now(),
              deltaTime = lastTick ? timeCurrent - lastTick : FRAME_TIME,
              defaultSpeed = defaults$1.speed,
              defaultEasing = defaults$1.easing,
              defaultDuration = defaults$1.duration;
          var activeCall = void 0,
              nextCall = void 0;
          if (deltaTime >= defaults$1.minFrameTime || !lastTick) {
              lastTick = timeCurrent;
              /********************
               Call Iteration
               ********************/
              // Expand any tweens that might need it.
              while (State.firstNew) {
                  validateTweens(State.firstNew);
              }
              // Iterate through each active call.
              for (activeCall = State.first; activeCall && activeCall !== State.firstNew; activeCall = activeCall._next) {
                  var element = activeCall.element,
                      data = Data(element);
                  // Check to see if this element has been deleted midway
                  // through the animation. If it's gone then end this
                  // animation.
                  if (!element.parentNode || !data) {
                      // TODO: Remove safely - decrease count, delete data, remove from arrays
                      freeAnimationCall(activeCall);
                      continue;
                  }
                  // Don't bother getting until we can use these.
                  var options = activeCall.options,
                      flags = activeCall._flags;
                  var timeStart = activeCall.timeStart;
                  // If this is the first time that this call has been
                  // processed by tick() then we assign timeStart now so that
                  // it's value is as close to the real animation start time
                  // as possible.
                  if (!timeStart) {
                      var queue = activeCall.queue != null ? activeCall.queue : options.queue;
                      timeStart = timeCurrent - deltaTime;
                      if (queue !== false) {
                          timeStart = Math.max(timeStart, data.lastFinishList[queue] || 0);
                      }
                      activeCall.timeStart = timeStart;
                  }
                  // If this animation is paused then skip processing unless
                  // it has been set to resume.
                  if (flags & 16 /* PAUSED */) {
                          // tslint:disable-line:no-bitwise
                          // Update the time start to accomodate the paused
                          // completion amount.
                          activeCall.timeStart += deltaTime;
                          continue;
                      }
                  // Check if this animation is ready - if it's synced then it
                  // needs to wait for all other animations in the sync
                  if (!(flags & 2 /* READY */)) {
                      // tslint:disable-line:no-bitwise
                      activeCall._flags |= 2 /* READY */; // tslint:disable-line:no-bitwise
                      options._ready++;
                  }
              }
              // Need to split the loop, as ready sync animations must all get
              // the same start time.
              for (activeCall = State.first; activeCall && activeCall !== State.firstNew; activeCall = nextCall) {
                  var _flags = activeCall._flags;
                  nextCall = activeCall._next;
                  if (!(_flags & 2 /* READY */) || _flags & 16 /* PAUSED */) {
                      // tslint:disable-line:no-bitwise
                      continue;
                  }
                  var _options = activeCall.options;
                  if (_flags & 32 /* SYNC */ && _options._ready < _options._total) {
                      // tslint:disable-line:no-bitwise
                      activeCall.timeStart += deltaTime;
                      continue;
                  }
                  var speed = activeCall.speed != null ? activeCall.speed : _options.speed != null ? _options.speed : defaultSpeed;
                  var _timeStart = activeCall.timeStart;
                  // Don't bother getting until we can use these.
                  if (!(_flags & 4 /* STARTED */)) {
                      // tslint:disable-line:no-bitwise
                      var delay = activeCall.delay != null ? activeCall.delay : _options.delay;
                      // Make sure anything we've delayed doesn't start
                      // animating yet, there might still be an active delay
                      // after something has been un-paused
                      if (delay) {
                          if (_timeStart + delay / speed > timeCurrent) {
                              continue;
                          }
                          activeCall.timeStart = _timeStart += delay / (delay > 0 ? speed : 1);
                      }
                      activeCall._flags |= 4 /* STARTED */; // tslint:disable-line:no-bitwise
                      // The begin callback is fired once per call, not once
                      // per element, and is passed the full raw DOM element
                      // set as both its context and its first argument.
                      if (_options._started++ === 0) {
                          _options._first = activeCall;
                          if (_options.begin) {
                              // Pass to an external fn with a try/catch block for optimisation
                              beginCall(activeCall);
                              // Only called once, even if reversed or repeated
                              _options.begin = undefined;
                          }
                      }
                  }
                  if (speed !== 1) {
                      // On the first frame we may have a shorter delta
                      // const delta = Math.min(deltaTime, timeCurrent - timeStart);
                      activeCall.timeStart = _timeStart += Math.min(deltaTime, timeCurrent - _timeStart) * (1 - speed);
                  }
                  var activeEasing = activeCall.easing != null ? activeCall.easing : _options.easing != null ? _options.easing : defaultEasing,
                      millisecondsEllapsed = activeCall.ellapsedTime = timeCurrent - _timeStart,
                      duration = activeCall.duration != null ? activeCall.duration : _options.duration != null ? _options.duration : defaultDuration,
                      percentComplete = activeCall.percentComplete = Velocity$$1.mock ? 1 : Math.min(millisecondsEllapsed / duration, 1),
                      tweens = activeCall.tweens,
                      reverse = _flags & 64 /* REVERSE */; // tslint:disable-line:no-bitwise
                  if (activeCall.progress || _options._first === activeCall && _options.progress) {
                      progressed.add(activeCall);
                  }
                  if (percentComplete === 1) {
                      completed.add(activeCall);
                  }
                  // tslint:disable-next-line:forin
                  for (var property in tweens) {
                      // For every element, iterate through each property.
                      var tween = tweens[property],
                          sequence = tween.sequence,
                          pattern = sequence.pattern;
                      var currentValue = "",
                          i = 0;
                      if (pattern) {
                          var easingComplete = (tween.easing || activeEasing)(percentComplete, 0, 1, property);
                          var best = 0;
                          for (var j = 0; j < sequence.length - 1; j++) {
                              if (sequence[j].percent < easingComplete) {
                                  best = j;
                              }
                          }
                          var tweenFrom = sequence[best],
                              tweenTo = sequence[best + 1] || tweenFrom,
                              tweenPercent = (percentComplete - tweenFrom.percent) / (tweenTo.percent - tweenFrom.percent),
                              easing = tweenTo.easing || linearEasing;
                          for (; i < pattern.length; i++) {
                              var startValue = tweenFrom[i];
                              if (startValue == null) {
                                  currentValue += pattern[i];
                              } else {
                                  var endValue = tweenTo[i];
                                  if (startValue === endValue) {
                                      currentValue += startValue;
                                  } else {
                                      // All easings must deal with numbers except for our internal ones.
                                      var result = easing(reverse ? 1 - tweenPercent : tweenPercent, startValue, endValue, property);
                                      currentValue += pattern[i] === true ? Math.round(result) : result;
                                  }
                              }
                          }
                          if (property !== "tween") {
                              if (percentComplete === 1 && currentValue.startsWith("calc(0 + ")) {
                                  currentValue = currentValue.replace(/^calc\(0[^\d]* \+ ([^\(\)]+)\)$/, "$1");
                              }
                              // TODO: To solve an IE<=8 positioning bug, the unit type must be dropped when setting a property value of 0 - add normalisations to legacy
                              setPropertyValue(activeCall.element, property, currentValue, tween.fn);
                          } else {
                              // Skip the fake 'tween' property as that is only
                              // passed into the progress callback.
                              activeCall.tween = currentValue;
                          }
                      } else {
                          console.warn("VelocityJS: Missing pattern:", property, JSON.stringify(tween[property]));
                          delete tweens[property];
                      }
                  }
              }
              if (progressed.size || completed.size) {
                  if (!document.hidden) {
                      asyncCallbacks();
                  } else if (worker) {
                      worker.postMessage("");
                  } else {
                      setTimeout(asyncCallbacks, 1);
                  }
              }
          }
      }
      if (State.first) {
          State.isTicking = true;
          if (!document.hidden) {
              rAFShim(tick);
          } else if (!worker) {
              rAFProxy(tick);
          } else if (timestamp === false) {
              // Make sure we turn on the messages.
              worker.postMessage(true);
          }
      } else {
          State.isTicking = false;
          lastTick = 0;
          if (document.hidden && worker) {
              // Make sure we turn off the messages.
              worker.postMessage(false);
          }
      }
      ticking = false;
  }

  // Project
  /**
   * Check if an animation should be finished, and if so we set the tweens to
   * the final value for it, then call complete.
   */
  function checkAnimationShouldBeFinished(animation, queueName, defaultQueue) {
      validateTweens(animation);
      if (queueName === undefined || queueName === getValue(animation.queue, animation.options.queue, defaultQueue)) {
          if (!(animation._flags & 4 /* STARTED */)) {
              // tslint:disable-line:no-bitwise
              // Copied from tick.ts - ensure that the animation is completely
              // valid and run begin() before complete().
              var options = animation.options;
              // The begin callback is fired once per call, not once per
              // element, and is passed the full raw DOM element set as both
              // its context and its first argument.
              if (options._started++ === 0) {
                  options._first = animation;
                  if (options.begin) {
                      // Pass to an external fn with a try/catch block for optimisation
                      beginCall(animation);
                      // Only called once, even if reversed or repeated
                      options.begin = undefined;
                  }
              }
              animation._flags |= 4 /* STARTED */; // tslint:disable-line:no-bitwise
          }
          // tslint:disable-next-line:forin
          for (var property in animation.tweens) {
              var tween = animation.tweens[property],
                  sequence = tween.sequence,
                  pattern = sequence.pattern;
              var currentValue = "",
                  i = 0;
              if (pattern) {
                  var endValues = sequence[sequence.length - 1];
                  for (; i < pattern.length; i++) {
                      var endValue = endValues[i];
                      currentValue += endValue == null ? pattern[i] : endValue;
                  }
              }
              setPropertyValue(animation.element, property, currentValue, tween.fn);
          }
          completeCall(animation);
      }
  }
  /**
   * When the finish action is triggered, the elements' currently active call is
   * immediately finished. When an element is finished, the next item in its
   * animation queue is immediately triggered. If passed via a chained call
   * then this will only target the animations in that call, and not the
   * elements linked to it.
   *
   * A queue name may be passed in to specify that only animations on the
   * named queue are finished. The default queue is named "". In addition the
   * value of `false` is allowed for the queue name.
   *
   * An final argument may be passed in to clear an element's remaining queued
   * calls. This may only be the value `true`.
   */
  function finish(args, elements, promiseHandler) {
      var queueName = validateQueue(args[0], true),
          defaultQueue = defaults$1.queue,
          finishAll = args[queueName === undefined ? 0 : 1] === true;
      if (isVelocityResult(elements) && elements.velocity.animations) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
              for (var _iterator = elements.velocity.animations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var animation = _step.value;

                  checkAnimationShouldBeFinished(animation, queueName, defaultQueue);
              }
          } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
          } finally {
              try {
                  if (!_iteratorNormalCompletion && _iterator.return) {
                      _iterator.return();
                  }
              } finally {
                  if (_didIteratorError) {
                      throw _iteratorError;
                  }
              }
          }
      } else {
          while (State.firstNew) {
              validateTweens(State.firstNew);
          }
          for (var activeCall = State.first, nextCall; activeCall && (finishAll || activeCall !== State.firstNew); activeCall = nextCall || State.firstNew) {
              nextCall = activeCall._next;
              if (!elements || elements.includes(activeCall.element)) {
                  checkAnimationShouldBeFinished(activeCall, queueName, defaultQueue);
              }
          }
      }
      if (promiseHandler) {
          if (isVelocityResult(elements) && elements.velocity.animations && elements.then) {
              elements.then(promiseHandler._resolver);
          } else {
              promiseHandler._resolver(elements);
          }
      }
  }
  registerAction(["finish", finish], true);

  /**
   * Used to map getters for the various AnimationFlags.
   */
  var animationFlags = {
      isExpanded: 1 /* EXPANDED */
      , isReady: 2 /* READY */
      , isStarted: 4 /* STARTED */
      , isStopped: 8 /* STOPPED */
      , isPaused: 16 /* PAUSED */
      , isSync: 32 /* SYNC */
      , isReverse: 64 /* REVERSE */
  };
  /**
   * Get or set an option or running AnimationCall data value. If there is no
   * value passed then it will get, otherwise we will set.
   *
   * NOTE: When using "get" this will not touch the Promise as it is never
   * returned to the user.
   */
  function option(args, elements, promiseHandler, action) {
      var key = args[0],
          queue = action.indexOf(".") >= 0 ? action.replace(/^.*\./, "") : undefined,
          queueName = queue === "false" ? false : validateQueue(queue, true);
      var animations = void 0,
          value = args[1];
      if (!key) {
          console.warn("VelocityJS: Cannot access a non-existant key!");
          return null;
      }
      // If we're chaining the return value from Velocity then we are only
      // interested in the values related to that call
      if (isVelocityResult(elements) && elements.velocity.animations) {
          animations = elements.velocity.animations;
      } else {
          animations = [];
          for (var activeCall = State.first; activeCall; activeCall = activeCall._next) {
              if (elements.indexOf(activeCall.element) >= 0 && getValue(activeCall.queue, activeCall.options.queue) === queueName) {
                  animations.push(activeCall);
              }
          }
          // If we're dealing with multiple elements that are pointing at a
          // single running animation, then instead treat them as a single
          // animation.
          if (elements.length > 1 && animations.length > 1) {
              var i = 1,
                  options = animations[0].options;
              while (i < animations.length) {
                  if (animations[i++].options !== options) {
                      options = null;
                      break;
                  }
              }
              // TODO: this needs to check that they're actually a sync:true animation to merge the results, otherwise the individual values may be different
              if (options) {
                  animations = [animations[0]];
              }
          }
      }
      // GET
      if (value === undefined) {
          var result = [],
              flag = animationFlags[key];
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
              for (var _iterator = animations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var animation = _step.value;

                  if (flag === undefined) {
                      // A normal key to get.
                      result.push(getValue(animation[key], animation.options[key]));
                  } else {
                      // A flag that we're checking against.
                      result.push((animation._flags & flag) === 0); // tslint:disable-line:no-bitwise
                  }
              }
          } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
          } finally {
              try {
                  if (!_iteratorNormalCompletion && _iterator.return) {
                      _iterator.return();
                  }
              } finally {
                  if (_didIteratorError) {
                      throw _iteratorError;
                  }
              }
          }

          if (elements.length === 1 && animations.length === 1) {
              // If only a single animation is found and we're only targetting a
              // single element, then return the value directly
              return result[0];
          }
          return result;
      }
      // SET
      var isPercentComplete = void 0;
      switch (key) {
          case "cache":
              value = validateCache(value);
              break;
          case "begin":
              value = validateBegin(value);
              break;
          case "complete":
              value = validateComplete(value);
              break;
          case "delay":
              value = validateDelay(value);
              break;
          case "duration":
              value = validateDuration(value);
              break;
          case "fpsLimit":
              value = validateFpsLimit(value);
              break;
          case "loop":
              value = validateLoop(value);
              break;
          case "percentComplete":
              isPercentComplete = true;
              value = parseFloat(value);
              break;
          case "repeat":
          case "repeatAgain":
              value = validateRepeat(value);
              break;
          default:
              if (key[0] !== "_") {
                  var num = parseFloat(value);
                  if (value === String(num)) {
                      value = num;
                  }
                  break;
              }
          // deliberate fallthrough
          case "queue":
          case "promise":
          case "promiseRejectEmpty":
          case "easing":
          case "started":
              console.warn("VelocityJS: Trying to set a read-only key:", key);
              return;
      }
      if (value === undefined || value !== value) {
          console.warn("VelocityJS: Trying to set an invalid value:" + key + "=" + value + " (" + args[1] + ")");
          return null;
      }
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
          for (var _iterator2 = animations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var _animation = _step2.value;

              if (isPercentComplete) {
                  _animation.timeStart = lastTick - getValue(_animation.duration, _animation.options.duration, defaults$1.duration) * value;
              } else {
                  _animation[key] = value;
              }
          }
      } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
      } finally {
          try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
              }
          } finally {
              if (_didIteratorError2) {
                  throw _iteratorError2;
              }
          }
      }

      if (promiseHandler) {
          if (isVelocityResult(elements) && elements.velocity.animations && elements.then) {
              elements.then(promiseHandler._resolver);
          } else {
              promiseHandler._resolver(elements);
          }
      }
  }
  registerAction(["option", option], true);

  // Project
  /**
   * Check if an animation should be paused / resumed.
   */
  function checkAnimation(animation, queueName, defaultQueue, isPaused) {
      if (queueName === undefined || queueName === getValue(animation.queue, animation.options.queue, defaultQueue)) {
          if (isPaused) {
              animation._flags |= 16 /* PAUSED */; // tslint:disable-line:no-bitwise
          } else {
              animation._flags &= ~16 /* PAUSED */; // tslint:disable-line:no-bitwise
          }
      }
  }
  /**
   * Pause and Resume are call-wide (not on a per element basis). Thus, calling pause or resume on a
   * single element will cause any calls that contain tweens for that element to be paused/resumed
   * as well.
   */
  function pauseResume(args, elements, promiseHandler, action) {
      var isPaused = action.indexOf("pause") === 0,
          queue = action.indexOf(".") >= 0 ? action.replace(/^.*\./, "") : undefined,
          queueName = queue === "false" ? false : validateQueue(args[0]),
          defaultQueue = defaults$1.queue;
      if (isVelocityResult(elements) && elements.velocity.animations) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
              for (var _iterator = elements.velocity.animations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var animation = _step.value;

                  checkAnimation(animation, queueName, defaultQueue, isPaused);
              }
          } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
          } finally {
              try {
                  if (!_iteratorNormalCompletion && _iterator.return) {
                      _iterator.return();
                  }
              } finally {
                  if (_didIteratorError) {
                      throw _iteratorError;
                  }
              }
          }
      } else {
          var activeCall = State.first;
          while (activeCall) {
              if (!elements || elements.includes(activeCall.element)) {
                  checkAnimation(activeCall, queueName, defaultQueue, isPaused);
              }
              activeCall = activeCall._next;
          }
      }
      if (promiseHandler) {
          if (isVelocityResult(elements) && elements.velocity.animations && elements.then) {
              elements.then(promiseHandler._resolver);
          } else {
              promiseHandler._resolver(elements);
          }
      }
  }
  registerAction(["pause", pauseResume], true);
  registerAction(["resume", pauseResume], true);

  // Project
  /**
   * Get or set a style of Nomralised property value on one or more elements.
   * If there is no value passed then it will get, otherwise we will set.
   *
   * NOTE: When using "get" this will not touch the Promise as it is never
   * returned to the user.
   *
   * This can fail to set, and will reject the Promise if it does so.
   *
   * Velocity(elements, "style", "property", "value") => elements;
   * Velocity(elements, "style", {"property": "value", ...}) => elements;
   * Velocity(element, "style", "property") => "value";
   * Velocity(elements, "style", "property") => ["value", ...];
   */
  function propertyAction(args, elements, promiseHandler, action) {
      var property = args[0],
          value = args[1];
      if (!property) {
          console.warn("VelocityJS: Cannot access a non-existant property!");
          return null;
      }
      // GET
      if (value === undefined && !isPlainObject(property)) {
          if (Array.isArray(property)) {
              if (elements.length === 1) {
                  var result = {};
                  var _iteratorNormalCompletion = true;
                  var _didIteratorError = false;
                  var _iteratorError = undefined;

                  try {
                      for (var _iterator = property[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                          var prop = _step.value;

                          result[prop] = fixColors(getPropertyValue(elements[0], prop));
                      }
                  } catch (err) {
                      _didIteratorError = true;
                      _iteratorError = err;
                  } finally {
                      try {
                          if (!_iteratorNormalCompletion && _iterator.return) {
                              _iterator.return();
                          }
                      } finally {
                          if (_didIteratorError) {
                              throw _iteratorError;
                          }
                      }
                  }

                  return result;
              } else {
                  var _result = [];
                  var _iteratorNormalCompletion2 = true;
                  var _didIteratorError2 = false;
                  var _iteratorError2 = undefined;

                  try {
                      for (var _iterator2 = elements[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                          var element = _step2.value;

                          var res = {};
                          var _iteratorNormalCompletion3 = true;
                          var _didIteratorError3 = false;
                          var _iteratorError3 = undefined;

                          try {
                              for (var _iterator3 = property[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                                  var _prop = _step3.value;

                                  res[_prop] = fixColors(getPropertyValue(element, _prop));
                              }
                          } catch (err) {
                              _didIteratorError3 = true;
                              _iteratorError3 = err;
                          } finally {
                              try {
                                  if (!_iteratorNormalCompletion3 && _iterator3.return) {
                                      _iterator3.return();
                                  }
                              } finally {
                                  if (_didIteratorError3) {
                                      throw _iteratorError3;
                                  }
                              }
                          }

                          _result.push(res);
                      }
                  } catch (err) {
                      _didIteratorError2 = true;
                      _iteratorError2 = err;
                  } finally {
                      try {
                          if (!_iteratorNormalCompletion2 && _iterator2.return) {
                              _iterator2.return();
                          }
                      } finally {
                          if (_didIteratorError2) {
                              throw _iteratorError2;
                          }
                      }
                  }

                  return _result;
              }
          } else {
              // If only a single animation is found and we're only targetting a
              // single element, then return the value directly
              if (elements.length === 1) {
                  return fixColors(getPropertyValue(elements[0], property));
              }
              var _result2 = [];
              var _iteratorNormalCompletion4 = true;
              var _didIteratorError4 = false;
              var _iteratorError4 = undefined;

              try {
                  for (var _iterator4 = elements[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                      var _element = _step4.value;

                      _result2.push(fixColors(getPropertyValue(_element, property)));
                  }
              } catch (err) {
                  _didIteratorError4 = true;
                  _iteratorError4 = err;
              } finally {
                  try {
                      if (!_iteratorNormalCompletion4 && _iterator4.return) {
                          _iterator4.return();
                      }
                  } finally {
                      if (_didIteratorError4) {
                          throw _iteratorError4;
                      }
                  }
              }

              return _result2;
          }
      }
      // SET
      var error = [];
      if (isPlainObject(property)) {
          for (var propertyName in property) {
              if (property.hasOwnProperty(propertyName)) {
                  var _iteratorNormalCompletion5 = true;
                  var _didIteratorError5 = false;
                  var _iteratorError5 = undefined;

                  try {
                      for (var _iterator5 = elements[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                          var _element2 = _step5.value;

                          var propertyValue = property[propertyName];
                          if (isString(propertyValue) || isNumber(propertyValue)) {
                              setPropertyValue(_element2, propertyName, property[propertyName]);
                          } else {
                              error.push("Cannot set a property \"" + propertyName + "\" to an unknown type: " + (typeof propertyValue === "undefined" ? "undefined" : _typeof(propertyValue)));
                              console.warn("VelocityJS: Cannot set a property \"" + propertyName + "\" to an unknown type:", propertyValue);
                          }
                      }
                  } catch (err) {
                      _didIteratorError5 = true;
                      _iteratorError5 = err;
                  } finally {
                      try {
                          if (!_iteratorNormalCompletion5 && _iterator5.return) {
                              _iterator5.return();
                          }
                      } finally {
                          if (_didIteratorError5) {
                              throw _iteratorError5;
                          }
                      }
                  }
              }
          }
      } else if (isString(value) || isNumber(value)) {
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
              for (var _iterator6 = elements[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                  var _element3 = _step6.value;

                  setPropertyValue(_element3, property, String(value));
              }
          } catch (err) {
              _didIteratorError6 = true;
              _iteratorError6 = err;
          } finally {
              try {
                  if (!_iteratorNormalCompletion6 && _iterator6.return) {
                      _iterator6.return();
                  }
              } finally {
                  if (_didIteratorError6) {
                      throw _iteratorError6;
                  }
              }
          }
      } else {
          error.push("Cannot set a property \"" + property + "\" to an unknown type: " + (typeof value === "undefined" ? "undefined" : _typeof(value)));
          console.warn("VelocityJS: Cannot set a property \"" + property + "\" to an unknown type:", value);
      }
      if (promiseHandler) {
          if (error.length) {
              promiseHandler._rejecter(error.join(", "));
          } else if (isVelocityResult(elements) && elements.velocity.animations && elements.then) {
              elements.then(promiseHandler._resolver);
          } else {
              promiseHandler._resolver(elements);
          }
      }
  }
  registerAction(["property", propertyAction], true);

  // Project
  registerAction(["reverse", function (args, elements, promiseHandler, action) {
          // NOTE: Code needs to split out before here - but this is needed to prevent it being overridden
          throw new SyntaxError("VelocityJS: The 'reverse' action is built in and private.");
  }], true);

  // Project
  /**
   * Check if an animation should be stopped, and if so then set the STOPPED
   * flag on it, then call complete.
   */
  function checkAnimationShouldBeStopped(animation, queueName, defaultQueue) {
      validateTweens(animation);
      if (queueName === undefined || queueName === getValue(animation.queue, animation.options.queue, defaultQueue)) {
          animation._flags |= 8 /* STOPPED */; // tslint:disable-line:no-bitwise
          completeCall(animation);
      }
  }
  /**
   * When the stop action is triggered, the elements' currently active call is
   * immediately stopped. When an element is stopped, the next item in its
   * animation queue is immediately triggered. If passed via a chained call
   * then this will only target the animations in that call, and not the
   * elements linked to it.
   *
   * A queue name may be passed in to specify that only animations on the
   * named queue are stopped. The default queue is named "". In addition the
   * value of `false` is allowed for the queue name.
   *
   * An final argument may be passed in to clear an element's remaining queued
   * calls. This may only be the value `true`.
   *
   * Note: The stop command runs prior to Velocity's Queueing phase since its
   * behavior is intended to take effect *immediately*, regardless of the
   * element's current queue state.
   */
  function stop(args, elements, promiseHandler, action) {
      var queueName = validateQueue(args[0], true),
          defaultQueue = defaults$1.queue,
          finishAll = args[queueName === undefined ? 0 : 1] === true;
      if (isVelocityResult(elements) && elements.velocity.animations) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
              for (var _iterator = elements.velocity.animations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var animation = _step.value;

                  checkAnimationShouldBeStopped(animation, queueName, defaultQueue);
              }
          } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
          } finally {
              try {
                  if (!_iteratorNormalCompletion && _iterator.return) {
                      _iterator.return();
                  }
              } finally {
                  if (_didIteratorError) {
                      throw _iteratorError;
                  }
              }
          }
      } else {
          while (State.firstNew) {
              validateTweens(State.firstNew);
          }
          for (var activeCall = State.first, nextCall; activeCall && (finishAll || activeCall !== State.firstNew); activeCall = nextCall || State.firstNew) {
              nextCall = activeCall._next;
              if (!elements || elements.includes(activeCall.element)) {
                  checkAnimationShouldBeStopped(activeCall, queueName, defaultQueue);
              }
          }
      }
      if (promiseHandler) {
          if (isVelocityResult(elements) && elements.velocity.animations && elements.then) {
              elements.then(promiseHandler._resolver);
          } else {
              promiseHandler._resolver(elements);
          }
      }
  }
  registerAction(["stop", stop], true);

  // Project
  registerAction(["style", propertyAction], true);

  // Project
  /**
   *
   */
  function tweenAction(args, elements, promiseHandler, action) {
      var requireForcefeeding = void 0;
      if (!elements) {
          if (!args.length) {
              console.info("Velocity(<element>, \"tween\", percentComplete, property, end | [end, <easing>, <start>], <easing>) => value\nVelocity(<element>, \"tween\", percentComplete, {property: end | [end, <easing>, <start>], ...}, <easing>) => {property: value, ...}");
              return null;
          }
          elements = [document.body];
          requireForcefeeding = true;
      } else if (elements.length !== 1) {
          // TODO: Allow more than a single element to return an array of results
          throw new Error("VelocityJS: Cannot tween more than one element!");
      }
      var percentComplete = args[0],
          fakeAnimation = {
          elements: elements,
          element: elements[0],
          queue: false,
          options: {
              duration: 1000
          },
          tweens: null
      },
          result = {};
      var properties = args[1],
          singleResult = void 0,
          maybeSequence = void 0,
          easing = args[2],
          count = 0;
      if (isString(args[1])) {
          if (SequencesObject && SequencesObject[args[1]]) {
              maybeSequence = SequencesObject[args[1]];
              properties = {};
              easing = args[2];
          } else {
              singleResult = true;
              properties = defineProperty({}, args[1], args[2]);
              easing = args[3];
          }
      } else if (Array.isArray(args[1])) {
          singleResult = true;
          properties = {
              tween: args[1]
          };
          easing = args[2];
      }
      if (!isNumber(percentComplete) || percentComplete < 0 || percentComplete > 1) {
          throw new Error("VelocityJS: Must tween a percentage from 0 to 1!");
      }
      if (!isPlainObject(properties)) {
          throw new Error("VelocityJS: Cannot tween an invalid property!");
      }
      if (requireForcefeeding) {
          for (var property in properties) {
              if (properties.hasOwnProperty(property) && (!Array.isArray(properties[property]) || properties[property].length < 2)) {
                  throw new Error("VelocityJS: When not supplying an element you must force-feed values: " + property);
              }
          }
      }
      var activeEasing = validateEasing(getValue(easing, defaults$1.easing), DEFAULT_DURATION);
      if (maybeSequence) {
          expandSequence(fakeAnimation, maybeSequence);
      } else {
          expandProperties(fakeAnimation, properties);
      }
      // tslint:disable-next-line:forin
      for (var _property in fakeAnimation.tweens) {
          // For every element, iterate through each property.
          var propertyTween = fakeAnimation.tweens[_property],
              sequence = propertyTween.sequence,
              pattern = sequence.pattern;
          var currentValue = "",
              i = 0;
          count++;
          if (pattern) {
              var easingComplete = (propertyTween.easing || activeEasing)(percentComplete, 0, 1, _property);
              var best = 0;
              for (var j = 0; j < sequence.length - 1; j++) {
                  if (sequence[j].percent < easingComplete) {
                      best = j;
                  }
              }
              var tweenFrom = sequence[best],
                  tweenTo = sequence[best + 1] || tweenFrom,
                  tweenPercent = (percentComplete - tweenFrom.percent) / (tweenTo.percent - tweenFrom.percent),
                  tweenEasing = tweenTo.easing || linearEasing;
              for (; i < pattern.length; i++) {
                  var startValue = tweenFrom[i];
                  if (startValue == null) {
                      currentValue += pattern[i];
                  } else {
                      var endValue = tweenTo[i];
                      if (startValue === endValue) {
                          currentValue += startValue;
                      } else {
                          // All easings must deal with numbers except for our internal ones.
                          var value = tweenEasing(tweenPercent, startValue, endValue, _property);
                          currentValue += pattern[i] === true ? Math.round(value) : value;
                      }
                  }
              }
              result[_property] = currentValue;
          }
      }
      if (singleResult && count === 1) {
          for (var _property2 in result) {
              if (result.hasOwnProperty(_property2)) {
                  return result[_property2];
              }
          }
      }
      return result;
  }
  registerAction(["tween", tweenAction], true);

  // Project
  /**
   * Converting from hex as it makes for a smaller file.
   */
  var colorValues = {
      aliceblue: 0xF0F8FF,
      antiquewhite: 0xFAEBD7,
      aqua: 0x00FFFF,
      aquamarine: 0x7FFFD4,
      azure: 0xF0FFFF,
      beige: 0xF5F5DC,
      bisque: 0xFFE4C4,
      black: 0x000000,
      blanchedalmond: 0xFFEBCD,
      blue: 0x0000FF,
      blueviolet: 0x8A2BE2,
      brown: 0xA52A2A,
      burlywood: 0xDEB887,
      cadetblue: 0x5F9EA0,
      chartreuse: 0x7FFF00,
      chocolate: 0xD2691E,
      coral: 0xFF7F50,
      cornflowerblue: 0x6495ED,
      cornsilk: 0xFFF8DC,
      crimson: 0xDC143C,
      cyan: 0x00FFFF,
      darkblue: 0x00008B,
      darkcyan: 0x008B8B,
      darkgoldenrod: 0xB8860B,
      darkgray: 0xA9A9A9,
      darkgrey: 0xA9A9A9,
      darkgreen: 0x006400,
      darkkhaki: 0xBDB76B,
      darkmagenta: 0x8B008B,
      darkolivegreen: 0x556B2F,
      darkorange: 0xFF8C00,
      darkorchid: 0x9932CC,
      darkred: 0x8B0000,
      darksalmon: 0xE9967A,
      darkseagreen: 0x8FBC8F,
      darkslateblue: 0x483D8B,
      darkslategray: 0x2F4F4F,
      darkslategrey: 0x2F4F4F,
      darkturquoise: 0x00CED1,
      darkviolet: 0x9400D3,
      deeppink: 0xFF1493,
      deepskyblue: 0x00BFFF,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1E90FF,
      firebrick: 0xB22222,
      floralwhite: 0xFFFAF0,
      forestgreen: 0x228B22,
      fuchsia: 0xFF00FF,
      gainsboro: 0xDCDCDC,
      ghostwhite: 0xF8F8FF,
      gold: 0xFFD700,
      goldenrod: 0xDAA520,
      gray: 0x808080,
      grey: 0x808080,
      green: 0x008000,
      greenyellow: 0xADFF2F,
      honeydew: 0xF0FFF0,
      hotpink: 0xFF69B4,
      indianred: 0xCD5C5C,
      indigo: 0x4B0082,
      ivory: 0xFFFFF0,
      khaki: 0xF0E68C,
      lavender: 0xE6E6FA,
      lavenderblush: 0xFFF0F5,
      lawngreen: 0x7CFC00,
      lemonchiffon: 0xFFFACD,
      lightblue: 0xADD8E6,
      lightcoral: 0xF08080,
      lightcyan: 0xE0FFFF,
      lightgoldenrodyellow: 0xFAFAD2,
      lightgray: 0xD3D3D3,
      lightgrey: 0xD3D3D3,
      lightgreen: 0x90EE90,
      lightpink: 0xFFB6C1,
      lightsalmon: 0xFFA07A,
      lightseagreen: 0x20B2AA,
      lightskyblue: 0x87CEFA,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xB0C4DE,
      lightyellow: 0xFFFFE0,
      lime: 0x00FF00,
      limegreen: 0x32CD32,
      linen: 0xFAF0E6,
      magenta: 0xFF00FF,
      maroon: 0x800000,
      mediumaquamarine: 0x66CDAA,
      mediumblue: 0x0000CD,
      mediumorchid: 0xBA55D3,
      mediumpurple: 0x9370DB,
      mediumseagreen: 0x3CB371,
      mediumslateblue: 0x7B68EE,
      mediumspringgreen: 0x00FA9A,
      mediumturquoise: 0x48D1CC,
      mediumvioletred: 0xC71585,
      midnightblue: 0x191970,
      mintcream: 0xF5FFFA,
      mistyrose: 0xFFE4E1,
      moccasin: 0xFFE4B5,
      navajowhite: 0xFFDEAD,
      navy: 0x000080,
      oldlace: 0xFDF5E6,
      olive: 0x808000,
      olivedrab: 0x6B8E23,
      orange: 0xFFA500,
      orangered: 0xFF4500,
      orchid: 0xDA70D6,
      palegoldenrod: 0xEEE8AA,
      palegreen: 0x98FB98,
      paleturquoise: 0xAFEEEE,
      palevioletred: 0xDB7093,
      papayawhip: 0xFFEFD5,
      peachpuff: 0xFFDAB9,
      peru: 0xCD853F,
      pink: 0xFFC0CB,
      plum: 0xDDA0DD,
      powderblue: 0xB0E0E6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xFF0000,
      rosybrown: 0xBC8F8F,
      royalblue: 0x4169E1,
      saddlebrown: 0x8B4513,
      salmon: 0xFA8072,
      sandybrown: 0xF4A460,
      seagreen: 0x2E8B57,
      seashell: 0xFFF5EE,
      sienna: 0xA0522D,
      silver: 0xC0C0C0,
      skyblue: 0x87CEEB,
      slateblue: 0x6A5ACD,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xFFFAFA,
      springgreen: 0x00FF7F,
      steelblue: 0x4682B4,
      tan: 0xD2B48C,
      teal: 0x008080,
      thistle: 0xD8BFD8,
      tomato: 0xFF6347,
      turquoise: 0x40E0D0,
      violet: 0xEE82EE,
      wheat: 0xF5DEB3,
      white: 0xFFFFFF,
      whitesmoke: 0xF5F5F5,
      yellow: 0xFFFF00,
      yellowgreen: 0x9ACD32
  };
  for (var name in colorValues) {
      if (colorValues.hasOwnProperty(name)) {
          var color = colorValues[name];
          ColorNames[name] = Math.floor(color / 65536) + "," + Math.floor(color / 256 % 256) + "," + color % 256;
      }
  }

  // Project
  function registerBackIn(name, amount) {
      registerEasing([name, function (percentComplete, startValue, endValue) {
          if (percentComplete === 0) {
              return startValue;
          }
          if (percentComplete === 1) {
              return endValue;
          }
          return Math.pow(percentComplete, 2) * ((amount + 1) * percentComplete - amount) * (endValue - startValue);
      }]);
  }
  function registerBackOut(name, amount) {
      registerEasing([name, function (percentComplete, startValue, endValue) {
          if (percentComplete === 0) {
              return startValue;
          }
          if (percentComplete === 1) {
              return endValue;
          }
          return (Math.pow(--percentComplete, 2) * ((amount + 1) * percentComplete + amount) + 1) * (endValue - startValue);
      }]);
  }
  function registerBackInOut(name, amount) {
      amount *= 1.525;
      registerEasing([name, function (percentComplete, startValue, endValue) {
          if (percentComplete === 0) {
              return startValue;
          }
          if (percentComplete === 1) {
              return endValue;
          }
          percentComplete *= 2;
          return (percentComplete < 1 ? Math.pow(percentComplete, 2) * ((amount + 1) * percentComplete - amount) : Math.pow(percentComplete - 2, 2) * ((amount + 1) * (percentComplete - 2) + amount) + 2) * 0.5 * (endValue - startValue);
      }]);
  }
  registerBackIn("easeInBack", 1.7);
  registerBackOut("easeOutBack", 1.7);
  registerBackInOut("easeInOutBack", 1.7);
  // TODO: Expose these as actions to register custom easings?

  // Project
  function easeOutBouncePercent(percentComplete) {
      if (percentComplete < 1 / 2.75) {
          return 7.5625 * percentComplete * percentComplete;
      }
      if (percentComplete < 2 / 2.75) {
          return 7.5625 * (percentComplete -= 1.5 / 2.75) * percentComplete + 0.75;
      }
      if (percentComplete < 2.5 / 2.75) {
          return 7.5625 * (percentComplete -= 2.25 / 2.75) * percentComplete + 0.9375;
      }
      return 7.5625 * (percentComplete -= 2.625 / 2.75) * percentComplete + 0.984375;
  }
  function easeInBouncePercent(percentComplete) {
      return 1 - easeOutBouncePercent(1 - percentComplete);
  }
  function easeInBounce(percentComplete, startValue, endValue) {
      if (percentComplete === 0) {
          return startValue;
      }
      if (percentComplete === 1) {
          return endValue;
      }
      return easeInBouncePercent(percentComplete) * (endValue - startValue);
  }
  function easeOutBounce(percentComplete, startValue, endValue) {
      if (percentComplete === 0) {
          return startValue;
      }
      if (percentComplete === 1) {
          return endValue;
      }
      return easeOutBouncePercent(percentComplete) * (endValue - startValue);
  }
  function easeInOutBounce(percentComplete, startValue, endValue) {
      if (percentComplete === 0) {
          return startValue;
      }
      if (percentComplete === 1) {
          return endValue;
      }
      return (percentComplete < 0.5 ? easeInBouncePercent(percentComplete * 2) * 0.5 : easeOutBouncePercent(percentComplete * 2 - 1) * 0.5 + 0.5) * (endValue - startValue);
  }
  registerEasing(["easeInBounce", easeInBounce]);
  registerEasing(["easeOutBounce", easeOutBounce]);
  registerEasing(["easeInOutBounce", easeInOutBounce]);

  // Project
  // Constants
  var PI2 = Math.PI * 2;
  function registerElasticIn(name, amplitude, period) {
      registerEasing([name, function (percentComplete, startValue, endValue) {
          if (percentComplete === 0) {
              return startValue;
          }
          if (percentComplete === 1) {
              return endValue;
          }
          return -(amplitude * Math.pow(2, 10 * (percentComplete -= 1)) * Math.sin((percentComplete - period / PI2 * Math.asin(1 / amplitude)) * PI2 / period)) * (endValue - startValue);
      }]);
  }
  function registerElasticOut(name, amplitude, period) {
      registerEasing([name, function (percentComplete, startValue, endValue) {
          if (percentComplete === 0) {
              return startValue;
          }
          if (percentComplete === 1) {
              return endValue;
          }
          return (amplitude * Math.pow(2, -10 * percentComplete) * Math.sin((percentComplete - period / PI2 * Math.asin(1 / amplitude)) * PI2 / period) + 1) * (endValue - startValue);
      }]);
  }
  function registerElasticInOut(name, amplitude, period) {
      registerEasing([name, function (percentComplete, startValue, endValue) {
          if (percentComplete === 0) {
              return startValue;
          }
          if (percentComplete === 1) {
              return endValue;
          }
          var s = period / PI2 * Math.asin(1 / amplitude);
          percentComplete = percentComplete * 2 - 1;
          return (percentComplete < 0 ? -0.5 * (amplitude * Math.pow(2, 10 * percentComplete) * Math.sin((percentComplete - s) * PI2 / period)) : amplitude * Math.pow(2, -10 * percentComplete) * Math.sin((percentComplete - s) * PI2 / period) * 0.5 + 1) * (endValue - startValue);
      }]);
  }
  registerElasticIn("easeInElastic", 1, 0.3);
  registerElasticOut("easeOutElastic", 1, 0.3);
  registerElasticInOut("easeInOutElastic", 1, 0.3 * 1.5);
  // TODO: Expose these as actions to register custom easings?

  // Project
  /**
   * Easing function that sets to the specified value immediately after the
   * animation starts.
   */
  function atStart(percentComplete, startValue, endValue) {
    return percentComplete === 0 ? startValue : endValue;
  }
  /**
   * Easing function that sets to the specified value while the animation is
   * running.
   */
  function during(percentComplete, startValue, endValue) {
    return percentComplete === 0 || percentComplete === 1 ? startValue : endValue;
  }
  /**
   * Easing function that sets to the specified value when the animation ends.
   */
  function atEnd(percentComplete, startValue, endValue) {
    return percentComplete === 1 ? endValue : startValue;
  }
  registerEasing(["at-start", atStart]);
  registerEasing(["during", during]);
  registerEasing(["at-end", atEnd]);

  // Project
  /**
   * Get/set the inner/outer dimension.
   */
  function getDimension(name, wantInner) {
      return function (element, propertyValue) {
          if (propertyValue === undefined) {
              return augmentDimension(element, name, wantInner) + "px";
          }
          setPropertyValue(element, name, parseFloat(propertyValue) - augmentDimension(element, name, wantInner) + "px");
      };
  }
  registerNormalization(["Element", "innerWidth", getDimension("width", true)]);
  registerNormalization(["Element", "innerHeight", getDimension("height", true)]);
  registerNormalization(["Element", "outerWidth", getDimension("width", false)]);
  registerNormalization(["Element", "outerHeight", getDimension("height", false)]);

  // Project
  // Constants
  var inlineRx = /^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|let|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i,
      listItemRx = /^(li)$/i,
      tableRowRx = /^(tr)$/i,
      tableRx = /^(table)$/i,
      tableRowGroupRx = /^(tbody)$/i;
  function display(element, propertyValue) {
      var style = element.style;
      if (propertyValue === undefined) {
          return computePropertyValue(element, "display");
      }
      if (propertyValue === "auto") {
          var nodeName = element && element.nodeName,
              data = Data(element);
          if (inlineRx.test(nodeName)) {
              propertyValue = "inline";
          } else if (listItemRx.test(nodeName)) {
              propertyValue = "list-item";
          } else if (tableRowRx.test(nodeName)) {
              propertyValue = "table-row";
          } else if (tableRx.test(nodeName)) {
              propertyValue = "table";
          } else if (tableRowGroupRx.test(nodeName)) {
              propertyValue = "table-row-group";
          } else {
              // Default to "block" when no match is found.
              propertyValue = "block";
          }
          // IMPORTANT: We need to do this as getPropertyValue bypasses the
          // Normalisation when it exists in the cache.
          data.cache["display"] = propertyValue;
      }
      style.display = propertyValue;
  }
  registerNormalization(["Element", "display", display]);

  // Project
  function clientWidth(element, propertyValue) {
      if (propertyValue == null) {
          return element.clientWidth + "px";
      }
  }
  function scrollWidth(element, propertyValue) {
      if (propertyValue == null) {
          return element.scrollWidth + "px";
      }
  }
  function clientHeight(element, propertyValue) {
      if (propertyValue == null) {
          return element.clientHeight + "px";
      }
  }
  function scrollHeight(element, propertyValue) {
      if (propertyValue == null) {
          return element.scrollHeight + "px";
      }
  }
  function scroll(direction, end) {
      return function (element, propertyValue) {
          if (propertyValue == null) {
              // Make sure we have these values cached.
              getPropertyValue(element, "client" + direction, null, true);
              getPropertyValue(element, "scroll" + direction, null, true);
              return element["scroll" + end] + "px";
          }
          var value = parseFloat(propertyValue),
              unit = propertyValue.replace(String(value), "");
          switch (unit) {
              case "":
              case "px":
                  element["scroll" + end] = value;
                  break;
              case "%":
                  var client = parseFloat(getPropertyValue(element, "client" + direction)),
                      scrollValue = parseFloat(getPropertyValue(element, "scroll" + direction));
                  element["scroll" + end] = Math.max(0, scrollValue - client) * value / 100;
                  break;
          }
      };
  }
  registerNormalization(["HTMLElement", "scroll", scroll("Height", "Top"), false]);
  registerNormalization(["HTMLElement", "scrollTop", scroll("Height", "Top"), false]);
  registerNormalization(["HTMLElement", "scrollLeft", scroll("Width", "Left"), false]);
  registerNormalization(["HTMLElement", "scrollWidth", scrollWidth]);
  registerNormalization(["HTMLElement", "clientWidth", clientWidth]);
  registerNormalization(["HTMLElement", "scrollHeight", scrollHeight]);
  registerNormalization(["HTMLElement", "clientHeight", clientHeight]);

  // Project
  /**
   * An RegExp pattern for the following list of css words using
   * http://kemio.com.ar/tools/lst-trie-re.php to generate:
   *
   * blockSize
   * borderBottomLeftRadius
   * borderBottomRightRadius
   * borderBottomWidth
   * borderImageOutset
   * borderImageWidth
   * borderLeftWidth
   * borderRadius
   * borderRightWidth
   * borderSpacing
   * borderTopLeftRadius
   * borderTopRightRadius
   * borderTopWidth
   * borderWidth
   * bottom
   * columnGap
   * columnRuleWidth
   * columnWidth
   * flexBasis
   * fontSize
   * gridColumnGap
   * gridGap
   * gridRowGap
   * height
   * inlineSize
   * left
   * letterSpacing
   * margin
   * marginBottom
   * marginLeft
   * marginRight
   * marginTop
   * maxBlockSize
   * maxHeight
   * maxInlineSize
   * maxWidth
   * minBlockSize
   * minHeight
   * minInlineSize
   * minWidth
   * objectPosition
   * outlineOffset
   * outlineWidth
   * padding
   * paddingBottom
   * paddingLeft
   * paddingRight
   * paddingTop
   * perspective
   * right
   * shapeMargin
   * strokeDashoffset
   * strokeWidth
   * textIndent
   * top
   * transformOrigin
   * width
   * wordSpacing
   */
  // tslint:disable-next-line:max-line-length
  var rxAddPx = /^(b(lockSize|o(rder(Bottom(LeftRadius|RightRadius|Width)|Image(Outset|Width)|LeftWidth|R(adius|ightWidth)|Spacing|Top(LeftRadius|RightRadius|Width)|Width)|ttom))|column(Gap|RuleWidth|Width)|f(lexBasis|ontSize)|grid(ColumnGap|Gap|RowGap)|height|inlineSize|le(ft|tterSpacing)|m(a(rgin(Bottom|Left|Right|Top)|x(BlockSize|Height|InlineSize|Width))|in(BlockSize|Height|InlineSize|Width))|o(bjectPosition|utline(Offset|Width))|p(adding(Bottom|Left|Right|Top)|erspective)|right|s(hapeMargin|troke(Dashoffset|Width))|t(extIndent|op|ransformOrigin)|w(idth|ordSpacing))$/;
  /**
   * Return a Normalisation that can be used to set / get a prefixed style
   * property.
   */
  function getSetPrefixed(propertyName, unprefixed) {
      return function (element, propertyValue) {
          if (propertyValue === undefined) {
              return computePropertyValue(element, propertyName) || computePropertyValue(element, unprefixed);
          }
          element.style[propertyName] = element.style[unprefixed] = propertyValue;
      };
  }
  /**
   * Return a Normalisation that can be used to set / get a style property.
   */
  function getSetStyle(propertyName) {
      return function (element, propertyValue) {
          if (propertyValue === undefined) {
              return computePropertyValue(element, propertyName);
          }
          element.style[propertyName] = propertyValue;
      };
  }
  /**
   * Vendor prefixes. Chrome / Safari, Firefox, IE / Edge, Opera.
   */
  var rxVendors = /^(webkit|moz|ms|o)[A-Z]/,
      prefixElement = State.prefixElement;
  if (prefixElement) {
      for (var propertyName in prefixElement.style) {
          if (rxVendors.test(propertyName)) {
              var unprefixed = propertyName.replace(/^[a-z]+([A-Z])/, function ($, letter) {
                  return letter.toLowerCase();
              });
              {
                  var addUnit = rxAddPx.test(unprefixed) ? "px" : undefined;
                  registerNormalization(["Element", unprefixed, getSetPrefixed(propertyName, unprefixed), addUnit]);
              }
          } else if (!hasNormalization(["Element", propertyName])) {
              var _addUnit = rxAddPx.test(propertyName) ? "px" : undefined;
              registerNormalization(["Element", propertyName, getSetStyle(propertyName), _addUnit]);
          }
      }
  }

  // Project
  /**
   * Get/set an attribute.
   */
  function getAttribute(name) {
      return function (element, propertyValue) {
          if (propertyValue === undefined) {
              return element.getAttribute(name);
          }
          element.setAttribute(name, propertyValue);
      };
  }
  var base = document.createElement("div"),
      rxSubtype = /^SVG(.*)Element$/,
      rxElement = /Element$/;
  Object.getOwnPropertyNames(window).forEach(function (property) {
      var subtype = rxSubtype.exec(property);
      if (subtype && subtype[1] !== "SVG") {
          // Don't do SVGSVGElement.
          try {
              var element = subtype[1] ? document.createElementNS("http://www.w3.org/2000/svg", (subtype[1] || "svg").toLowerCase()) : document.createElement("svg");
              // tslint:disable-next-line:forin
              for (var attribute in element) {
                  // Although this isn't a tween without prototypes, we do
                  // want to get hold of all attributes and not just own ones.
                  var value = element[attribute];
                  if (isString(attribute) && !(attribute[0] === "o" && attribute[1] === "n") && attribute !== attribute.toUpperCase() && !rxElement.test(attribute) && !(attribute in base) && !isFunction(value)) {
                      // TODO: Should this all be set on the generic SVGElement, it would save space and time, but not as powerful
                      registerNormalization([property, attribute, getAttribute(attribute)]);
                  }
              }
          } catch (e) {
              console.error("VelocityJS: Error when trying to identify SVG attributes on " + property + ".", e);
          }
      }
  });

  // Project
  /**
   * Get/set the width or height.
   */
  function getDimension$1(name) {
      return function (element, propertyValue) {
          if (propertyValue === undefined) {
              // Firefox throws an error if .getBBox() is called on an SVG that isn't attached to the DOM.
              try {
                  return element.getBBox()[name] + "px";
              } catch (e) {
                  return "0px";
              }
          }
          element.setAttribute(name, propertyValue);
      };
  }
  registerNormalization(["SVGElement", "width", getDimension$1("width")]);
  registerNormalization(["SVGElement", "height", getDimension$1("height")]);

  // Project
  /**
   * A fake normalization used to allow the "tween" property easy access.
   */
  function getSetTween(element, propertyValue) {
      if (propertyValue === undefined) {
          return "";
      }
  }
  registerNormalization(["Element", "tween", getSetTween]);

  // Automatically generated
  var VERSION = "2.0.5";

  // Project
  var Velocity$$1 = Velocity$1;
  /**
   * These parts of Velocity absolutely must be included, even if they're unused!
   */
  var VelocityStatic;
  (function (VelocityStatic) {
      /**
       * Actions cannot be replaced if they are internal (hasOwnProperty is false
       * but they still exist). Otherwise they can be replaced by users.
       *
       * All external method calls should be using actions rather than sub-calls
       * of Velocity itself.
       */
      VelocityStatic.Actions = Actions;
      /**
       * Our known easing functions.
       */
      VelocityStatic.Easings = Easings;
      /**
       * The currently registered sequences.
       */
      VelocityStatic.Sequences = SequencesObject;
      /**
       * Current internal state of Velocity.
       */
      VelocityStatic.State = State; // tslint:disable-line:no-shadowed-variable
      /**
       * Velocity option defaults, which can be overriden by the user.
       */
      VelocityStatic.defaults = defaults$1;
      /**
       * Used to patch any object to allow Velocity chaining. In order to chain an
       * object must either be treatable as an array - with a <code>.length</code>
       * property, and each member a Node, or a Node directly.
       *
       * By default Velocity will try to patch <code>window</code>,
       * <code>jQuery</code>, <code>Zepto</code>, and several classes that return
       * Nodes or lists of Nodes.
       */
      VelocityStatic.patch = patch;
      /**
       * Set to true, 1 or 2 (most verbose) to output debug info to console.
       */
      VelocityStatic.debug = false;
      /**
       * In mock mode, all animations are forced to complete immediately upon the
       * next rAF tick. If there are further animations queued then they will each
       * take one single frame in turn. Loops and repeats will be disabled while
       * <code>mock = true</code>.
       */
      VelocityStatic.mock = false;
      /**
       * Save our version number somewhere visible.
       */
      VelocityStatic.version = VERSION;
      /**
       * Added as a fallback for "import {Velocity} from 'velocity-animate';".
       */
      VelocityStatic.Velocity = Velocity$1; // tslint:disable-line:no-shadowed-variable
  })(VelocityStatic || (VelocityStatic = {}));
  /* IE detection. Gist: https://gist.github.com/julianshapiro/9098609 */
  var IE = function () {
      if (document.documentMode) {
          return document.documentMode;
      } else {
          for (var i = 7; i > 4; i--) {
              var div = document.createElement("div");
              div.innerHTML = "<!" + "--" + "[if IE " + i + "]><span></span><![endif]-->";
              if (div.getElementsByTagName("span").length) {
                  div = null;
                  return i;
              }
          }
      }
      return undefined;
  }();
  /******************
   Unsupported
   ******************/
  if (IE <= 8) {
      throw new Error("VelocityJS cannot run on Internet Explorer 8 or earlier");
  }
  /******************
   Frameworks
   ******************/
  if (window) {
      /*
       * Both jQuery and Zepto allow their $.fn object to be extended to allow
       * wrapped elements to be subjected to plugin calls. If either framework is
       * loaded, register a "velocity" extension pointing to Velocity's core
       * animate() method. Velocity also registers itself onto a global container
       * (window.jQuery || window.Zepto || window) so that certain features are
       * accessible beyond just a per-element scope. Accordingly, Velocity can
       * both act on wrapped DOM elements and stand alone for targeting raw DOM
       * elements.
       */
      var jQuery = window.jQuery,
          Zepto = window.Zepto;
      patch(window, true);
      patch(Element && Element.prototype);
      patch(NodeList && NodeList.prototype);
      patch(HTMLCollection && HTMLCollection.prototype);
      patch(jQuery, true);
      patch(jQuery && jQuery.fn);
      patch(Zepto, true);
      patch(Zepto && Zepto.fn);
  }
  // Make sure that the values within Velocity are read-only and upatchable.

  var _loop = function _loop(property) {
      if (VelocityStatic.hasOwnProperty(property)) {
          switch (typeof property === "undefined" ? "undefined" : _typeof(property)) {
              case "number":
              case "boolean":
                  defineProperty$1(Velocity$$1, property, {
                      get: function get$$1() {
                          return VelocityStatic[property];
                      },
                      set: function set$$1(value) {
                          VelocityStatic[property] = value;
                      }
                  }, true);
                  break;
              default:
                  defineProperty$1(Velocity$$1, property, VelocityStatic[property], true);
                  break;
          }
      }
  };

  for (var property in VelocityStatic) {
      _loop(property);
  }
  Object.freeze(Velocity$$1);

  // Project
  var rxPercents = /(\d*\.\d+|\d+\.?|from|to)/g;
  function expandSequence(animation, sequence) {
      var tweens = animation.tweens = Object.create(null),
          element = animation.element;
      for (var propertyName in sequence.tweens) {
          if (sequence.tweens.hasOwnProperty(propertyName)) {
              var fn = getNormalization(element, propertyName);
              if (!fn && propertyName !== "tween") {
                  if (Velocity$$1.debug) {
                      console.log("Skipping [" + propertyName + "] due to a lack of browser support.");
                  }
                  continue;
              }
              tweens[propertyName] = {
                  fn: fn,
                  sequence: sequence.tweens[propertyName]
              };
          }
      }
  }
  /**
   * Used to register a sequence. This should never be called by users
   * directly, instead it should be called via an action:<br/>
   * <code>Velocity("registerSequence", ""name", VelocitySequence);</code>
   */
  function registerSequence(args) {
      if (isPlainObject(args[0])) {
          for (var name in args[0]) {
              if (args[0].hasOwnProperty(name)) {
                  registerSequence([name, args[0][name]]);
              }
          }
      } else if (isString(args[0])) {
          var _name = args[0],
              sequence = args[1];
          if (!isString(_name)) {
              console.warn("VelocityJS: Trying to set 'registerSequence' name to an invalid value:", _name);
          } else if (!isPlainObject(sequence)) {
              console.warn("VelocityJS: Trying to set 'registerSequence' sequence to an invalid value:", _name, sequence);
          } else {
              if (SequencesObject[_name]) {
                  console.warn("VelocityJS: Replacing named sequence:", _name);
              }
              var percents = {},
                  steps = new Array(100),
                  properties = [],
                  sequenceList = SequencesObject[_name] = {},
                  duration = validateDuration(sequence.duration);
              sequenceList.tweens = {};
              if (isNumber(duration)) {
                  sequenceList.duration = duration;
              }
              for (var part in sequence) {
                  if (sequence.hasOwnProperty(part)) {
                      var keys = String(part).match(rxPercents);
                      if (keys) {
                          var _iteratorNormalCompletion = true;
                          var _didIteratorError = false;
                          var _iteratorError = undefined;

                          try {
                              for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                  var key = _step.value;

                                  var percent = key === "from" ? 0 : key === "to" ? 100 : parseFloat(key);
                                  if (percent < 0 || percent > 100) {
                                      console.warn("VelocityJS: Trying to use an invalid value as a percentage (0 <= n <= 100):", _name, percent);
                                  } else if (isNaN(percent)) {
                                      console.warn("VelocityJS: Trying to use an invalid number as a percentage:", _name, part, key);
                                  } else {
                                      if (!percents[String(percent)]) {
                                          percents[String(percent)] = [];
                                      }
                                      percents[String(percent)].push(part);
                                      for (var property in sequence[part]) {
                                          if (!properties.includes(property)) {
                                              properties.push(property);
                                          }
                                      }
                                  }
                              }
                          } catch (err) {
                              _didIteratorError = true;
                              _iteratorError = err;
                          } finally {
                              try {
                                  if (!_iteratorNormalCompletion && _iterator.return) {
                                      _iterator.return();
                                  }
                              } finally {
                                  if (_didIteratorError) {
                                      throw _iteratorError;
                                  }
                              }
                          }
                      }
                  }
              }
              var orderedPercents = Object.keys(percents).sort(function (a, b) {
                  var a1 = parseFloat(a),
                      b1 = parseFloat(b);
                  return a1 > b1 ? 1 : a1 < b1 ? -1 : 0;
              });
              orderedPercents.forEach(function (key) {
                  steps.push.apply(percents[key]);
              });
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                  for (var _iterator2 = properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                      var _property = _step2.value;

                      var parts = [],
                          propertyName = camelCase(_property);
                      var _iteratorNormalCompletion3 = true;
                      var _didIteratorError3 = false;
                      var _iteratorError3 = undefined;

                      try {
                          for (var _iterator3 = orderedPercents[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                              var _key = _step3.value;
                              var _iteratorNormalCompletion6 = true;
                              var _didIteratorError6 = false;
                              var _iteratorError6 = undefined;

                              try {
                                  for (var _iterator6 = percents[_key][Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                                      var _value = _step6.value;

                                      var stepProperties = sequence[_value];
                                      if (stepProperties[propertyName]) {
                                          parts.push(isString(stepProperties[propertyName]) ? stepProperties[propertyName] : stepProperties[propertyName][0]);
                                      }
                                  }
                              } catch (err) {
                                  _didIteratorError6 = true;
                                  _iteratorError6 = err;
                              } finally {
                                  try {
                                      if (!_iteratorNormalCompletion6 && _iterator6.return) {
                                          _iterator6.return();
                                      }
                                  } finally {
                                      if (_didIteratorError6) {
                                          throw _iteratorError6;
                                      }
                                  }
                              }
                          }
                      } catch (err) {
                          _didIteratorError3 = true;
                          _iteratorError3 = err;
                      } finally {
                          try {
                              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                                  _iterator3.return();
                              }
                          } finally {
                              if (_didIteratorError3) {
                                  throw _iteratorError3;
                              }
                          }
                      }

                      if (parts.length) {
                          var realSequence = findPattern(parts, propertyName);
                          var index = 0;
                          if (realSequence) {
                              var _iteratorNormalCompletion4 = true;
                              var _didIteratorError4 = false;
                              var _iteratorError4 = undefined;

                              try {
                                  for (var _iterator4 = orderedPercents[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                                      var _key2 = _step4.value;
                                      var _iteratorNormalCompletion5 = true;
                                      var _didIteratorError5 = false;
                                      var _iteratorError5 = undefined;

                                      try {
                                          for (var _iterator5 = percents[_key2][Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                                              var value = _step5.value;

                                              var originalProperty = sequence[value][propertyName];
                                              if (originalProperty) {
                                                  if (Array.isArray(originalProperty) && originalProperty.length > 1 && (isString(originalProperty[1]) || Array.isArray(originalProperty[1]))) {
                                                      realSequence[index].easing = validateEasing(originalProperty[1], sequenceList.duration || DEFAULT_DURATION);
                                                  }
                                                  realSequence[index++].percent = parseFloat(_key2) / 100;
                                              }
                                          }
                                      } catch (err) {
                                          _didIteratorError5 = true;
                                          _iteratorError5 = err;
                                      } finally {
                                          try {
                                              if (!_iteratorNormalCompletion5 && _iterator5.return) {
                                                  _iterator5.return();
                                              }
                                          } finally {
                                              if (_didIteratorError5) {
                                                  throw _iteratorError5;
                                              }
                                          }
                                      }
                                  }
                              } catch (err) {
                                  _didIteratorError4 = true;
                                  _iteratorError4 = err;
                              } finally {
                                  try {
                                      if (!_iteratorNormalCompletion4 && _iterator4.return) {
                                          _iterator4.return();
                                      }
                                  } finally {
                                      if (_didIteratorError4) {
                                          throw _iteratorError4;
                                      }
                                  }
                              }

                              sequenceList.tweens[propertyName] = realSequence;
                          }
                      }
                  }
              } catch (err) {
                  _didIteratorError2 = true;
                  _iteratorError2 = err;
              } finally {
                  try {
                      if (!_iteratorNormalCompletion2 && _iterator2.return) {
                          _iterator2.return();
                      }
                  } finally {
                      if (_didIteratorError2) {
                          throw _iteratorError2;
                      }
                  }
              }
          }
      }
  }
  registerAction(["registerSequence", registerSequence], true);

  // Project
  var globalPromise = void 0;
  try {
      globalPromise = Promise;
  } catch ( /**/_a) {/**/}
  var noPromiseOption = ", if that is deliberate then pass `promiseRejectEmpty:false` as an option";
  /**
   * Patch a VelocityResult with a Promise.
   */
  function patchPromise(promiseObject, result) {
      defineProperty$1(result, "promise", promiseObject);
      defineProperty$1(result, "then", promiseObject.then.bind(promiseObject));
      defineProperty$1(result, "catch", promiseObject.catch.bind(promiseObject));
      if (promiseObject.finally) {
          // Semi-standard
          defineProperty$1(result, "finally", promiseObject.finally.bind(promiseObject));
      }
  }
  /* tslint:enable:max-line-length */
  function Velocity$1() {
      for (var _len = arguments.length, argsList = Array(_len), _key = 0; _key < _len; _key++) {
          argsList[_key] = arguments[_key];
      }

      var
      /**
       * A shortcut to the default options.
       */
      defaults$$1 = defaults$1,

      /**
       * Shortcut to arguments for file size.
       */
      args = arguments,

      /**
       * Cache of the first argument - this is used often enough to be saved.
       */
      args0 = args[0],

      /**
       * To allow for expressive CoffeeScript code, Velocity supports an
       * alternative syntax in which "elements" (or "e"), "properties" (or
       * "p"), and "options" (or "o") objects are defined on a container
       * object that's passed in as Velocity's sole argument.
       *
       * Note: Some browsers automatically populate arguments with a
       * "properties" object. We detect it by checking for its default
       * "names" property.
       */
      // TODO: Confirm which browsers - if <=IE8 the we can drop completely
      syntacticSugar = isPlainObject(args0) && (args0.p || isPlainObject(args0.properties) && !args0.properties.names || isString(args0.properties));
      var
      /**
       *  When Velocity is called via the utility function (Velocity()),
       * elements are explicitly passed in as the first parameter. Thus,
       * argument positioning varies.
       */
      argumentIndex = 0,

      /**
       * The list of elements, extended with Promise and Velocity.
       */
      elements = void 0,

      /**
       * The properties being animated. This can be a string, in which case it
       * is either a function for these elements, or it is a "named" animation
       * sequence to use instead. Named sequences start with either "callout."
       * or "transition.". When used as a callout the values will be reset
       * after finishing. When used as a transtition then there is no special
       * handling after finishing.
       */
      propertiesMap = void 0,

      /**
       * Options supplied, this will be mapped and validated into
       * <code>options</code>.
       */
      optionsMap = void 0,

      /**
       * If called via a chain then this contains the <b>last</b> calls
       * animations. If this does not have a value then any access to the
       * element's animations needs to be to the currently-running ones.
       */
      animations = void 0,

      /**
       * The promise that is returned.
       */
      promise = void 0,

      // Used when the animation is finished
      resolver = void 0,

      // Used when there was an issue with one or more of the Velocity arguments
      rejecter = void 0;
      //console.log(`Velocity`, _arguments)
      // First get the elements, and the animations connected to the last call if
      // this is chained.
      // TODO: Clean this up a bit
      // TODO: Throw error if the chain is called with elements as the first argument. isVelocityResult(this) && ( (isNode(arg0) || isWrapped(arg0)) && arg0 == this)
      if (isNode(this)) {
          // This is from a chain such as document.getElementById("").velocity(...)
          elements = [this];
      } else if (isWrapped(this)) {
          // This might be a chain from something else, but if chained from a
          // previous Velocity() call then grab the animations it's related to.
          elements = cloneArray(this);
          if (isVelocityResult(this)) {
              animations = this.velocity.animations;
          }
      } else if (syntacticSugar) {
          elements = cloneArray(args0.elements || args0.e);
          argumentIndex++;
      } else if (isNode(args0)) {
          elements = cloneArray([args0]);
          argumentIndex++;
      } else if (isWrapped(args0)) {
          elements = cloneArray(args0);
          argumentIndex++;
      }
      // Allow elements to be chained.
      if (elements) {
          defineProperty$1(elements, "velocity", Velocity$1.bind(elements));
          if (animations) {
              defineProperty$1(elements.velocity, "animations", animations);
          }
      }
      // Next get the propertiesMap and options.
      if (syntacticSugar) {
          propertiesMap = getValue(args0.properties, args0.p);
      } else {
          // TODO: Should be possible to call Velocity("pauseAll") - currently not possible
          propertiesMap = args[argumentIndex++];
      }
      // Get any options map passed in as arguments first, expand any direct
      // options if possible.
      var isReverse = propertiesMap === "reverse",
          isAction = !isReverse && isString(propertiesMap),
          maybeSequence = isAction && SequencesObject[propertiesMap],
          opts = syntacticSugar ? getValue(args0.options, args0.o) : args[argumentIndex];
      if (isPlainObject(opts)) {
          optionsMap = opts;
      }
      // Create the promise if supported and wanted.
      if (globalPromise && getValue(optionsMap && optionsMap.promise, defaults$$1.promise)) {
          promise = new globalPromise(function (resolve, reject) {
              rejecter = reject;
              // IMPORTANT:
              // If a resolver tries to run on a Promise then it will wait until
              // that Promise resolves - but in this case we're running on our own
              // Promise, so need to make sure it's not seen as one. Removing
              // these values for the duration of the resolve.
              // Due to being an async call, they should be back to "normal"
              // before the <code>.then()</code> function gets called.
              resolver = function resolver(result) {
                  if (isVelocityResult(result) && result.promise) {
                      delete result.then;
                      delete result.catch;
                      delete result.finally;
                      resolve(result);
                      patchPromise(result.promise, result);
                  } else {
                      resolve(result);
                  }
              };
          });
          if (elements) {
              patchPromise(promise, elements);
          }
      }
      if (promise) {
          var optionPromiseRejectEmpty = optionsMap && optionsMap.promiseRejectEmpty,
              promiseRejectEmpty = getValue(optionPromiseRejectEmpty, defaults$$1.promiseRejectEmpty);
          if (!elements && !isAction) {
              if (promiseRejectEmpty) {
                  rejecter("Velocity: No elements supplied" + (isBoolean(optionPromiseRejectEmpty) ? "" : noPromiseOption) + ". Aborting.");
              } else {
                  resolver();
              }
          } else if (!propertiesMap) {
              if (promiseRejectEmpty) {
                  rejecter("Velocity: No properties supplied" + (isBoolean(optionPromiseRejectEmpty) ? "" : noPromiseOption) + ". Aborting.");
              } else {
                  resolver();
              }
          }
      }
      if (!elements && !isAction || !propertiesMap) {
          return promise;
      }
      // NOTE: Can't use isAction here due to type inference - there are callbacks
      // between so the type isn't considered safe.
      if (isAction) {
          var actionArgs = [],
              promiseHandler = promise && {
              _promise: promise,
              _resolver: resolver,
              _rejecter: rejecter
          };
          while (argumentIndex < args.length) {
              actionArgs.push(args[argumentIndex++]);
          }
          // Velocity's behavior is categorized into "actions". If a string is
          // passed in instead of a propertiesMap then that will call a function
          // to do something special to the animation linked.
          // There is one special case - "reverse" - which is handled differently,
          // by being stored on the animation and then expanded when the animation
          // starts.
          var action = propertiesMap.replace(/\..*$/, ""),
              callback = Actions[action];
          if (callback) {
              var result = callback(actionArgs, elements, promiseHandler, propertiesMap);
              if (result !== undefined) {
                  return result;
              }
              return elements || promise;
          } else if (!maybeSequence) {
              console.error("VelocityJS: First argument (" + propertiesMap + ") was not a property map, a known action, or a registered redirect. Aborting.");
              return;
          }
      }
      var hasValidDuration = void 0;
      if (isPlainObject(propertiesMap) || isReverse || maybeSequence) {
          /**
           * The options for this set of animations.
           */
          var options = {};
          var isSync = defaults$$1.sync;
          // Private options first - set as non-enumerable, and starting with an
          // underscore so we can filter them out.
          if (promise) {
              defineProperty$1(options, "_promise", promise);
              defineProperty$1(options, "_rejecter", rejecter);
              defineProperty$1(options, "_resolver", resolver);
          }
          defineProperty$1(options, "_ready", 0);
          defineProperty$1(options, "_started", 0);
          defineProperty$1(options, "_completed", 0);
          defineProperty$1(options, "_total", 0);
          // Now check the optionsMap
          if (isPlainObject(optionsMap)) {
              var validDuration = validateDuration(optionsMap.duration);
              hasValidDuration = validDuration !== undefined;
              options.duration = getValue(validDuration, defaults$$1.duration);
              options.delay = getValue(validateDelay(optionsMap.delay), defaults$$1.delay);
              // Need the extra fallback here in case it supplies an invalid
              // easing that we need to overrride with the default.
              options.easing = validateEasing(getValue(optionsMap.easing, defaults$$1.easing), options.duration) || validateEasing(defaults$$1.easing, options.duration);
              options.loop = getValue(validateLoop(optionsMap.loop), defaults$$1.loop);
              options.repeat = options.repeatAgain = getValue(validateRepeat(optionsMap.repeat), defaults$$1.repeat);
              if (optionsMap.speed != null) {
                  options.speed = getValue(validateSpeed(optionsMap.speed), 1);
              }
              if (isBoolean(optionsMap.promise)) {
                  options.promise = optionsMap.promise;
              }
              options.queue = getValue(validateQueue(optionsMap.queue), defaults$$1.queue);
              if (optionsMap.mobileHA && !State.isGingerbread) {
                  /* When set to true, and if this is a mobile device, mobileHA automatically enables hardware acceleration (via a null transform hack)
                   on animating elements. HA is removed from the element at the completion of its animation. */
                  /* Note: Android Gingerbread doesn't support HA. If a null transform hack (mobileHA) is in fact set, it will prevent other tranform subproperties from taking effect. */
                  /* Note: You can read more about the use of mobileHA in Velocity's documentation: velocity-animate/#mobileHA. */
                  options.mobileHA = true;
              }
              if (optionsMap.drag === true) {
                  options.drag = true;
              }
              if (isNumber(optionsMap.stagger) || isFunction(optionsMap.stagger)) {
                  options.stagger = optionsMap.stagger;
              }
              if (!isReverse) {
                  if (optionsMap["display"] != null) {
                      propertiesMap.display = optionsMap["display"];
                      console.error("Deprecated \"options.display\" used, this is now a property:", optionsMap["display"]);
                  }
                  if (optionsMap["visibility"] != null) {
                      propertiesMap.visibility = optionsMap["visibility"];
                      console.error("Deprecated \"options.visibility\" used, this is now a property:", optionsMap["visibility"]);
                  }
              }
              // TODO: Allow functional options for different options per element
              var optionsBegin = validateBegin(optionsMap.begin),
                  optionsComplete = validateComplete(optionsMap.complete),
                  optionsProgress = validateProgress(optionsMap.progress),
                  optionsSync = validateSync(optionsMap.sync);
              if (optionsBegin != null) {
                  options.begin = optionsBegin;
              }
              if (optionsComplete != null) {
                  options.complete = optionsComplete;
              }
              if (optionsProgress != null) {
                  options.progress = optionsProgress;
              }
              if (optionsSync != null) {
                  isSync = optionsSync;
              }
          } else if (!syntacticSugar) {
              // Expand any direct options if possible.
              var offset = 0;
              options.duration = validateDuration(args[argumentIndex], true);
              if (options.duration === undefined) {
                  options.duration = defaults$$1.duration;
              } else {
                  hasValidDuration = true;
                  offset++;
              }
              if (!isFunction(args[argumentIndex + offset])) {
                  // Despite coming before Complete, we can't pass a fn easing
                  var easing = validateEasing(args[argumentIndex + offset], getValue(options && validateDuration(options.duration), defaults$$1.duration), true);
                  if (easing !== undefined) {
                      offset++;
                      options.easing = easing;
                  }
              }
              var complete = validateComplete(args[argumentIndex + offset], true);
              if (complete !== undefined) {
                  options.complete = complete;
              }
              options.delay = defaults$$1.delay;
              options.loop = defaults$$1.loop;
              options.repeat = options.repeatAgain = defaults$$1.repeat;
          }
          if (isReverse && options.queue === false) {
              throw new Error("VelocityJS: Cannot reverse a queue:false animation.");
          }
          if (!hasValidDuration && maybeSequence && maybeSequence.duration) {
              options.duration = maybeSequence.duration;
          }
          // When a set of elements is targeted by a Velocity call, the set is
          // broken up and each element has the current Velocity call individually
          // queued onto it. In this way, each element's existing queue is
          // respected; some elements may already be animating and accordingly
          // should not have this current Velocity call triggered immediately
          // unless the sync:true option is used.
          var rootAnimation = {
              options: options,
              elements: elements,
              _prev: undefined,
              _next: undefined,
              _flags: isSync ? 32 /* SYNC */ : 0,
              percentComplete: 0,
              ellapsedTime: 0,
              timeStart: 0
          };
          animations = [];
          for (var index = 0; index < elements.length; index++) {
              var element = elements[index];
              var flags = 0;
              if (isNode(element)) {
                  // TODO: This needs to check for valid animation targets, not just Elements
                  if (isReverse) {
                      var lastAnimation = Data(element).lastAnimationList[options.queue];
                      propertiesMap = lastAnimation && lastAnimation.tweens;
                      if (!propertiesMap) {
                          console.error("VelocityJS: Attempting to reverse an animation on an element with no previous animation:", element);
                          continue;
                      }
                      flags |= 64 /* REVERSE */ & ~(lastAnimation._flags & 64 /* REVERSE */); // tslint:disable-line:no-bitwise
                  }
                  var animation = Object.assign({}, rootAnimation, { element: element, _flags: rootAnimation._flags | flags });
                  options._total++;
                  animations.push(animation);
                  if (options.stagger) {
                      if (isFunction(options.stagger)) {
                          var num = optionCallback(options.stagger, element, index, elements.length, elements, "stagger");
                          if (isNumber(num)) {
                              animation.delay = options.delay + num;
                          }
                      } else {
                          animation.delay = options.delay + options.stagger * index;
                      }
                  }
                  if (options.drag) {
                      animation.duration = options.duration - options.duration * Math.max(1 - (index + 1) / elements.length, 0.75);
                  }
                  if (maybeSequence) {
                      expandSequence(animation, maybeSequence);
                  } else if (isReverse) {
                      // In this case we're using the previous animation, so
                      // it will be expanded correctly when that one runs.
                      animation.tweens = propertiesMap;
                  } else {
                      animation.tweens = Object.create(null);
                      expandProperties(animation, propertiesMap);
                  }
                  queue$1(element, animation, options.queue);
              }
          }
          if (State.isTicking === false) {
              // If the animation tick isn't running, start it. (Velocity shuts it
              // off when there are no active calls to process.)
              tick(false);
          }
          if (animations) {
              defineProperty$1(elements.velocity, "animations", animations);
          }
      }
      /***************
       Chaining
       ***************/
      /* Return the elements back to the call chain, with wrapped elements taking precedence in case Velocity was called via the $.fn. extension. */
      return elements || promise;
  }
  /**
   * Call an option callback in a try/catch block and report an error if needed.
   */
  function optionCallback(fn, element, index, length, elements, option) {
      try {
          return fn.call(element, index, length, elements, option);
      } catch (e) {
          console.error("VelocityJS: Exception when calling '" + option + "' callback:", e);
      }
  }

  // Project
  /**
   * Used to patch any object to allow Velocity chaining. In order to chain an
   * object must either be treatable as an array - with a <code>.length</code>
   * property, and each member a Node, or a Node directly.
   *
   * By default Velocity will try to patch <code>window</code>,
   * <code>jQuery</code>, <code>Zepto</code>, and several classes that return
   * Nodes or lists of Nodes.
   */
  function patch(proto, global) {
      try {
          defineProperty$1(proto, (global ? "V" : "v") + "elocity", Velocity$1);
      } catch (e) {
          console.warn("VelocityJS: Error when trying to add prototype.", e);
      }
  }

  // Project
  var Velocity$2 = Velocity$1;
  /**
   * These parts of Velocity absolutely must be included, even if they're unused!
   */
  var VelocityStatic$1;
  (function (VelocityStatic) {
      /**
       * Actions cannot be replaced if they are internal (hasOwnProperty is false
       * but they still exist). Otherwise they can be replaced by users.
       *
       * All external method calls should be using actions rather than sub-calls
       * of Velocity itself.
       */
      VelocityStatic.Actions = Actions;
      /**
       * Our known easing functions.
       */
      VelocityStatic.Easings = Easings;
      /**
       * The currently registered sequences.
       */
      VelocityStatic.Sequences = SequencesObject;
      /**
       * Current internal state of Velocity.
       */
      VelocityStatic.State = State; // tslint:disable-line:no-shadowed-variable
      /**
       * Velocity option defaults, which can be overriden by the user.
       */
      VelocityStatic.defaults = defaults$1;
      /**
       * Used to patch any object to allow Velocity chaining. In order to chain an
       * object must either be treatable as an array - with a <code>.length</code>
       * property, and each member a Node, or a Node directly.
       *
       * By default Velocity will try to patch <code>window</code>,
       * <code>jQuery</code>, <code>Zepto</code>, and several classes that return
       * Nodes or lists of Nodes.
       */
      VelocityStatic.patch = patch;
      /**
       * Set to true, 1 or 2 (most verbose) to output debug info to console.
       */
      VelocityStatic.debug = false;
      /**
       * In mock mode, all animations are forced to complete immediately upon the
       * next rAF tick. If there are further animations queued then they will each
       * take one single frame in turn. Loops and repeats will be disabled while
       * <code>mock = true</code>.
       */
      VelocityStatic.mock = false;
      /**
       * Save our version number somewhere visible.
       */
      VelocityStatic.version = VERSION;
      /**
       * Added as a fallback for "import {Velocity} from 'velocity-animate';".
       */
      VelocityStatic.Velocity = Velocity$1; // tslint:disable-line:no-shadowed-variable
  })(VelocityStatic$1 || (VelocityStatic$1 = {}));
  /* IE detection. Gist: https://gist.github.com/julianshapiro/9098609 */
  var IE$1 = function () {
      if (document.documentMode) {
          return document.documentMode;
      } else {
          for (var i = 7; i > 4; i--) {
              var div = document.createElement("div");
              div.innerHTML = "<!" + "--" + "[if IE " + i + "]><span></span><![endif]-->";
              if (div.getElementsByTagName("span").length) {
                  div = null;
                  return i;
              }
          }
      }
      return undefined;
  }();
  /******************
   Unsupported
   ******************/
  if (IE$1 <= 8) {
      throw new Error("VelocityJS cannot run on Internet Explorer 8 or earlier");
  }
  /******************
   Frameworks
   ******************/
  if (window) {
      /*
       * Both jQuery and Zepto allow their $.fn object to be extended to allow
       * wrapped elements to be subjected to plugin calls. If either framework is
       * loaded, register a "velocity" extension pointing to Velocity's core
       * animate() method. Velocity also registers itself onto a global container
       * (window.jQuery || window.Zepto || window) so that certain features are
       * accessible beyond just a per-element scope. Accordingly, Velocity can
       * both act on wrapped DOM elements and stand alone for targeting raw DOM
       * elements.
       */
      var jQuery$1 = window.jQuery,
          Zepto$1 = window.Zepto;
      patch(window, true);
      patch(Element && Element.prototype);
      patch(NodeList && NodeList.prototype);
      patch(HTMLCollection && HTMLCollection.prototype);
      patch(jQuery$1, true);
      patch(jQuery$1 && jQuery$1.fn);
      patch(Zepto$1, true);
      patch(Zepto$1 && Zepto$1.fn);
  }
  // Make sure that the values within Velocity are read-only and upatchable.

  var _loop$1 = function _loop(property) {
      if (VelocityStatic$1.hasOwnProperty(property)) {
          switch (typeof property === "undefined" ? "undefined" : _typeof(property)) {
              case "number":
              case "boolean":
                  defineProperty$1(Velocity$2, property, {
                      get: function get$$1() {
                          return VelocityStatic$1[property];
                      },
                      set: function set$$1(value) {
                          VelocityStatic$1[property] = value;
                      }
                  }, true);
                  break;
              default:
                  defineProperty$1(Velocity$2, property, VelocityStatic$1[property], true);
                  break;
          }
      }
  };

  for (var property$1 in VelocityStatic$1) {
      _loop$1(property$1);
  }
  Object.freeze(Velocity$2);

  return Velocity$2;

})));

// THIS FILE IS GENERATED - DO NOT EDIT!
/*!mobile-detect v1.4.4 2019-09-21*/
/*global module:false, define:false*/
/*jshint latedef:false*/
/*!@license Copyright 2013, Heinrich Goebl, License: MIT, see https://github.com/hgoebl/mobile-detect.js*/
(function (define, undefined) {
define(function () {
    'use strict';

    var impl = {};

    impl.mobileDetectRules = {
    "phones": {
        "iPhone": "\\biPhone\\b|\\biPod\\b",
        "BlackBerry": "BlackBerry|\\bBB10\\b|rim[0-9]+|\\b(BBA100|BBB100|BBD100|BBE100|BBF100|STH100)\\b-[0-9]+",
        "HTC": "HTC|HTC.*(Sensation|Evo|Vision|Explorer|6800|8100|8900|A7272|S510e|C110e|Legend|Desire|T8282)|APX515CKT|Qtek9090|APA9292KT|HD_mini|Sensation.*Z710e|PG86100|Z715e|Desire.*(A8181|HD)|ADR6200|ADR6400L|ADR6425|001HT|Inspire 4G|Android.*\\bEVO\\b|T-Mobile G1|Z520m|Android [0-9.]+; Pixel",
        "Nexus": "Nexus One|Nexus S|Galaxy.*Nexus|Android.*Nexus.*Mobile|Nexus 4|Nexus 5|Nexus 6",
        "Dell": "Dell[;]? (Streak|Aero|Venue|Venue Pro|Flash|Smoke|Mini 3iX)|XCD28|XCD35|\\b001DL\\b|\\b101DL\\b|\\bGS01\\b",
        "Motorola": "Motorola|DROIDX|DROID BIONIC|\\bDroid\\b.*Build|Android.*Xoom|HRI39|MOT-|A1260|A1680|A555|A853|A855|A953|A955|A956|Motorola.*ELECTRIFY|Motorola.*i1|i867|i940|MB200|MB300|MB501|MB502|MB508|MB511|MB520|MB525|MB526|MB611|MB612|MB632|MB810|MB855|MB860|MB861|MB865|MB870|ME501|ME502|ME511|ME525|ME600|ME632|ME722|ME811|ME860|ME863|ME865|MT620|MT710|MT716|MT720|MT810|MT870|MT917|Motorola.*TITANIUM|WX435|WX445|XT300|XT301|XT311|XT316|XT317|XT319|XT320|XT390|XT502|XT530|XT531|XT532|XT535|XT603|XT610|XT611|XT615|XT681|XT701|XT702|XT711|XT720|XT800|XT806|XT860|XT862|XT875|XT882|XT883|XT894|XT901|XT907|XT909|XT910|XT912|XT928|XT926|XT915|XT919|XT925|XT1021|\\bMoto E\\b|XT1068|XT1092|XT1052",
        "Samsung": "\\bSamsung\\b|SM-G950F|SM-G955F|SM-G9250|GT-19300|SGH-I337|BGT-S5230|GT-B2100|GT-B2700|GT-B2710|GT-B3210|GT-B3310|GT-B3410|GT-B3730|GT-B3740|GT-B5510|GT-B5512|GT-B5722|GT-B6520|GT-B7300|GT-B7320|GT-B7330|GT-B7350|GT-B7510|GT-B7722|GT-B7800|GT-C3010|GT-C3011|GT-C3060|GT-C3200|GT-C3212|GT-C3212I|GT-C3262|GT-C3222|GT-C3300|GT-C3300K|GT-C3303|GT-C3303K|GT-C3310|GT-C3322|GT-C3330|GT-C3350|GT-C3500|GT-C3510|GT-C3530|GT-C3630|GT-C3780|GT-C5010|GT-C5212|GT-C6620|GT-C6625|GT-C6712|GT-E1050|GT-E1070|GT-E1075|GT-E1080|GT-E1081|GT-E1085|GT-E1087|GT-E1100|GT-E1107|GT-E1110|GT-E1120|GT-E1125|GT-E1130|GT-E1160|GT-E1170|GT-E1175|GT-E1180|GT-E1182|GT-E1200|GT-E1210|GT-E1225|GT-E1230|GT-E1390|GT-E2100|GT-E2120|GT-E2121|GT-E2152|GT-E2220|GT-E2222|GT-E2230|GT-E2232|GT-E2250|GT-E2370|GT-E2550|GT-E2652|GT-E3210|GT-E3213|GT-I5500|GT-I5503|GT-I5700|GT-I5800|GT-I5801|GT-I6410|GT-I6420|GT-I7110|GT-I7410|GT-I7500|GT-I8000|GT-I8150|GT-I8160|GT-I8190|GT-I8320|GT-I8330|GT-I8350|GT-I8530|GT-I8700|GT-I8703|GT-I8910|GT-I9000|GT-I9001|GT-I9003|GT-I9010|GT-I9020|GT-I9023|GT-I9070|GT-I9082|GT-I9100|GT-I9103|GT-I9220|GT-I9250|GT-I9300|GT-I9305|GT-I9500|GT-I9505|GT-M3510|GT-M5650|GT-M7500|GT-M7600|GT-M7603|GT-M8800|GT-M8910|GT-N7000|GT-S3110|GT-S3310|GT-S3350|GT-S3353|GT-S3370|GT-S3650|GT-S3653|GT-S3770|GT-S3850|GT-S5210|GT-S5220|GT-S5229|GT-S5230|GT-S5233|GT-S5250|GT-S5253|GT-S5260|GT-S5263|GT-S5270|GT-S5300|GT-S5330|GT-S5350|GT-S5360|GT-S5363|GT-S5369|GT-S5380|GT-S5380D|GT-S5560|GT-S5570|GT-S5600|GT-S5603|GT-S5610|GT-S5620|GT-S5660|GT-S5670|GT-S5690|GT-S5750|GT-S5780|GT-S5830|GT-S5839|GT-S6102|GT-S6500|GT-S7070|GT-S7200|GT-S7220|GT-S7230|GT-S7233|GT-S7250|GT-S7500|GT-S7530|GT-S7550|GT-S7562|GT-S7710|GT-S8000|GT-S8003|GT-S8500|GT-S8530|GT-S8600|SCH-A310|SCH-A530|SCH-A570|SCH-A610|SCH-A630|SCH-A650|SCH-A790|SCH-A795|SCH-A850|SCH-A870|SCH-A890|SCH-A930|SCH-A950|SCH-A970|SCH-A990|SCH-I100|SCH-I110|SCH-I400|SCH-I405|SCH-I500|SCH-I510|SCH-I515|SCH-I600|SCH-I730|SCH-I760|SCH-I770|SCH-I830|SCH-I910|SCH-I920|SCH-I959|SCH-LC11|SCH-N150|SCH-N300|SCH-R100|SCH-R300|SCH-R351|SCH-R400|SCH-R410|SCH-T300|SCH-U310|SCH-U320|SCH-U350|SCH-U360|SCH-U365|SCH-U370|SCH-U380|SCH-U410|SCH-U430|SCH-U450|SCH-U460|SCH-U470|SCH-U490|SCH-U540|SCH-U550|SCH-U620|SCH-U640|SCH-U650|SCH-U660|SCH-U700|SCH-U740|SCH-U750|SCH-U810|SCH-U820|SCH-U900|SCH-U940|SCH-U960|SCS-26UC|SGH-A107|SGH-A117|SGH-A127|SGH-A137|SGH-A157|SGH-A167|SGH-A177|SGH-A187|SGH-A197|SGH-A227|SGH-A237|SGH-A257|SGH-A437|SGH-A517|SGH-A597|SGH-A637|SGH-A657|SGH-A667|SGH-A687|SGH-A697|SGH-A707|SGH-A717|SGH-A727|SGH-A737|SGH-A747|SGH-A767|SGH-A777|SGH-A797|SGH-A817|SGH-A827|SGH-A837|SGH-A847|SGH-A867|SGH-A877|SGH-A887|SGH-A897|SGH-A927|SGH-B100|SGH-B130|SGH-B200|SGH-B220|SGH-C100|SGH-C110|SGH-C120|SGH-C130|SGH-C140|SGH-C160|SGH-C170|SGH-C180|SGH-C200|SGH-C207|SGH-C210|SGH-C225|SGH-C230|SGH-C417|SGH-C450|SGH-D307|SGH-D347|SGH-D357|SGH-D407|SGH-D415|SGH-D780|SGH-D807|SGH-D980|SGH-E105|SGH-E200|SGH-E315|SGH-E316|SGH-E317|SGH-E335|SGH-E590|SGH-E635|SGH-E715|SGH-E890|SGH-F300|SGH-F480|SGH-I200|SGH-I300|SGH-I320|SGH-I550|SGH-I577|SGH-I600|SGH-I607|SGH-I617|SGH-I627|SGH-I637|SGH-I677|SGH-I700|SGH-I717|SGH-I727|SGH-i747M|SGH-I777|SGH-I780|SGH-I827|SGH-I847|SGH-I857|SGH-I896|SGH-I897|SGH-I900|SGH-I907|SGH-I917|SGH-I927|SGH-I937|SGH-I997|SGH-J150|SGH-J200|SGH-L170|SGH-L700|SGH-M110|SGH-M150|SGH-M200|SGH-N105|SGH-N500|SGH-N600|SGH-N620|SGH-N625|SGH-N700|SGH-N710|SGH-P107|SGH-P207|SGH-P300|SGH-P310|SGH-P520|SGH-P735|SGH-P777|SGH-Q105|SGH-R210|SGH-R220|SGH-R225|SGH-S105|SGH-S307|SGH-T109|SGH-T119|SGH-T139|SGH-T209|SGH-T219|SGH-T229|SGH-T239|SGH-T249|SGH-T259|SGH-T309|SGH-T319|SGH-T329|SGH-T339|SGH-T349|SGH-T359|SGH-T369|SGH-T379|SGH-T409|SGH-T429|SGH-T439|SGH-T459|SGH-T469|SGH-T479|SGH-T499|SGH-T509|SGH-T519|SGH-T539|SGH-T559|SGH-T589|SGH-T609|SGH-T619|SGH-T629|SGH-T639|SGH-T659|SGH-T669|SGH-T679|SGH-T709|SGH-T719|SGH-T729|SGH-T739|SGH-T746|SGH-T749|SGH-T759|SGH-T769|SGH-T809|SGH-T819|SGH-T839|SGH-T919|SGH-T929|SGH-T939|SGH-T959|SGH-T989|SGH-U100|SGH-U200|SGH-U800|SGH-V205|SGH-V206|SGH-X100|SGH-X105|SGH-X120|SGH-X140|SGH-X426|SGH-X427|SGH-X475|SGH-X495|SGH-X497|SGH-X507|SGH-X600|SGH-X610|SGH-X620|SGH-X630|SGH-X700|SGH-X820|SGH-X890|SGH-Z130|SGH-Z150|SGH-Z170|SGH-ZX10|SGH-ZX20|SHW-M110|SPH-A120|SPH-A400|SPH-A420|SPH-A460|SPH-A500|SPH-A560|SPH-A600|SPH-A620|SPH-A660|SPH-A700|SPH-A740|SPH-A760|SPH-A790|SPH-A800|SPH-A820|SPH-A840|SPH-A880|SPH-A900|SPH-A940|SPH-A960|SPH-D600|SPH-D700|SPH-D710|SPH-D720|SPH-I300|SPH-I325|SPH-I330|SPH-I350|SPH-I500|SPH-I600|SPH-I700|SPH-L700|SPH-M100|SPH-M220|SPH-M240|SPH-M300|SPH-M305|SPH-M320|SPH-M330|SPH-M350|SPH-M360|SPH-M370|SPH-M380|SPH-M510|SPH-M540|SPH-M550|SPH-M560|SPH-M570|SPH-M580|SPH-M610|SPH-M620|SPH-M630|SPH-M800|SPH-M810|SPH-M850|SPH-M900|SPH-M910|SPH-M920|SPH-M930|SPH-N100|SPH-N200|SPH-N240|SPH-N300|SPH-N400|SPH-Z400|SWC-E100|SCH-i909|GT-N7100|GT-N7105|SCH-I535|SM-N900A|SGH-I317|SGH-T999L|GT-S5360B|GT-I8262|GT-S6802|GT-S6312|GT-S6310|GT-S5312|GT-S5310|GT-I9105|GT-I8510|GT-S6790N|SM-G7105|SM-N9005|GT-S5301|GT-I9295|GT-I9195|SM-C101|GT-S7392|GT-S7560|GT-B7610|GT-I5510|GT-S7582|GT-S7530E|GT-I8750|SM-G9006V|SM-G9008V|SM-G9009D|SM-G900A|SM-G900D|SM-G900F|SM-G900H|SM-G900I|SM-G900J|SM-G900K|SM-G900L|SM-G900M|SM-G900P|SM-G900R4|SM-G900S|SM-G900T|SM-G900V|SM-G900W8|SHV-E160K|SCH-P709|SCH-P729|SM-T2558|GT-I9205|SM-G9350|SM-J120F|SM-G920F|SM-G920V|SM-G930F|SM-N910C|SM-A310F|GT-I9190|SM-J500FN|SM-G903F|SM-J330F",
        "LG": "\\bLG\\b;|LG[- ]?(C800|C900|E400|E610|E900|E-900|F160|F180K|F180L|F180S|730|855|L160|LS740|LS840|LS970|LU6200|MS690|MS695|MS770|MS840|MS870|MS910|P500|P700|P705|VM696|AS680|AS695|AX840|C729|E970|GS505|272|C395|E739BK|E960|L55C|L75C|LS696|LS860|P769BK|P350|P500|P509|P870|UN272|US730|VS840|VS950|LN272|LN510|LS670|LS855|LW690|MN270|MN510|P509|P769|P930|UN200|UN270|UN510|UN610|US670|US740|US760|UX265|UX840|VN271|VN530|VS660|VS700|VS740|VS750|VS910|VS920|VS930|VX9200|VX11000|AX840A|LW770|P506|P925|P999|E612|D955|D802|MS323|M257)|LM-G710",
        "Sony": "SonyST|SonyLT|SonyEricsson|SonyEricssonLT15iv|LT18i|E10i|LT28h|LT26w|SonyEricssonMT27i|C5303|C6902|C6903|C6906|C6943|D2533",
        "Asus": "Asus.*Galaxy|PadFone.*Mobile",
        "NokiaLumia": "Lumia [0-9]{3,4}",
        "Micromax": "Micromax.*\\b(A210|A92|A88|A72|A111|A110Q|A115|A116|A110|A90S|A26|A51|A35|A54|A25|A27|A89|A68|A65|A57|A90)\\b",
        "Palm": "PalmSource|Palm",
        "Vertu": "Vertu|Vertu.*Ltd|Vertu.*Ascent|Vertu.*Ayxta|Vertu.*Constellation(F|Quest)?|Vertu.*Monika|Vertu.*Signature",
        "Pantech": "PANTECH|IM-A850S|IM-A840S|IM-A830L|IM-A830K|IM-A830S|IM-A820L|IM-A810K|IM-A810S|IM-A800S|IM-T100K|IM-A725L|IM-A780L|IM-A775C|IM-A770K|IM-A760S|IM-A750K|IM-A740S|IM-A730S|IM-A720L|IM-A710K|IM-A690L|IM-A690S|IM-A650S|IM-A630K|IM-A600S|VEGA PTL21|PT003|P8010|ADR910L|P6030|P6020|P9070|P4100|P9060|P5000|CDM8992|TXT8045|ADR8995|IS11PT|P2030|P6010|P8000|PT002|IS06|CDM8999|P9050|PT001|TXT8040|P2020|P9020|P2000|P7040|P7000|C790",
        "Fly": "IQ230|IQ444|IQ450|IQ440|IQ442|IQ441|IQ245|IQ256|IQ236|IQ255|IQ235|IQ245|IQ275|IQ240|IQ285|IQ280|IQ270|IQ260|IQ250",
        "Wiko": "KITE 4G|HIGHWAY|GETAWAY|STAIRWAY|DARKSIDE|DARKFULL|DARKNIGHT|DARKMOON|SLIDE|WAX 4G|RAINBOW|BLOOM|SUNSET|GOA(?!nna)|LENNY|BARRY|IGGY|OZZY|CINK FIVE|CINK PEAX|CINK PEAX 2|CINK SLIM|CINK SLIM 2|CINK +|CINK KING|CINK PEAX|CINK SLIM|SUBLIM",
        "iMobile": "i-mobile (IQ|i-STYLE|idea|ZAA|Hitz)",
        "SimValley": "\\b(SP-80|XT-930|SX-340|XT-930|SX-310|SP-360|SP60|SPT-800|SP-120|SPT-800|SP-140|SPX-5|SPX-8|SP-100|SPX-8|SPX-12)\\b",
        "Wolfgang": "AT-B24D|AT-AS50HD|AT-AS40W|AT-AS55HD|AT-AS45q2|AT-B26D|AT-AS50Q",
        "Alcatel": "Alcatel",
        "Nintendo": "Nintendo (3DS|Switch)",
        "Amoi": "Amoi",
        "INQ": "INQ",
        "OnePlus": "ONEPLUS",
        "GenericPhone": "Tapatalk|PDA;|SAGEM|\\bmmp\\b|pocket|\\bpsp\\b|symbian|Smartphone|smartfon|treo|up.browser|up.link|vodafone|\\bwap\\b|nokia|Series40|Series60|S60|SonyEricsson|N900|MAUI.*WAP.*Browser"
    },
    "tablets": {
        "iPad": "iPad|iPad.*Mobile",
        "NexusTablet": "Android.*Nexus[\\s]+(7|9|10)",
        "GoogleTablet": "Android.*Pixel C",
        "SamsungTablet": "SAMSUNG.*Tablet|Galaxy.*Tab|SC-01C|GT-P1000|GT-P1003|GT-P1010|GT-P3105|GT-P6210|GT-P6800|GT-P6810|GT-P7100|GT-P7300|GT-P7310|GT-P7500|GT-P7510|SCH-I800|SCH-I815|SCH-I905|SGH-I957|SGH-I987|SGH-T849|SGH-T859|SGH-T869|SPH-P100|GT-P3100|GT-P3108|GT-P3110|GT-P5100|GT-P5110|GT-P6200|GT-P7320|GT-P7511|GT-N8000|GT-P8510|SGH-I497|SPH-P500|SGH-T779|SCH-I705|SCH-I915|GT-N8013|GT-P3113|GT-P5113|GT-P8110|GT-N8010|GT-N8005|GT-N8020|GT-P1013|GT-P6201|GT-P7501|GT-N5100|GT-N5105|GT-N5110|SHV-E140K|SHV-E140L|SHV-E140S|SHV-E150S|SHV-E230K|SHV-E230L|SHV-E230S|SHW-M180K|SHW-M180L|SHW-M180S|SHW-M180W|SHW-M300W|SHW-M305W|SHW-M380K|SHW-M380S|SHW-M380W|SHW-M430W|SHW-M480K|SHW-M480S|SHW-M480W|SHW-M485W|SHW-M486W|SHW-M500W|GT-I9228|SCH-P739|SCH-I925|GT-I9200|GT-P5200|GT-P5210|GT-P5210X|SM-T311|SM-T310|SM-T310X|SM-T210|SM-T210R|SM-T211|SM-P600|SM-P601|SM-P605|SM-P900|SM-P901|SM-T217|SM-T217A|SM-T217S|SM-P6000|SM-T3100|SGH-I467|XE500|SM-T110|GT-P5220|GT-I9200X|GT-N5110X|GT-N5120|SM-P905|SM-T111|SM-T2105|SM-T315|SM-T320|SM-T320X|SM-T321|SM-T520|SM-T525|SM-T530NU|SM-T230NU|SM-T330NU|SM-T900|XE500T1C|SM-P605V|SM-P905V|SM-T337V|SM-T537V|SM-T707V|SM-T807V|SM-P600X|SM-P900X|SM-T210X|SM-T230|SM-T230X|SM-T325|GT-P7503|SM-T531|SM-T330|SM-T530|SM-T705|SM-T705C|SM-T535|SM-T331|SM-T800|SM-T700|SM-T537|SM-T807|SM-P907A|SM-T337A|SM-T537A|SM-T707A|SM-T807A|SM-T237|SM-T807P|SM-P607T|SM-T217T|SM-T337T|SM-T807T|SM-T116NQ|SM-T116BU|SM-P550|SM-T350|SM-T550|SM-T9000|SM-P9000|SM-T705Y|SM-T805|GT-P3113|SM-T710|SM-T810|SM-T815|SM-T360|SM-T533|SM-T113|SM-T335|SM-T715|SM-T560|SM-T670|SM-T677|SM-T377|SM-T567|SM-T357T|SM-T555|SM-T561|SM-T713|SM-T719|SM-T813|SM-T819|SM-T580|SM-T355Y?|SM-T280|SM-T817A|SM-T820|SM-W700|SM-P580|SM-T587|SM-P350|SM-P555M|SM-P355M|SM-T113NU|SM-T815Y|SM-T585|SM-T285|SM-T825|SM-W708|SM-T835|SM-T830|SM-T837V|SM-T720|SM-T510|SM-T387V",
        "Kindle": "Kindle|Silk.*Accelerated|Android.*\\b(KFOT|KFTT|KFJWI|KFJWA|KFOTE|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|WFJWAE|KFSAWA|KFSAWI|KFASWI|KFARWI|KFFOWI|KFGIWI|KFMEWI)\\b|Android.*Silk\/[0-9.]+ like Chrome\/[0-9.]+ (?!Mobile)",
        "SurfaceTablet": "Windows NT [0-9.]+; ARM;.*(Tablet|ARMBJS)",
        "HPTablet": "HP Slate (7|8|10)|HP ElitePad 900|hp-tablet|EliteBook.*Touch|HP 8|Slate 21|HP SlateBook 10",
        "AsusTablet": "^.*PadFone((?!Mobile).)*$|Transformer|TF101|TF101G|TF300T|TF300TG|TF300TL|TF700T|TF700KL|TF701T|TF810C|ME171|ME301T|ME302C|ME371MG|ME370T|ME372MG|ME172V|ME173X|ME400C|Slider SL101|\\bK00F\\b|\\bK00C\\b|\\bK00E\\b|\\bK00L\\b|TX201LA|ME176C|ME102A|\\bM80TA\\b|ME372CL|ME560CG|ME372CG|ME302KL| K010 | K011 | K017 | K01E |ME572C|ME103K|ME170C|ME171C|\\bME70C\\b|ME581C|ME581CL|ME8510C|ME181C|P01Y|PO1MA|P01Z|\\bP027\\b|\\bP024\\b|\\bP00C\\b",
        "BlackBerryTablet": "PlayBook|RIM Tablet",
        "HTCtablet": "HTC_Flyer_P512|HTC Flyer|HTC Jetstream|HTC-P715a|HTC EVO View 4G|PG41200|PG09410",
        "MotorolaTablet": "xoom|sholest|MZ615|MZ605|MZ505|MZ601|MZ602|MZ603|MZ604|MZ606|MZ607|MZ608|MZ609|MZ615|MZ616|MZ617",
        "NookTablet": "Android.*Nook|NookColor|nook browser|BNRV200|BNRV200A|BNTV250|BNTV250A|BNTV400|BNTV600|LogicPD Zoom2",
        "AcerTablet": "Android.*; \\b(A100|A101|A110|A200|A210|A211|A500|A501|A510|A511|A700|A701|W500|W500P|W501|W501P|W510|W511|W700|G100|G100W|B1-A71|B1-710|B1-711|A1-810|A1-811|A1-830)\\b|W3-810|\\bA3-A10\\b|\\bA3-A11\\b|\\bA3-A20\\b|\\bA3-A30",
        "ToshibaTablet": "Android.*(AT100|AT105|AT200|AT205|AT270|AT275|AT300|AT305|AT1S5|AT500|AT570|AT700|AT830)|TOSHIBA.*FOLIO",
        "LGTablet": "\\bL-06C|LG-V909|LG-V900|LG-V700|LG-V510|LG-V500|LG-V410|LG-V400|LG-VK810\\b",
        "FujitsuTablet": "Android.*\\b(F-01D|F-02F|F-05E|F-10D|M532|Q572)\\b",
        "PrestigioTablet": "PMP3170B|PMP3270B|PMP3470B|PMP7170B|PMP3370B|PMP3570C|PMP5870C|PMP3670B|PMP5570C|PMP5770D|PMP3970B|PMP3870C|PMP5580C|PMP5880D|PMP5780D|PMP5588C|PMP7280C|PMP7280C3G|PMP7280|PMP7880D|PMP5597D|PMP5597|PMP7100D|PER3464|PER3274|PER3574|PER3884|PER5274|PER5474|PMP5097CPRO|PMP5097|PMP7380D|PMP5297C|PMP5297C_QUAD|PMP812E|PMP812E3G|PMP812F|PMP810E|PMP880TD|PMT3017|PMT3037|PMT3047|PMT3057|PMT7008|PMT5887|PMT5001|PMT5002",
        "LenovoTablet": "Lenovo TAB|Idea(Tab|Pad)( A1|A10| K1|)|ThinkPad([ ]+)?Tablet|YT3-850M|YT3-X90L|YT3-X90F|YT3-X90X|Lenovo.*(S2109|S2110|S5000|S6000|K3011|A3000|A3500|A1000|A2107|A2109|A1107|A5500|A7600|B6000|B8000|B8080)(-|)(FL|F|HV|H|)|TB-X103F|TB-X304X|TB-X304F|TB-X304L|TB-X505F|TB-X505L|TB-X505X|TB-X605F|TB-X605L|TB-8703F|TB-8703X|TB-8703N|TB-8704N|TB-8704F|TB-8704X|TB-8704V|TB-7304F|TB-7304I|TB-7304X|Tab2A7-10F|Tab2A7-20F|TB2-X30L|YT3-X50L|YT3-X50F|YT3-X50M|YT-X705F|YT-X703F|YT-X703L|YT-X705L|YT-X705X|TB2-X30F|TB2-X30L|TB2-X30M|A2107A-F|A2107A-H|TB3-730F|TB3-730M|TB3-730X|TB-7504F|TB-7504X",
        "DellTablet": "Venue 11|Venue 8|Venue 7|Dell Streak 10|Dell Streak 7",
        "YarvikTablet": "Android.*\\b(TAB210|TAB211|TAB224|TAB250|TAB260|TAB264|TAB310|TAB360|TAB364|TAB410|TAB411|TAB420|TAB424|TAB450|TAB460|TAB461|TAB464|TAB465|TAB467|TAB468|TAB07-100|TAB07-101|TAB07-150|TAB07-151|TAB07-152|TAB07-200|TAB07-201-3G|TAB07-210|TAB07-211|TAB07-212|TAB07-214|TAB07-220|TAB07-400|TAB07-485|TAB08-150|TAB08-200|TAB08-201-3G|TAB08-201-30|TAB09-100|TAB09-211|TAB09-410|TAB10-150|TAB10-201|TAB10-211|TAB10-400|TAB10-410|TAB13-201|TAB274EUK|TAB275EUK|TAB374EUK|TAB462EUK|TAB474EUK|TAB9-200)\\b",
        "MedionTablet": "Android.*\\bOYO\\b|LIFE.*(P9212|P9514|P9516|S9512)|LIFETAB",
        "ArnovaTablet": "97G4|AN10G2|AN7bG3|AN7fG3|AN8G3|AN8cG3|AN7G3|AN9G3|AN7dG3|AN7dG3ST|AN7dG3ChildPad|AN10bG3|AN10bG3DT|AN9G2",
        "IntensoTablet": "INM8002KP|INM1010FP|INM805ND|Intenso Tab|TAB1004",
        "IRUTablet": "M702pro",
        "MegafonTablet": "MegaFon V9|\\bZTE V9\\b|Android.*\\bMT7A\\b",
        "EbodaTablet": "E-Boda (Supreme|Impresspeed|Izzycomm|Essential)",
        "AllViewTablet": "Allview.*(Viva|Alldro|City|Speed|All TV|Frenzy|Quasar|Shine|TX1|AX1|AX2)",
        "ArchosTablet": "\\b(101G9|80G9|A101IT)\\b|Qilive 97R|Archos5|\\bARCHOS (70|79|80|90|97|101|FAMILYPAD|)(b|c|)(G10| Cobalt| TITANIUM(HD|)| Xenon| Neon|XSK| 2| XS 2| PLATINUM| CARBON|GAMEPAD)\\b",
        "AinolTablet": "NOVO7|NOVO8|NOVO10|Novo7Aurora|Novo7Basic|NOVO7PALADIN|novo9-Spark",
        "NokiaLumiaTablet": "Lumia 2520",
        "SonyTablet": "Sony.*Tablet|Xperia Tablet|Sony Tablet S|SO-03E|SGPT12|SGPT13|SGPT114|SGPT121|SGPT122|SGPT123|SGPT111|SGPT112|SGPT113|SGPT131|SGPT132|SGPT133|SGPT211|SGPT212|SGPT213|SGP311|SGP312|SGP321|EBRD1101|EBRD1102|EBRD1201|SGP351|SGP341|SGP511|SGP512|SGP521|SGP541|SGP551|SGP621|SGP641|SGP612|SOT31|SGP771|SGP611|SGP612|SGP712",
        "PhilipsTablet": "\\b(PI2010|PI3000|PI3100|PI3105|PI3110|PI3205|PI3210|PI3900|PI4010|PI7000|PI7100)\\b",
        "CubeTablet": "Android.*(K8GT|U9GT|U10GT|U16GT|U17GT|U18GT|U19GT|U20GT|U23GT|U30GT)|CUBE U8GT",
        "CobyTablet": "MID1042|MID1045|MID1125|MID1126|MID7012|MID7014|MID7015|MID7034|MID7035|MID7036|MID7042|MID7048|MID7127|MID8042|MID8048|MID8127|MID9042|MID9740|MID9742|MID7022|MID7010",
        "MIDTablet": "M9701|M9000|M9100|M806|M1052|M806|T703|MID701|MID713|MID710|MID727|MID760|MID830|MID728|MID933|MID125|MID810|MID732|MID120|MID930|MID800|MID731|MID900|MID100|MID820|MID735|MID980|MID130|MID833|MID737|MID960|MID135|MID860|MID736|MID140|MID930|MID835|MID733|MID4X10",
        "MSITablet": "MSI \\b(Primo 73K|Primo 73L|Primo 81L|Primo 77|Primo 93|Primo 75|Primo 76|Primo 73|Primo 81|Primo 91|Primo 90|Enjoy 71|Enjoy 7|Enjoy 10)\\b",
        "SMiTTablet": "Android.*(\\bMID\\b|MID-560|MTV-T1200|MTV-PND531|MTV-P1101|MTV-PND530)",
        "RockChipTablet": "Android.*(RK2818|RK2808A|RK2918|RK3066)|RK2738|RK2808A",
        "FlyTablet": "IQ310|Fly Vision",
        "bqTablet": "Android.*(bq)?.*\\b(Elcano|Curie|Edison|Maxwell|Kepler|Pascal|Tesla|Hypatia|Platon|Newton|Livingstone|Cervantes|Avant|Aquaris ([E|M]10|M8))\\b|Maxwell.*Lite|Maxwell.*Plus",
        "HuaweiTablet": "MediaPad|MediaPad 7 Youth|IDEOS S7|S7-201c|S7-202u|S7-101|S7-103|S7-104|S7-105|S7-106|S7-201|S7-Slim|M2-A01L|BAH-L09|BAH-W09|AGS-L09|CMR-AL19",
        "NecTablet": "\\bN-06D|\\bN-08D",
        "PantechTablet": "Pantech.*P4100",
        "BronchoTablet": "Broncho.*(N701|N708|N802|a710)",
        "VersusTablet": "TOUCHPAD.*[78910]|\\bTOUCHTAB\\b",
        "ZyncTablet": "z1000|Z99 2G|z930|z990|z909|Z919|z900",
        "PositivoTablet": "TB07STA|TB10STA|TB07FTA|TB10FTA",
        "NabiTablet": "Android.*\\bNabi",
        "KoboTablet": "Kobo Touch|\\bK080\\b|\\bVox\\b Build|\\bArc\\b Build",
        "DanewTablet": "DSlide.*\\b(700|701R|702|703R|704|802|970|971|972|973|974|1010|1012)\\b",
        "TexetTablet": "NaviPad|TB-772A|TM-7045|TM-7055|TM-9750|TM-7016|TM-7024|TM-7026|TM-7041|TM-7043|TM-7047|TM-8041|TM-9741|TM-9747|TM-9748|TM-9751|TM-7022|TM-7021|TM-7020|TM-7011|TM-7010|TM-7023|TM-7025|TM-7037W|TM-7038W|TM-7027W|TM-9720|TM-9725|TM-9737W|TM-1020|TM-9738W|TM-9740|TM-9743W|TB-807A|TB-771A|TB-727A|TB-725A|TB-719A|TB-823A|TB-805A|TB-723A|TB-715A|TB-707A|TB-705A|TB-709A|TB-711A|TB-890HD|TB-880HD|TB-790HD|TB-780HD|TB-770HD|TB-721HD|TB-710HD|TB-434HD|TB-860HD|TB-840HD|TB-760HD|TB-750HD|TB-740HD|TB-730HD|TB-722HD|TB-720HD|TB-700HD|TB-500HD|TB-470HD|TB-431HD|TB-430HD|TB-506|TB-504|TB-446|TB-436|TB-416|TB-146SE|TB-126SE",
        "PlaystationTablet": "Playstation.*(Portable|Vita)",
        "TrekstorTablet": "ST10416-1|VT10416-1|ST70408-1|ST702xx-1|ST702xx-2|ST80208|ST97216|ST70104-2|VT10416-2|ST10216-2A|SurfTab",
        "PyleAudioTablet": "\\b(PTBL10CEU|PTBL10C|PTBL72BC|PTBL72BCEU|PTBL7CEU|PTBL7C|PTBL92BC|PTBL92BCEU|PTBL9CEU|PTBL9CUK|PTBL9C)\\b",
        "AdvanTablet": "Android.* \\b(E3A|T3X|T5C|T5B|T3E|T3C|T3B|T1J|T1F|T2A|T1H|T1i|E1C|T1-E|T5-A|T4|E1-B|T2Ci|T1-B|T1-D|O1-A|E1-A|T1-A|T3A|T4i)\\b ",
        "DanyTechTablet": "Genius Tab G3|Genius Tab S2|Genius Tab Q3|Genius Tab G4|Genius Tab Q4|Genius Tab G-II|Genius TAB GII|Genius TAB GIII|Genius Tab S1",
        "GalapadTablet": "Android.*\\bG1\\b(?!\\))",
        "MicromaxTablet": "Funbook|Micromax.*\\b(P250|P560|P360|P362|P600|P300|P350|P500|P275)\\b",
        "KarbonnTablet": "Android.*\\b(A39|A37|A34|ST8|ST10|ST7|Smart Tab3|Smart Tab2)\\b",
        "AllFineTablet": "Fine7 Genius|Fine7 Shine|Fine7 Air|Fine8 Style|Fine9 More|Fine10 Joy|Fine11 Wide",
        "PROSCANTablet": "\\b(PEM63|PLT1023G|PLT1041|PLT1044|PLT1044G|PLT1091|PLT4311|PLT4311PL|PLT4315|PLT7030|PLT7033|PLT7033D|PLT7035|PLT7035D|PLT7044K|PLT7045K|PLT7045KB|PLT7071KG|PLT7072|PLT7223G|PLT7225G|PLT7777G|PLT7810K|PLT7849G|PLT7851G|PLT7852G|PLT8015|PLT8031|PLT8034|PLT8036|PLT8080K|PLT8082|PLT8088|PLT8223G|PLT8234G|PLT8235G|PLT8816K|PLT9011|PLT9045K|PLT9233G|PLT9735|PLT9760G|PLT9770G)\\b",
        "YONESTablet": "BQ1078|BC1003|BC1077|RK9702|BC9730|BC9001|IT9001|BC7008|BC7010|BC708|BC728|BC7012|BC7030|BC7027|BC7026",
        "ChangJiaTablet": "TPC7102|TPC7103|TPC7105|TPC7106|TPC7107|TPC7201|TPC7203|TPC7205|TPC7210|TPC7708|TPC7709|TPC7712|TPC7110|TPC8101|TPC8103|TPC8105|TPC8106|TPC8203|TPC8205|TPC8503|TPC9106|TPC9701|TPC97101|TPC97103|TPC97105|TPC97106|TPC97111|TPC97113|TPC97203|TPC97603|TPC97809|TPC97205|TPC10101|TPC10103|TPC10106|TPC10111|TPC10203|TPC10205|TPC10503",
        "GUTablet": "TX-A1301|TX-M9002|Q702|kf026",
        "PointOfViewTablet": "TAB-P506|TAB-navi-7-3G-M|TAB-P517|TAB-P-527|TAB-P701|TAB-P703|TAB-P721|TAB-P731N|TAB-P741|TAB-P825|TAB-P905|TAB-P925|TAB-PR945|TAB-PL1015|TAB-P1025|TAB-PI1045|TAB-P1325|TAB-PROTAB[0-9]+|TAB-PROTAB25|TAB-PROTAB26|TAB-PROTAB27|TAB-PROTAB26XL|TAB-PROTAB2-IPS9|TAB-PROTAB30-IPS9|TAB-PROTAB25XXL|TAB-PROTAB26-IPS10|TAB-PROTAB30-IPS10",
        "OvermaxTablet": "OV-(SteelCore|NewBase|Basecore|Baseone|Exellen|Quattor|EduTab|Solution|ACTION|BasicTab|TeddyTab|MagicTab|Stream|TB-08|TB-09)|Qualcore 1027",
        "HCLTablet": "HCL.*Tablet|Connect-3G-2.0|Connect-2G-2.0|ME Tablet U1|ME Tablet U2|ME Tablet G1|ME Tablet X1|ME Tablet Y2|ME Tablet Sync",
        "DPSTablet": "DPS Dream 9|DPS Dual 7",
        "VistureTablet": "V97 HD|i75 3G|Visture V4( HD)?|Visture V5( HD)?|Visture V10",
        "CrestaTablet": "CTP(-)?810|CTP(-)?818|CTP(-)?828|CTP(-)?838|CTP(-)?888|CTP(-)?978|CTP(-)?980|CTP(-)?987|CTP(-)?988|CTP(-)?989",
        "MediatekTablet": "\\bMT8125|MT8389|MT8135|MT8377\\b",
        "ConcordeTablet": "Concorde([ ]+)?Tab|ConCorde ReadMan",
        "GoCleverTablet": "GOCLEVER TAB|A7GOCLEVER|M1042|M7841|M742|R1042BK|R1041|TAB A975|TAB A7842|TAB A741|TAB A741L|TAB M723G|TAB M721|TAB A1021|TAB I921|TAB R721|TAB I720|TAB T76|TAB R70|TAB R76.2|TAB R106|TAB R83.2|TAB M813G|TAB I721|GCTA722|TAB I70|TAB I71|TAB S73|TAB R73|TAB R74|TAB R93|TAB R75|TAB R76.1|TAB A73|TAB A93|TAB A93.2|TAB T72|TAB R83|TAB R974|TAB R973|TAB A101|TAB A103|TAB A104|TAB A104.2|R105BK|M713G|A972BK|TAB A971|TAB R974.2|TAB R104|TAB R83.3|TAB A1042",
        "ModecomTablet": "FreeTAB 9000|FreeTAB 7.4|FreeTAB 7004|FreeTAB 7800|FreeTAB 2096|FreeTAB 7.5|FreeTAB 1014|FreeTAB 1001 |FreeTAB 8001|FreeTAB 9706|FreeTAB 9702|FreeTAB 7003|FreeTAB 7002|FreeTAB 1002|FreeTAB 7801|FreeTAB 1331|FreeTAB 1004|FreeTAB 8002|FreeTAB 8014|FreeTAB 9704|FreeTAB 1003",
        "VoninoTablet": "\\b(Argus[ _]?S|Diamond[ _]?79HD|Emerald[ _]?78E|Luna[ _]?70C|Onyx[ _]?S|Onyx[ _]?Z|Orin[ _]?HD|Orin[ _]?S|Otis[ _]?S|SpeedStar[ _]?S|Magnet[ _]?M9|Primus[ _]?94[ _]?3G|Primus[ _]?94HD|Primus[ _]?QS|Android.*\\bQ8\\b|Sirius[ _]?EVO[ _]?QS|Sirius[ _]?QS|Spirit[ _]?S)\\b",
        "ECSTablet": "V07OT2|TM105A|S10OT1|TR10CS1",
        "StorexTablet": "eZee[_']?(Tab|Go)[0-9]+|TabLC7|Looney Tunes Tab",
        "VodafoneTablet": "SmartTab([ ]+)?[0-9]+|SmartTabII10|SmartTabII7|VF-1497|VFD 1400",
        "EssentielBTablet": "Smart[ ']?TAB[ ]+?[0-9]+|Family[ ']?TAB2",
        "RossMoorTablet": "RM-790|RM-997|RMD-878G|RMD-974R|RMT-705A|RMT-701|RME-601|RMT-501|RMT-711",
        "iMobileTablet": "i-mobile i-note",
        "TolinoTablet": "tolino tab [0-9.]+|tolino shine",
        "AudioSonicTablet": "\\bC-22Q|T7-QC|T-17B|T-17P\\b",
        "AMPETablet": "Android.* A78 ",
        "SkkTablet": "Android.* (SKYPAD|PHOENIX|CYCLOPS)",
        "TecnoTablet": "TECNO P9|TECNO DP8D",
        "JXDTablet": "Android.* \\b(F3000|A3300|JXD5000|JXD3000|JXD2000|JXD300B|JXD300|S5800|S7800|S602b|S5110b|S7300|S5300|S602|S603|S5100|S5110|S601|S7100a|P3000F|P3000s|P101|P200s|P1000m|P200m|P9100|P1000s|S6600b|S908|P1000|P300|S18|S6600|S9100)\\b",
        "iJoyTablet": "Tablet (Spirit 7|Essentia|Galatea|Fusion|Onix 7|Landa|Titan|Scooby|Deox|Stella|Themis|Argon|Unique 7|Sygnus|Hexen|Finity 7|Cream|Cream X2|Jade|Neon 7|Neron 7|Kandy|Scape|Saphyr 7|Rebel|Biox|Rebel|Rebel 8GB|Myst|Draco 7|Myst|Tab7-004|Myst|Tadeo Jones|Tablet Boing|Arrow|Draco Dual Cam|Aurix|Mint|Amity|Revolution|Finity 9|Neon 9|T9w|Amity 4GB Dual Cam|Stone 4GB|Stone 8GB|Andromeda|Silken|X2|Andromeda II|Halley|Flame|Saphyr 9,7|Touch 8|Planet|Triton|Unique 10|Hexen 10|Memphis 4GB|Memphis 8GB|Onix 10)",
        "FX2Tablet": "FX2 PAD7|FX2 PAD10",
        "XoroTablet": "KidsPAD 701|PAD[ ]?712|PAD[ ]?714|PAD[ ]?716|PAD[ ]?717|PAD[ ]?718|PAD[ ]?720|PAD[ ]?721|PAD[ ]?722|PAD[ ]?790|PAD[ ]?792|PAD[ ]?900|PAD[ ]?9715D|PAD[ ]?9716DR|PAD[ ]?9718DR|PAD[ ]?9719QR|PAD[ ]?9720QR|TelePAD1030|Telepad1032|TelePAD730|TelePAD731|TelePAD732|TelePAD735Q|TelePAD830|TelePAD9730|TelePAD795|MegaPAD 1331|MegaPAD 1851|MegaPAD 2151",
        "ViewsonicTablet": "ViewPad 10pi|ViewPad 10e|ViewPad 10s|ViewPad E72|ViewPad7|ViewPad E100|ViewPad 7e|ViewSonic VB733|VB100a",
        "VerizonTablet": "QTAQZ3|QTAIR7|QTAQTZ3|QTASUN1|QTASUN2|QTAXIA1",
        "OdysTablet": "LOOX|XENO10|ODYS[ -](Space|EVO|Xpress|NOON)|\\bXELIO\\b|Xelio10Pro|XELIO7PHONETAB|XELIO10EXTREME|XELIOPT2|NEO_QUAD10",
        "CaptivaTablet": "CAPTIVA PAD",
        "IconbitTablet": "NetTAB|NT-3702|NT-3702S|NT-3702S|NT-3603P|NT-3603P|NT-0704S|NT-0704S|NT-3805C|NT-3805C|NT-0806C|NT-0806C|NT-0909T|NT-0909T|NT-0907S|NT-0907S|NT-0902S|NT-0902S",
        "TeclastTablet": "T98 4G|\\bP80\\b|\\bX90HD\\b|X98 Air|X98 Air 3G|\\bX89\\b|P80 3G|\\bX80h\\b|P98 Air|\\bX89HD\\b|P98 3G|\\bP90HD\\b|P89 3G|X98 3G|\\bP70h\\b|P79HD 3G|G18d 3G|\\bP79HD\\b|\\bP89s\\b|\\bA88\\b|\\bP10HD\\b|\\bP19HD\\b|G18 3G|\\bP78HD\\b|\\bA78\\b|\\bP75\\b|G17s 3G|G17h 3G|\\bP85t\\b|\\bP90\\b|\\bP11\\b|\\bP98t\\b|\\bP98HD\\b|\\bG18d\\b|\\bP85s\\b|\\bP11HD\\b|\\bP88s\\b|\\bA80HD\\b|\\bA80se\\b|\\bA10h\\b|\\bP89\\b|\\bP78s\\b|\\bG18\\b|\\bP85\\b|\\bA70h\\b|\\bA70\\b|\\bG17\\b|\\bP18\\b|\\bA80s\\b|\\bA11s\\b|\\bP88HD\\b|\\bA80h\\b|\\bP76s\\b|\\bP76h\\b|\\bP98\\b|\\bA10HD\\b|\\bP78\\b|\\bP88\\b|\\bA11\\b|\\bA10t\\b|\\bP76a\\b|\\bP76t\\b|\\bP76e\\b|\\bP85HD\\b|\\bP85a\\b|\\bP86\\b|\\bP75HD\\b|\\bP76v\\b|\\bA12\\b|\\bP75a\\b|\\bA15\\b|\\bP76Ti\\b|\\bP81HD\\b|\\bA10\\b|\\bT760VE\\b|\\bT720HD\\b|\\bP76\\b|\\bP73\\b|\\bP71\\b|\\bP72\\b|\\bT720SE\\b|\\bC520Ti\\b|\\bT760\\b|\\bT720VE\\b|T720-3GE|T720-WiFi",
        "OndaTablet": "\\b(V975i|Vi30|VX530|V701|Vi60|V701s|Vi50|V801s|V719|Vx610w|VX610W|V819i|Vi10|VX580W|Vi10|V711s|V813|V811|V820w|V820|Vi20|V711|VI30W|V712|V891w|V972|V819w|V820w|Vi60|V820w|V711|V813s|V801|V819|V975s|V801|V819|V819|V818|V811|V712|V975m|V101w|V961w|V812|V818|V971|V971s|V919|V989|V116w|V102w|V973|Vi40)\\b[\\s]+|V10 \\b4G\\b",
        "JaytechTablet": "TPC-PA762",
        "BlaupunktTablet": "Endeavour 800NG|Endeavour 1010",
        "DigmaTablet": "\\b(iDx10|iDx9|iDx8|iDx7|iDxD7|iDxD8|iDsQ8|iDsQ7|iDsQ8|iDsD10|iDnD7|3TS804H|iDsQ11|iDj7|iDs10)\\b",
        "EvolioTablet": "ARIA_Mini_wifi|Aria[ _]Mini|Evolio X10|Evolio X7|Evolio X8|\\bEvotab\\b|\\bNeura\\b",
        "LavaTablet": "QPAD E704|\\bIvoryS\\b|E-TAB IVORY|\\bE-TAB\\b",
        "AocTablet": "MW0811|MW0812|MW0922|MTK8382|MW1031|MW0831|MW0821|MW0931|MW0712",
        "MpmanTablet": "MP11 OCTA|MP10 OCTA|MPQC1114|MPQC1004|MPQC994|MPQC974|MPQC973|MPQC804|MPQC784|MPQC780|\\bMPG7\\b|MPDCG75|MPDCG71|MPDC1006|MP101DC|MPDC9000|MPDC905|MPDC706HD|MPDC706|MPDC705|MPDC110|MPDC100|MPDC99|MPDC97|MPDC88|MPDC8|MPDC77|MP709|MID701|MID711|MID170|MPDC703|MPQC1010",
        "CelkonTablet": "CT695|CT888|CT[\\s]?910|CT7 Tab|CT9 Tab|CT3 Tab|CT2 Tab|CT1 Tab|C820|C720|\\bCT-1\\b",
        "WolderTablet": "miTab \\b(DIAMOND|SPACE|BROOKLYN|NEO|FLY|MANHATTAN|FUNK|EVOLUTION|SKY|GOCAR|IRON|GENIUS|POP|MINT|EPSILON|BROADWAY|JUMP|HOP|LEGEND|NEW AGE|LINE|ADVANCE|FEEL|FOLLOW|LIKE|LINK|LIVE|THINK|FREEDOM|CHICAGO|CLEVELAND|BALTIMORE-GH|IOWA|BOSTON|SEATTLE|PHOENIX|DALLAS|IN 101|MasterChef)\\b",
        "MediacomTablet": "M-MPI10C3G|M-SP10EG|M-SP10EGP|M-SP10HXAH|M-SP7HXAH|M-SP10HXBH|M-SP8HXAH|M-SP8MXA",
        "MiTablet": "\\bMI PAD\\b|\\bHM NOTE 1W\\b",
        "NibiruTablet": "Nibiru M1|Nibiru Jupiter One",
        "NexoTablet": "NEXO NOVA|NEXO 10|NEXO AVIO|NEXO FREE|NEXO GO|NEXO EVO|NEXO 3G|NEXO SMART|NEXO KIDDO|NEXO MOBI",
        "LeaderTablet": "TBLT10Q|TBLT10I|TBL-10WDKB|TBL-10WDKBO2013|TBL-W230V2|TBL-W450|TBL-W500|SV572|TBLT7I|TBA-AC7-8G|TBLT79|TBL-8W16|TBL-10W32|TBL-10WKB|TBL-W100",
        "UbislateTablet": "UbiSlate[\\s]?7C",
        "PocketBookTablet": "Pocketbook",
        "KocasoTablet": "\\b(TB-1207)\\b",
        "HisenseTablet": "\\b(F5281|E2371)\\b",
        "Hudl": "Hudl HT7S3|Hudl 2",
        "TelstraTablet": "T-Hub2",
        "GenericTablet": "Android.*\\b97D\\b|Tablet(?!.*PC)|BNTV250A|MID-WCDMA|LogicPD Zoom2|\\bA7EB\\b|CatNova8|A1_07|CT704|CT1002|\\bM721\\b|rk30sdk|\\bEVOTAB\\b|M758A|ET904|ALUMIUM10|Smartfren Tab|Endeavour 1010|Tablet-PC-4|Tagi Tab|\\bM6pro\\b|CT1020W|arc 10HD|\\bTP750\\b|\\bQTAQZ3\\b|WVT101|TM1088|KT107"
    },
    "oss": {
        "AndroidOS": "Android",
        "BlackBerryOS": "blackberry|\\bBB10\\b|rim tablet os",
        "PalmOS": "PalmOS|avantgo|blazer|elaine|hiptop|palm|plucker|xiino",
        "SymbianOS": "Symbian|SymbOS|Series60|Series40|SYB-[0-9]+|\\bS60\\b",
        "WindowsMobileOS": "Windows CE.*(PPC|Smartphone|Mobile|[0-9]{3}x[0-9]{3})|Windows Mobile|Windows Phone [0-9.]+|WCE;",
        "WindowsPhoneOS": "Windows Phone 10.0|Windows Phone 8.1|Windows Phone 8.0|Windows Phone OS|XBLWP7|ZuneWP7|Windows NT 6.[23]; ARM;",
        "iOS": "\\biPhone.*Mobile|\\biPod|\\biPad|AppleCoreMedia",
        "iPadOS": "CPU OS 13",
        "MeeGoOS": "MeeGo",
        "MaemoOS": "Maemo",
        "JavaOS": "J2ME\/|\\bMIDP\\b|\\bCLDC\\b",
        "webOS": "webOS|hpwOS",
        "badaOS": "\\bBada\\b",
        "BREWOS": "BREW"
    },
    "uas": {
        "Chrome": "\\bCrMo\\b|CriOS|Android.*Chrome\/[.0-9]* (Mobile)?",
        "Dolfin": "\\bDolfin\\b",
        "Opera": "Opera.*Mini|Opera.*Mobi|Android.*Opera|Mobile.*OPR\/[0-9.]+$|Coast\/[0-9.]+",
        "Skyfire": "Skyfire",
        "Edge": "Mobile Safari\/[.0-9]* Edge",
        "IE": "IEMobile|MSIEMobile",
        "Firefox": "fennec|firefox.*maemo|(Mobile|Tablet).*Firefox|Firefox.*Mobile|FxiOS",
        "Bolt": "bolt",
        "TeaShark": "teashark",
        "Blazer": "Blazer",
        "Safari": "Version.*Mobile.*Safari|Safari.*Mobile|MobileSafari",
        "WeChat": "\\bMicroMessenger\\b",
        "UCBrowser": "UC.*Browser|UCWEB",
        "baiduboxapp": "baiduboxapp",
        "baidubrowser": "baidubrowser",
        "DiigoBrowser": "DiigoBrowser",
        "Mercury": "\\bMercury\\b",
        "ObigoBrowser": "Obigo",
        "NetFront": "NF-Browser",
        "GenericBrowser": "NokiaBrowser|OviBrowser|OneBrowser|TwonkyBeamBrowser|SEMC.*Browser|FlyFlow|Minimo|NetFront|Novarra-Vision|MQQBrowser|MicroMessenger",
        "PaleMoon": "Android.*PaleMoon|Mobile.*PaleMoon"
    },
    "props": {
        "Mobile": "Mobile\/[VER]",
        "Build": "Build\/[VER]",
        "Version": "Version\/[VER]",
        "VendorID": "VendorID\/[VER]",
        "iPad": "iPad.*CPU[a-z ]+[VER]",
        "iPhone": "iPhone.*CPU[a-z ]+[VER]",
        "iPod": "iPod.*CPU[a-z ]+[VER]",
        "Kindle": "Kindle\/[VER]",
        "Chrome": [
            "Chrome\/[VER]",
            "CriOS\/[VER]",
            "CrMo\/[VER]"
        ],
        "Coast": [
            "Coast\/[VER]"
        ],
        "Dolfin": "Dolfin\/[VER]",
        "Firefox": [
            "Firefox\/[VER]",
            "FxiOS\/[VER]"
        ],
        "Fennec": "Fennec\/[VER]",
        "Edge": "Edge\/[VER]",
        "IE": [
            "IEMobile\/[VER];",
            "IEMobile [VER]",
            "MSIE [VER];",
            "Trident\/[0-9.]+;.*rv:[VER]"
        ],
        "NetFront": "NetFront\/[VER]",
        "NokiaBrowser": "NokiaBrowser\/[VER]",
        "Opera": [
            " OPR\/[VER]",
            "Opera Mini\/[VER]",
            "Version\/[VER]"
        ],
        "Opera Mini": "Opera Mini\/[VER]",
        "Opera Mobi": "Version\/[VER]",
        "UCBrowser": [
            "UCWEB[VER]",
            "UC.*Browser\/[VER]"
        ],
        "MQQBrowser": "MQQBrowser\/[VER]",
        "MicroMessenger": "MicroMessenger\/[VER]",
        "baiduboxapp": "baiduboxapp\/[VER]",
        "baidubrowser": "baidubrowser\/[VER]",
        "SamsungBrowser": "SamsungBrowser\/[VER]",
        "Iron": "Iron\/[VER]",
        "Safari": [
            "Version\/[VER]",
            "Safari\/[VER]"
        ],
        "Skyfire": "Skyfire\/[VER]",
        "Tizen": "Tizen\/[VER]",
        "Webkit": "webkit[ \/][VER]",
        "PaleMoon": "PaleMoon\/[VER]",
        "Gecko": "Gecko\/[VER]",
        "Trident": "Trident\/[VER]",
        "Presto": "Presto\/[VER]",
        "Goanna": "Goanna\/[VER]",
        "iOS": " \\bi?OS\\b [VER][ ;]{1}",
        "Android": "Android [VER]",
        "BlackBerry": [
            "BlackBerry[\\w]+\/[VER]",
            "BlackBerry.*Version\/[VER]",
            "Version\/[VER]"
        ],
        "BREW": "BREW [VER]",
        "Java": "Java\/[VER]",
        "Windows Phone OS": [
            "Windows Phone OS [VER]",
            "Windows Phone [VER]"
        ],
        "Windows Phone": "Windows Phone [VER]",
        "Windows CE": "Windows CE\/[VER]",
        "Windows NT": "Windows NT [VER]",
        "Symbian": [
            "SymbianOS\/[VER]",
            "Symbian\/[VER]"
        ],
        "webOS": [
            "webOS\/[VER]",
            "hpwOS\/[VER];"
        ]
    },
    "utils": {
        "Bot": "Googlebot|facebookexternalhit|Google-AMPHTML|s~amp-validator|AdsBot-Google|Google Keyword Suggestion|Facebot|YandexBot|YandexMobileBot|bingbot|ia_archiver|AhrefsBot|Ezooms|GSLFbot|WBSearchBot|Twitterbot|TweetmemeBot|Twikle|PaperLiBot|Wotbox|UnwindFetchor|Exabot|MJ12bot|YandexImages|TurnitinBot|Pingdom|contentkingapp",
        "MobileBot": "Googlebot-Mobile|AdsBot-Google-Mobile|YahooSeeker\/M1A1-R2D2",
        "DesktopMode": "WPDesktop",
        "TV": "SonyDTV|HbbTV",
        "WebKit": "(webkit)[ \/]([\\w.]+)",
        "Console": "\\b(Nintendo|Nintendo WiiU|Nintendo 3DS|Nintendo Switch|PLAYSTATION|Xbox)\\b",
        "Watch": "SM-V700"
    }
};

    // following patterns come from http://detectmobilebrowsers.com/
    impl.detectMobileBrowsers = {
        fullPattern: /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,
        shortPattern: /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i,
        tabletPattern: /android|ipad|playbook|silk/i
    };

    var hasOwnProp = Object.prototype.hasOwnProperty,
        isArray;

    impl.FALLBACK_PHONE = 'UnknownPhone';
    impl.FALLBACK_TABLET = 'UnknownTablet';
    impl.FALLBACK_MOBILE = 'UnknownMobile';

    isArray = ('isArray' in Array) ?
        Array.isArray : function (value) { return Object.prototype.toString.call(value) === '[object Array]'; };

    function equalIC(a, b) {
        return a != null && b != null && a.toLowerCase() === b.toLowerCase();
    }

    function containsIC(array, value) {
        var valueLC, i, len = array.length;
        if (!len || !value) {
            return false;
        }
        valueLC = value.toLowerCase();
        for (i = 0; i < len; ++i) {
            if (valueLC === array[i].toLowerCase()) {
                return true;
            }
        }
        return false;
    }

    function convertPropsToRegExp(object) {
        for (var key in object) {
            if (hasOwnProp.call(object, key)) {
                object[key] = new RegExp(object[key], 'i');
            }
        }
    }

    function prepareUserAgent(userAgent) {
        return (userAgent || '').substr(0, 500); // mitigate vulnerable to ReDoS
    }

    (function init() {
        var key, values, value, i, len, verPos, mobileDetectRules = impl.mobileDetectRules;
        for (key in mobileDetectRules.props) {
            if (hasOwnProp.call(mobileDetectRules.props, key)) {
                values = mobileDetectRules.props[key];
                if (!isArray(values)) {
                    values = [values];
                }
                len = values.length;
                for (i = 0; i < len; ++i) {
                    value = values[i];
                    verPos = value.indexOf('[VER]');
                    if (verPos >= 0) {
                        value = value.substring(0, verPos) + '([\\w._\\+]+)' + value.substring(verPos + 5);
                    }
                    values[i] = new RegExp(value, 'i');
                }
                mobileDetectRules.props[key] = values;
            }
        }
        convertPropsToRegExp(mobileDetectRules.oss);
        convertPropsToRegExp(mobileDetectRules.phones);
        convertPropsToRegExp(mobileDetectRules.tablets);
        convertPropsToRegExp(mobileDetectRules.uas);
        convertPropsToRegExp(mobileDetectRules.utils);

        // copy some patterns to oss0 which are tested first (see issue#15)
        mobileDetectRules.oss0 = {
            WindowsPhoneOS: mobileDetectRules.oss.WindowsPhoneOS,
            WindowsMobileOS: mobileDetectRules.oss.WindowsMobileOS
        };
    }());

    /**
     * Test userAgent string against a set of rules and find the first matched key.
     * @param {Object} rules (key is String, value is RegExp)
     * @param {String} userAgent the navigator.userAgent (or HTTP-Header 'User-Agent').
     * @returns {String|null} the matched key if found, otherwise <tt>null</tt>
     * @private
     */
    impl.findMatch = function(rules, userAgent) {
        for (var key in rules) {
            if (hasOwnProp.call(rules, key)) {
                if (rules[key].test(userAgent)) {
                    return key;
                }
            }
        }
        return null;
    };

    /**
     * Test userAgent string against a set of rules and return an array of matched keys.
     * @param {Object} rules (key is String, value is RegExp)
     * @param {String} userAgent the navigator.userAgent (or HTTP-Header 'User-Agent').
     * @returns {Array} an array of matched keys, may be empty when there is no match, but not <tt>null</tt>
     * @private
     */
    impl.findMatches = function(rules, userAgent) {
        var result = [];
        for (var key in rules) {
            if (hasOwnProp.call(rules, key)) {
                if (rules[key].test(userAgent)) {
                    result.push(key);
                }
            }
        }
        return result;
    };

    /**
     * Check the version of the given property in the User-Agent.
     *
     * @param {String} propertyName
     * @param {String} userAgent
     * @return {String} version or <tt>null</tt> if version not found
     * @private
     */
    impl.getVersionStr = function (propertyName, userAgent) {
        var props = impl.mobileDetectRules.props, patterns, i, len, match;
        if (hasOwnProp.call(props, propertyName)) {
            patterns = props[propertyName];
            len = patterns.length;
            for (i = 0; i < len; ++i) {
                match = patterns[i].exec(userAgent);
                if (match !== null) {
                    return match[1];
                }
            }
        }
        return null;
    };

    /**
     * Check the version of the given property in the User-Agent.
     * Will return a float number. (eg. 2_0 will return 2.0, 4.3.1 will return 4.31)
     *
     * @param {String} propertyName
     * @param {String} userAgent
     * @return {Number} version or <tt>NaN</tt> if version not found
     * @private
     */
    impl.getVersion = function (propertyName, userAgent) {
        var version = impl.getVersionStr(propertyName, userAgent);
        return version ? impl.prepareVersionNo(version) : NaN;
    };

    /**
     * Prepare the version number.
     *
     * @param {String} version
     * @return {Number} the version number as a floating number
     * @private
     */
    impl.prepareVersionNo = function (version) {
        var numbers;

        numbers = version.split(/[a-z._ \/\-]/i);
        if (numbers.length === 1) {
            version = numbers[0];
        }
        if (numbers.length > 1) {
            version = numbers[0] + '.';
            numbers.shift();
            version += numbers.join('');
        }
        return Number(version);
    };

    impl.isMobileFallback = function (userAgent) {
        return impl.detectMobileBrowsers.fullPattern.test(userAgent) ||
            impl.detectMobileBrowsers.shortPattern.test(userAgent.substr(0,4));
    };

    impl.isTabletFallback = function (userAgent) {
        return impl.detectMobileBrowsers.tabletPattern.test(userAgent);
    };

    impl.prepareDetectionCache = function (cache, userAgent, maxPhoneWidth) {
        if (cache.mobile !== undefined) {
            return;
        }
        var phone, tablet, phoneSized;

        // first check for stronger tablet rules, then phone (see issue#5)
        tablet = impl.findMatch(impl.mobileDetectRules.tablets, userAgent);
        if (tablet) {
            cache.mobile = cache.tablet = tablet;
            cache.phone = null;
            return; // unambiguously identified as tablet
        }

        phone = impl.findMatch(impl.mobileDetectRules.phones, userAgent);
        if (phone) {
            cache.mobile = cache.phone = phone;
            cache.tablet = null;
            return; // unambiguously identified as phone
        }

        // our rules haven't found a match -> try more general fallback rules
        if (impl.isMobileFallback(userAgent)) {
            phoneSized = MobileDetect.isPhoneSized(maxPhoneWidth);
            if (phoneSized === undefined) {
                cache.mobile = impl.FALLBACK_MOBILE;
                cache.tablet = cache.phone = null;
            } else if (phoneSized) {
                cache.mobile = cache.phone = impl.FALLBACK_PHONE;
                cache.tablet = null;
            } else {
                cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
                cache.phone = null;
            }
        } else if (impl.isTabletFallback(userAgent)) {
            cache.mobile = cache.tablet = impl.FALLBACK_TABLET;
            cache.phone = null;
        } else {
            // not mobile at all!
            cache.mobile = cache.tablet = cache.phone = null;
        }
    };

    // t is a reference to a MobileDetect instance
    impl.mobileGrade = function (t) {
        // impl note:
        // To keep in sync w/ Mobile_Detect.php easily, the following code is tightly aligned to the PHP version.
        // When changes are made in Mobile_Detect.php, copy this method and replace:
        //     $this-> / t.
        //     self::MOBILE_GRADE_(.) / '$1'
        //     , self::VERSION_TYPE_FLOAT / (nothing)
        //     isIOS() / os('iOS')
        //     [reg] / (nothing)   <-- jsdelivr complaining about unescaped unicode character U+00AE
        var $isMobile = t.mobile() !== null;

        if (
            // Apple iOS 3.2-5.1 - Tested on the original iPad (4.3 / 5.0), iPad 2 (4.3), iPad 3 (5.1), original iPhone (3.1), iPhone 3 (3.2), 3GS (4.3), 4 (4.3 / 5.0), and 4S (5.1)
            t.os('iOS') && t.version('iPad')>=4.3 ||
            t.os('iOS') && t.version('iPhone')>=3.1 ||
            t.os('iOS') && t.version('iPod')>=3.1 ||

            // Android 2.1-2.3 - Tested on the HTC Incredible (2.2), original Droid (2.2), HTC Aria (2.1), Google Nexus S (2.3). Functional on 1.5 & 1.6 but performance may be sluggish, tested on Google G1 (1.5)
            // Android 3.1 (Honeycomb)  - Tested on the Samsung Galaxy Tab 10.1 and Motorola XOOM
            // Android 4.0 (ICS)  - Tested on a Galaxy Nexus. Note: transition performance can be poor on upgraded devices
            // Android 4.1 (Jelly Bean)  - Tested on a Galaxy Nexus and Galaxy 7
            ( t.version('Android')>2.1 && t.is('Webkit') ) ||

            // Windows Phone 7-7.5 - Tested on the HTC Surround (7.0) HTC Trophy (7.5), LG-E900 (7.5), Nokia Lumia 800
            t.version('Windows Phone OS')>=7.0 ||

            // Blackberry 7 - Tested on BlackBerry Torch 9810
            // Blackberry 6.0 - Tested on the Torch 9800 and Style 9670
            t.is('BlackBerry') && t.version('BlackBerry')>=6.0 ||
            // Blackberry Playbook (1.0-2.0) - Tested on PlayBook
            t.match('Playbook.*Tablet') ||

            // Palm WebOS (1.4-2.0) - Tested on the Palm Pixi (1.4), Pre (1.4), Pre 2 (2.0)
            ( t.version('webOS')>=1.4 && t.match('Palm|Pre|Pixi') ) ||
            // Palm WebOS 3.0  - Tested on HP TouchPad
            t.match('hp.*TouchPad') ||

            // Firefox Mobile (12 Beta) - Tested on Android 2.3 device
            ( t.is('Firefox') && t.version('Firefox')>=12 ) ||

            // Chrome for Android - Tested on Android 4.0, 4.1 device
            ( t.is('Chrome') && t.is('AndroidOS') && t.version('Android')>=4.0 ) ||

            // Skyfire 4.1 - Tested on Android 2.3 device
            ( t.is('Skyfire') && t.version('Skyfire')>=4.1 && t.is('AndroidOS') && t.version('Android')>=2.3 ) ||

            // Opera Mobile 11.5-12: Tested on Android 2.3
            ( t.is('Opera') && t.version('Opera Mobi')>11 && t.is('AndroidOS') ) ||

            // Meego 1.2 - Tested on Nokia 950 and N9
            t.is('MeeGoOS') ||

            // Tizen (pre-release) - Tested on early hardware
            t.is('Tizen') ||

            // Samsung Bada 2.0 - Tested on a Samsung Wave 3, Dolphin browser
            // @todo: more tests here!
            t.is('Dolfin') && t.version('Bada')>=2.0 ||

            // UC Browser - Tested on Android 2.3 device
            ( (t.is('UC Browser') || t.is('Dolfin')) && t.version('Android')>=2.3 ) ||

            // Kindle 3 and Fire  - Tested on the built-in WebKit browser for each
            ( t.match('Kindle Fire') ||
                t.is('Kindle') && t.version('Kindle')>=3.0 ) ||

            // Nook Color 1.4.1 - Tested on original Nook Color, not Nook Tablet
            t.is('AndroidOS') && t.is('NookTablet') ||

            // Chrome Desktop 11-21 - Tested on OS X 10.7 and Windows 7
            t.version('Chrome')>=11 && !$isMobile ||

            // Safari Desktop 4-5 - Tested on OS X 10.7 and Windows 7
            t.version('Safari')>=5.0 && !$isMobile ||

            // Firefox Desktop 4-13 - Tested on OS X 10.7 and Windows 7
            t.version('Firefox')>=4.0 && !$isMobile ||

            // Internet Explorer 7-9 - Tested on Windows XP, Vista and 7
            t.version('MSIE')>=7.0 && !$isMobile ||

            // Opera Desktop 10-12 - Tested on OS X 10.7 and Windows 7
            // @reference: http://my.opera.com/community/openweb/idopera/
            t.version('Opera')>=10 && !$isMobile

            ){
            return 'A';
        }

        if (
            t.os('iOS') && t.version('iPad')<4.3 ||
            t.os('iOS') && t.version('iPhone')<3.1 ||
            t.os('iOS') && t.version('iPod')<3.1 ||

            // Blackberry 5.0: Tested on the Storm 2 9550, Bold 9770
            t.is('Blackberry') && t.version('BlackBerry')>=5 && t.version('BlackBerry')<6 ||

            //Opera Mini (5.0-6.5) - Tested on iOS 3.2/4.3 and Android 2.3
            ( t.version('Opera Mini')>=5.0 && t.version('Opera Mini')<=6.5 &&
                (t.version('Android')>=2.3 || t.is('iOS')) ) ||

            // Nokia Symbian^3 - Tested on Nokia N8 (Symbian^3), C7 (Symbian^3), also works on N97 (Symbian^1)
            t.match('NokiaN8|NokiaC7|N97.*Series60|Symbian/3') ||

            // @todo: report this (tested on Nokia N71)
            t.version('Opera Mobi')>=11 && t.is('SymbianOS')
            ){
            return 'B';
        }

        if (
        // Blackberry 4.x - Tested on the Curve 8330
            t.version('BlackBerry')<5.0 ||
            // Windows Mobile - Tested on the HTC Leo (WinMo 5.2)
            t.match('MSIEMobile|Windows CE.*Mobile') || t.version('Windows Mobile')<=5.2

            ){
            return 'C';
        }

        //All older smartphone platforms and featurephones - Any device that doesn't support media queries
        //will receive the basic, C grade experience.
        return 'C';
    };

    impl.detectOS = function (ua) {
        return impl.findMatch(impl.mobileDetectRules.oss0, ua) ||
            impl.findMatch(impl.mobileDetectRules.oss, ua);
    };

    impl.getDeviceSmallerSide = function () {
        return window.screen.width < window.screen.height ?
            window.screen.width :
            window.screen.height;
    };

    /**
     * Constructor for MobileDetect object.
     * <br>
     * Such an object will keep a reference to the given user-agent string and cache most of the detect queries.<br>
     * <div style="background-color: #d9edf7; border: 1px solid #bce8f1; color: #3a87ad; padding: 14px; border-radius: 2px; margin-top: 20px">
     *     <strong>Find information how to download and install:</strong>
     *     <a href="https://github.com/hgoebl/mobile-detect.js/">github.com/hgoebl/mobile-detect.js/</a>
     * </div>
     *
     * @example <pre>
     *     var md = new MobileDetect(window.navigator.userAgent);
     *     if (md.mobile()) {
     *         location.href = (md.mobileGrade() === 'A') ? '/mobile/' : '/lynx/';
     *     }
     * </pre>
     *
     * @param {string} userAgent typically taken from window.navigator.userAgent or http_header['User-Agent']
     * @param {number} [maxPhoneWidth=600] <strong>only for browsers</strong> specify a value for the maximum
     *        width of smallest device side (in logical "CSS" pixels) until a device detected as mobile will be handled
     *        as phone.
     *        This is only used in cases where the device cannot be classified as phone or tablet.<br>
     *        See <a href="http://developer.android.com/guide/practices/screens_support.html">Declaring Tablet Layouts
     *        for Android</a>.<br>
     *        If you provide a value < 0, then this "fuzzy" check is disabled.
     * @constructor
     * @global
     */
    function MobileDetect(userAgent, maxPhoneWidth) {
        this.ua = prepareUserAgent(userAgent);
        this._cache = {};
        //600dp is typical 7" tablet minimum width
        this.maxPhoneWidth = maxPhoneWidth || 600;
    }

    MobileDetect.prototype = {
        constructor: MobileDetect,

        /**
         * Returns the detected phone or tablet type or <tt>null</tt> if it is not a mobile device.
         * <br>
         * For a list of possible return values see {@link MobileDetect#phone} and {@link MobileDetect#tablet}.<br>
         * <br>
         * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
         * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
         * is positive, a value of <code>UnknownPhone</code>, <code>UnknownTablet</code> or
         * <code>UnknownMobile</code> is returned.<br>
         * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
         * <br>
         * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
         * and <code>UnknownMobile</code>, so you will get <code>UnknownMobile</code> here.<br>
         * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
         * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
         * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
         * <br>
         * In most cases you will use the return value just as a boolean.
         *
         * @returns {String} the key for the phone family or tablet family, e.g. "Nexus".
         * @function MobileDetect#mobile
         */
        mobile: function () {
            impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
            return this._cache.mobile;
        },

        /**
         * Returns the detected phone type/family string or <tt>null</tt>.
         * <br>
         * The returned tablet (family or producer) is one of following keys:<br>
         * <br><tt>iPhone, BlackBerry, HTC, Nexus, Dell, Motorola, Samsung, LG, Sony, Asus,
         * NokiaLumia, Micromax, Palm, Vertu, Pantech, Fly, Wiko, iMobile, SimValley,
         * Wolfgang, Alcatel, Nintendo, Amoi, INQ, OnePlus, GenericPhone</tt><br>
         * <br>
         * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
         * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
         * is positive, a value of <code>UnknownPhone</code> or <code>UnknownMobile</code> is returned.<br>
         * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
         * <br>
         * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
         * and <code>UnknownMobile</code>, so you will get <code>null</code> here, while {@link MobileDetect#mobile}
         * will return <code>UnknownMobile</code>.<br>
         * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
         * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
         * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
         * <br>
         * In most cases you will use the return value just as a boolean.
         *
         * @returns {String} the key of the phone family or producer, e.g. "iPhone"
         * @function MobileDetect#phone
         */
        phone: function () {
            impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
            return this._cache.phone;
        },

        /**
         * Returns the detected tablet type/family string or <tt>null</tt>.
         * <br>
         * The returned tablet (family or producer) is one of following keys:<br>
         * <br><tt>iPad, NexusTablet, GoogleTablet, SamsungTablet, Kindle, SurfaceTablet,
         * HPTablet, AsusTablet, BlackBerryTablet, HTCtablet, MotorolaTablet, NookTablet,
         * AcerTablet, ToshibaTablet, LGTablet, FujitsuTablet, PrestigioTablet,
         * LenovoTablet, DellTablet, YarvikTablet, MedionTablet, ArnovaTablet,
         * IntensoTablet, IRUTablet, MegafonTablet, EbodaTablet, AllViewTablet,
         * ArchosTablet, AinolTablet, NokiaLumiaTablet, SonyTablet, PhilipsTablet,
         * CubeTablet, CobyTablet, MIDTablet, MSITablet, SMiTTablet, RockChipTablet,
         * FlyTablet, bqTablet, HuaweiTablet, NecTablet, PantechTablet, BronchoTablet,
         * VersusTablet, ZyncTablet, PositivoTablet, NabiTablet, KoboTablet, DanewTablet,
         * TexetTablet, PlaystationTablet, TrekstorTablet, PyleAudioTablet, AdvanTablet,
         * DanyTechTablet, GalapadTablet, MicromaxTablet, KarbonnTablet, AllFineTablet,
         * PROSCANTablet, YONESTablet, ChangJiaTablet, GUTablet, PointOfViewTablet,
         * OvermaxTablet, HCLTablet, DPSTablet, VistureTablet, CrestaTablet,
         * MediatekTablet, ConcordeTablet, GoCleverTablet, ModecomTablet, VoninoTablet,
         * ECSTablet, StorexTablet, VodafoneTablet, EssentielBTablet, RossMoorTablet,
         * iMobileTablet, TolinoTablet, AudioSonicTablet, AMPETablet, SkkTablet,
         * TecnoTablet, JXDTablet, iJoyTablet, FX2Tablet, XoroTablet, ViewsonicTablet,
         * VerizonTablet, OdysTablet, CaptivaTablet, IconbitTablet, TeclastTablet,
         * OndaTablet, JaytechTablet, BlaupunktTablet, DigmaTablet, EvolioTablet,
         * LavaTablet, AocTablet, MpmanTablet, CelkonTablet, WolderTablet, MediacomTablet,
         * MiTablet, NibiruTablet, NexoTablet, LeaderTablet, UbislateTablet,
         * PocketBookTablet, KocasoTablet, HisenseTablet, Hudl, TelstraTablet,
         * GenericTablet</tt><br>
         * <br>
         * If the device is not detected by the regular expressions from Mobile-Detect, a test is made against
         * the patterns of <a href="http://detectmobilebrowsers.com/">detectmobilebrowsers.com</a>. If this test
         * is positive, a value of <code>UnknownTablet</code> or <code>UnknownMobile</code> is returned.<br>
         * When used in browser, the decision whether phone or tablet is made based on <code>screen.width/height</code>.<br>
         * <br>
         * When used server-side (node.js), there is no way to tell the difference between <code>UnknownTablet</code>
         * and <code>UnknownMobile</code>, so you will get <code>null</code> here, while {@link MobileDetect#mobile}
         * will return <code>UnknownMobile</code>.<br>
         * Be aware that since v1.0.0 in this special case you will get <code>UnknownMobile</code> only for:
         * {@link MobileDetect#mobile}, not for {@link MobileDetect#phone} and {@link MobileDetect#tablet}.
         * In versions before v1.0.0 all 3 methods returned <code>UnknownMobile</code> which was tedious to use.
         * <br>
         * In most cases you will use the return value just as a boolean.
         *
         * @returns {String} the key of the tablet family or producer, e.g. "SamsungTablet"
         * @function MobileDetect#tablet
         */
        tablet: function () {
            impl.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth);
            return this._cache.tablet;
        },

        /**
         * Returns the (first) detected user-agent string or <tt>null</tt>.
         * <br>
         * The returned user-agent is one of following keys:<br>
         * <br><tt>Chrome, Dolfin, Opera, Skyfire, Edge, IE, Firefox, Bolt, TeaShark, Blazer,
         * Safari, WeChat, UCBrowser, baiduboxapp, baidubrowser, DiigoBrowser, Mercury,
         * ObigoBrowser, NetFront, GenericBrowser, PaleMoon</tt><br>
         * <br>
         * In most cases calling {@link MobileDetect#userAgent} will be sufficient. But there are rare
         * cases where a mobile device pretends to be more than one particular browser. You can get the
         * list of all matches with {@link MobileDetect#userAgents} or check for a particular value by
         * providing one of the defined keys as first argument to {@link MobileDetect#is}.
         *
         * @returns {String} the key for the detected user-agent or <tt>null</tt>
         * @function MobileDetect#userAgent
         */
        userAgent: function () {
            if (this._cache.userAgent === undefined) {
                this._cache.userAgent = impl.findMatch(impl.mobileDetectRules.uas, this.ua);
            }
            return this._cache.userAgent;
        },

        /**
         * Returns all detected user-agent strings.
         * <br>
         * The array is empty or contains one or more of following keys:<br>
         * <br><tt>Chrome, Dolfin, Opera, Skyfire, Edge, IE, Firefox, Bolt, TeaShark, Blazer,
         * Safari, WeChat, UCBrowser, baiduboxapp, baidubrowser, DiigoBrowser, Mercury,
         * ObigoBrowser, NetFront, GenericBrowser, PaleMoon</tt><br>
         * <br>
         * In most cases calling {@link MobileDetect#userAgent} will be sufficient. But there are rare
         * cases where a mobile device pretends to be more than one particular browser. You can get the
         * list of all matches with {@link MobileDetect#userAgents} or check for a particular value by
         * providing one of the defined keys as first argument to {@link MobileDetect#is}.
         *
         * @returns {Array} the array of detected user-agent keys or <tt>[]</tt>
         * @function MobileDetect#userAgents
         */
        userAgents: function () {
            if (this._cache.userAgents === undefined) {
                this._cache.userAgents = impl.findMatches(impl.mobileDetectRules.uas, this.ua);
            }
            return this._cache.userAgents;
        },

        /**
         * Returns the detected operating system string or <tt>null</tt>.
         * <br>
         * The operating system is one of following keys:<br>
         * <br><tt>AndroidOS, BlackBerryOS, PalmOS, SymbianOS, WindowsMobileOS, WindowsPhoneOS,
         * iOS, iPadOS, MeeGoOS, MaemoOS, JavaOS, webOS, badaOS, BREWOS</tt><br>
         *
         * @returns {String} the key for the detected operating system.
         * @function MobileDetect#os
         */
        os: function () {
            if (this._cache.os === undefined) {
                this._cache.os = impl.detectOS(this.ua);
            }
            return this._cache.os;
        },

        /**
         * Get the version (as Number) of the given property in the User-Agent.
         * <br>
         * Will return a float number. (eg. 2_0 will return 2.0, 4.3.1 will return 4.31)
         *
         * @param {String} key a key defining a thing which has a version.<br>
         *        You can use one of following keys:<br>
         * <br><tt>Mobile, Build, Version, VendorID, iPad, iPhone, iPod, Kindle, Chrome, Coast,
         * Dolfin, Firefox, Fennec, Edge, IE, NetFront, NokiaBrowser, Opera, Opera Mini,
         * Opera Mobi, UCBrowser, MQQBrowser, MicroMessenger, baiduboxapp, baidubrowser,
         * SamsungBrowser, Iron, Safari, Skyfire, Tizen, Webkit, PaleMoon, Gecko, Trident,
         * Presto, Goanna, iOS, Android, BlackBerry, BREW, Java, Windows Phone OS, Windows
         * Phone, Windows CE, Windows NT, Symbian, webOS</tt><br>
         *
         * @returns {Number} the version as float or <tt>NaN</tt> if User-Agent doesn't contain this version.
         *          Be careful when comparing this value with '==' operator!
         * @function MobileDetect#version
         */
        version: function (key) {
            return impl.getVersion(key, this.ua);
        },

        /**
         * Get the version (as String) of the given property in the User-Agent.
         * <br>
         *
         * @param {String} key a key defining a thing which has a version.<br>
         *        You can use one of following keys:<br>
         * <br><tt>Mobile, Build, Version, VendorID, iPad, iPhone, iPod, Kindle, Chrome, Coast,
         * Dolfin, Firefox, Fennec, Edge, IE, NetFront, NokiaBrowser, Opera, Opera Mini,
         * Opera Mobi, UCBrowser, MQQBrowser, MicroMessenger, baiduboxapp, baidubrowser,
         * SamsungBrowser, Iron, Safari, Skyfire, Tizen, Webkit, PaleMoon, Gecko, Trident,
         * Presto, Goanna, iOS, Android, BlackBerry, BREW, Java, Windows Phone OS, Windows
         * Phone, Windows CE, Windows NT, Symbian, webOS</tt><br>
         *
         * @returns {String} the "raw" version as String or <tt>null</tt> if User-Agent doesn't contain this version.
         *
         * @function MobileDetect#versionStr
         */
        versionStr: function (key) {
            return impl.getVersionStr(key, this.ua);
        },

        /**
         * Global test key against userAgent, os, phone, tablet and some other properties of userAgent string.
         *
         * @param {String} key the key (case-insensitive) of a userAgent, an operating system, phone or
         *        tablet family.<br>
         *        For a complete list of possible values, see {@link MobileDetect#userAgent},
         *        {@link MobileDetect#os}, {@link MobileDetect#phone}, {@link MobileDetect#tablet}.<br>
         *        Additionally you have following keys:<br>
         * <br><tt>Bot, MobileBot, DesktopMode, TV, WebKit, Console, Watch</tt><br>
         *
         * @returns {boolean} <tt>true</tt> when the given key is one of the defined keys of userAgent, os, phone,
         *                    tablet or one of the listed additional keys, otherwise <tt>false</tt>
         * @function MobileDetect#is
         */
        is: function (key) {
            return containsIC(this.userAgents(), key) ||
                   equalIC(key, this.os()) ||
                   equalIC(key, this.phone()) ||
                   equalIC(key, this.tablet()) ||
                   containsIC(impl.findMatches(impl.mobileDetectRules.utils, this.ua), key);
        },

        /**
         * Do a quick test against navigator::userAgent.
         *
         * @param {String|RegExp} pattern the pattern, either as String or RegExp
         *                        (a string will be converted to a case-insensitive RegExp).
         * @returns {boolean} <tt>true</tt> when the pattern matches, otherwise <tt>false</tt>
         * @function MobileDetect#match
         */
        match: function (pattern) {
            if (!(pattern instanceof RegExp)) {
                pattern = new RegExp(pattern, 'i');
            }
            return pattern.test(this.ua);
        },

        /**
         * Checks whether the mobile device can be considered as phone regarding <code>screen.width</code>.
         * <br>
         * Obviously this method makes sense in browser environments only (not for Node.js)!
         * @param {number} [maxPhoneWidth] the maximum logical pixels (aka. CSS-pixels) to be considered as phone.<br>
         *        The argument is optional and if not present or falsy, the value of the constructor is taken.
         * @returns {boolean|undefined} <code>undefined</code> if screen size wasn't detectable, else <code>true</code>
         *          when screen.width is less or equal to maxPhoneWidth, otherwise <code>false</code>.<br>
         *          Will always return <code>undefined</code> server-side.
         */
        isPhoneSized: function (maxPhoneWidth) {
            return MobileDetect.isPhoneSized(maxPhoneWidth || this.maxPhoneWidth);
        },

        /**
         * Returns the mobile grade ('A', 'B', 'C').
         *
         * @returns {String} one of the mobile grades ('A', 'B', 'C').
         * @function MobileDetect#mobileGrade
         */
        mobileGrade: function () {
            if (this._cache.grade === undefined) {
                this._cache.grade = impl.mobileGrade(this);
            }
            return this._cache.grade;
        }
    };

    // environment-dependent
    if (typeof window !== 'undefined' && window.screen) {
        MobileDetect.isPhoneSized = function (maxPhoneWidth) {
            return maxPhoneWidth < 0 ? undefined : impl.getDeviceSmallerSide() <= maxPhoneWidth;
        };
    } else {
        MobileDetect.isPhoneSized = function () {};
    }

    // should not be replaced by a completely new object - just overwrite existing methods
    MobileDetect._impl = impl;
    
    MobileDetect.version = '1.4.4 2019-09-21';

    return MobileDetect;
}); // end of call of define()
})((function (undefined) {
    if (typeof module !== 'undefined' && module.exports) {
        return function (factory) { module.exports = factory(); };
    } else if (typeof define === 'function' && define.amd) {
        return define;
    } else if (typeof window !== 'undefined') {
        return function (factory) { window.MobileDetect = factory(); };
    } else {
        // please file a bug if you get this error!
        throw new Error('unknown environment');
    }
})());
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/*
 *
 * More info at [www.dropzonejs.com](http://www.dropzonejs.com)
 *
 * Copyright (c) 2012, Matias Meno
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */
// The Emitter class provides the ability to call `.on()` on Dropzone to listen
// to events.
// It is strongly based on component's emitter class, and I removed the
// functionality because of the dependency hell with different frameworks.
var Emitter =
/*#__PURE__*/
function () {
  function Emitter() {
    _classCallCheck(this, Emitter);
  }

  _createClass(Emitter, [{
    key: "on",
    // Add an event listener for given event
    value: function on(event, fn) {
      this._callbacks = this._callbacks || {}; // Create namespace for this event

      if (!this._callbacks[event]) {
        this._callbacks[event] = [];
      }

      this._callbacks[event].push(fn);

      return this;
    }
  }, {
    key: "emit",
    value: function emit(event) {
      this._callbacks = this._callbacks || {};
      var callbacks = this._callbacks[event];

      if (callbacks) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = callbacks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var callback = _step.value;
            callback.apply(this, args);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return this;
    } // Remove event listener for given event. If fn is not provided, all event
    // listeners for that event will be removed. If neither is provided, all
    // event listeners will be removed.

  }, {
    key: "off",
    value: function off(event, fn) {
      if (!this._callbacks || arguments.length === 0) {
        this._callbacks = {};
        return this;
      } // specific event


      var callbacks = this._callbacks[event];

      if (!callbacks) {
        return this;
      } // remove all handlers


      if (arguments.length === 1) {
        delete this._callbacks[event];
        return this;
      } // remove specific handler


      for (var i = 0; i < callbacks.length; i++) {
        var callback = callbacks[i];

        if (callback === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }

      return this;
    }
  }]);

  return Emitter;
}();

var Dropzone =
/*#__PURE__*/
function (_Emitter) {
  _inherits(Dropzone, _Emitter);

  _createClass(Dropzone, null, [{
    key: "initClass",
    value: function initClass() {
      // Exposing the emitter class, mainly for tests
      this.prototype.Emitter = Emitter;
      /*
       This is a list of all available events you can register on a dropzone object.
        You can register an event handler like this:
        dropzone.on("dragEnter", function() { });
        */

      this.prototype.events = ["drop", "dragstart", "dragend", "dragenter", "dragover", "dragleave", "addedfile", "addedfiles", "removedfile", "thumbnail", "error", "errormultiple", "processing", "processingmultiple", "uploadprogress", "totaluploadprogress", "sending", "sendingmultiple", "success", "successmultiple", "canceled", "canceledmultiple", "complete", "completemultiple", "reset", "maxfilesexceeded", "maxfilesreached", "queuecomplete"];
      this.prototype.defaultOptions = {
        /**
         * Has to be specified on elements other than form (or when the form
         * doesn't have an `action` attribute). You can also
         * provide a function that will be called with `files` and
         * must return the url (since `v3.12.0`)
         */
        url: null,

        /**
         * Can be changed to `"put"` if necessary. You can also provide a function
         * that will be called with `files` and must return the method (since `v3.12.0`).
         */
        method: "post",

        /**
         * Will be set on the XHRequest.
         */
        withCredentials: false,

        /**
         * The timeout for the XHR requests in milliseconds (since `v4.4.0`).
         */
        timeout: 30000,

        /**
         * How many file uploads to process in parallel (See the
         * Enqueuing file uploads documentation section for more info)
         */
        parallelUploads: 2,

        /**
         * Whether to send multiple files in one request. If
         * this it set to true, then the fallback file input element will
         * have the `multiple` attribute as well. This option will
         * also trigger additional events (like `processingmultiple`). See the events
         * documentation section for more information.
         */
        uploadMultiple: false,

        /**
         * Whether you want files to be uploaded in chunks to your server. This can't be
         * used in combination with `uploadMultiple`.
         *
         * See [chunksUploaded](#config-chunksUploaded) for the callback to finalise an upload.
         */
        chunking: false,

        /**
         * If `chunking` is enabled, this defines whether **every** file should be chunked,
         * even if the file size is below chunkSize. This means, that the additional chunk
         * form data will be submitted and the `chunksUploaded` callback will be invoked.
         */
        forceChunking: false,

        /**
         * If `chunking` is `true`, then this defines the chunk size in bytes.
         */
        chunkSize: 2000000,

        /**
         * If `true`, the individual chunks of a file are being uploaded simultaneously.
         */
        parallelChunkUploads: false,

        /**
         * Whether a chunk should be retried if it fails.
         */
        retryChunks: false,

        /**
         * If `retryChunks` is true, how many times should it be retried.
         */
        retryChunksLimit: 3,

        /**
         * If not `null` defines how many files this Dropzone handles. If it exceeds,
         * the event `maxfilesexceeded` will be called. The dropzone element gets the
         * class `dz-max-files-reached` accordingly so you can provide visual feedback.
         */
        maxFilesize: 256,

        /**
         * The name of the file param that gets transferred.
         * **NOTE**: If you have the option  `uploadMultiple` set to `true`, then
         * Dropzone will append `[]` to the name.
         */
        paramName: "file",

        /**
         * Whether thumbnails for images should be generated
         */
        createImageThumbnails: true,

        /**
         * In MB. When the filename exceeds this limit, the thumbnail will not be generated.
         */
        maxThumbnailFilesize: 10,

        /**
         * If `null`, the ratio of the image will be used to calculate it.
         */
        thumbnailWidth: 120,

        /**
         * The same as `thumbnailWidth`. If both are null, images will not be resized.
         */
        thumbnailHeight: 120,

        /**
         * How the images should be scaled down in case both, `thumbnailWidth` and `thumbnailHeight` are provided.
         * Can be either `contain` or `crop`.
         */
        thumbnailMethod: 'crop',

        /**
         * If set, images will be resized to these dimensions before being **uploaded**.
         * If only one, `resizeWidth` **or** `resizeHeight` is provided, the original aspect
         * ratio of the file will be preserved.
         *
         * The `options.transformFile` function uses these options, so if the `transformFile` function
         * is overridden, these options don't do anything.
         */
        resizeWidth: null,

        /**
         * See `resizeWidth`.
         */
        resizeHeight: null,

        /**
         * The mime type of the resized image (before it gets uploaded to the server).
         * If `null` the original mime type will be used. To force jpeg, for example, use `image/jpeg`.
         * See `resizeWidth` for more information.
         */
        resizeMimeType: null,

        /**
         * The quality of the resized images. See `resizeWidth`.
         */
        resizeQuality: 0.8,

        /**
         * How the images should be scaled down in case both, `resizeWidth` and `resizeHeight` are provided.
         * Can be either `contain` or `crop`.
         */
        resizeMethod: 'contain',

        /**
         * The base that is used to calculate the filesize. You can change this to
         * 1024 if you would rather display kibibytes, mebibytes, etc...
         * 1024 is technically incorrect, because `1024 bytes` are `1 kibibyte` not `1 kilobyte`.
         * You can change this to `1024` if you don't care about validity.
         */
        filesizeBase: 1000,

        /**
         * Can be used to limit the maximum number of files that will be handled by this Dropzone
         */
        maxFiles: null,

        /**
         * An optional object to send additional headers to the server. Eg:
         * `{ "My-Awesome-Header": "header value" }`
         */
        headers: null,

        /**
         * If `true`, the dropzone element itself will be clickable, if `false`
         * nothing will be clickable.
         *
         * You can also pass an HTML element, a CSS selector (for multiple elements)
         * or an array of those. In that case, all of those elements will trigger an
         * upload when clicked.
         */
        clickable: true,

        /**
         * Whether hidden files in directories should be ignored.
         */
        ignoreHiddenFiles: true,

        /**
         * The default implementation of `accept` checks the file's mime type or
         * extension against this list. This is a comma separated list of mime
         * types or file extensions.
         *
         * Eg.: `image/*,application/pdf,.psd`
         *
         * If the Dropzone is `clickable` this option will also be used as
         * [`accept`](https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept)
         * parameter on the hidden file input as well.
         */
        acceptedFiles: null,

        /**
         * **Deprecated!**
         * Use acceptedFiles instead.
         */
        acceptedMimeTypes: null,

        /**
         * If false, files will be added to the queue but the queue will not be
         * processed automatically.
         * This can be useful if you need some additional user input before sending
         * files (or if you want want all files sent at once).
         * If you're ready to send the file simply call `myDropzone.processQueue()`.
         *
         * See the [enqueuing file uploads](#enqueuing-file-uploads) documentation
         * section for more information.
         */
        autoProcessQueue: true,

        /**
         * If false, files added to the dropzone will not be queued by default.
         * You'll have to call `enqueueFile(file)` manually.
         */
        autoQueue: true,

        /**
         * If `true`, this will add a link to every file preview to remove or cancel (if
         * already uploading) the file. The `dictCancelUpload`, `dictCancelUploadConfirmation`
         * and `dictRemoveFile` options are used for the wording.
         */
        addRemoveLinks: false,

        /**
         * Defines where to display the file previews – if `null` the
         * Dropzone element itself is used. Can be a plain `HTMLElement` or a CSS
         * selector. The element should have the `dropzone-previews` class so
         * the previews are displayed properly.
         */
        previewsContainer: null,

        /**
         * This is the element the hidden input field (which is used when clicking on the
         * dropzone to trigger file selection) will be appended to. This might
         * be important in case you use frameworks to switch the content of your page.
         *
         * Can be a selector string, or an element directly.
         */
        hiddenInputContainer: "body",

        /**
         * If null, no capture type will be specified
         * If camera, mobile devices will skip the file selection and choose camera
         * If microphone, mobile devices will skip the file selection and choose the microphone
         * If camcorder, mobile devices will skip the file selection and choose the camera in video mode
         * On apple devices multiple must be set to false.  AcceptedFiles may need to
         * be set to an appropriate mime type (e.g. "image/*", "audio/*", or "video/*").
         */
        capture: null,

        /**
         * **Deprecated**. Use `renameFile` instead.
         */
        renameFilename: null,

        /**
         * A function that is invoked before the file is uploaded to the server and renames the file.
         * This function gets the `File` as argument and can use the `file.name`. The actual name of the
         * file that gets used during the upload can be accessed through `file.upload.filename`.
         */
        renameFile: null,

        /**
         * If `true` the fallback will be forced. This is very useful to test your server
         * implementations first and make sure that everything works as
         * expected without dropzone if you experience problems, and to test
         * how your fallbacks will look.
         */
        forceFallback: false,

        /**
         * The text used before any files are dropped.
         */
        dictDefaultMessage: "Drop files here to upload",

        /**
         * The text that replaces the default message text it the browser is not supported.
         */
        dictFallbackMessage: "Your browser does not support drag'n'drop file uploads.",

        /**
         * The text that will be added before the fallback form.
         * If you provide a  fallback element yourself, or if this option is `null` this will
         * be ignored.
         */
        dictFallbackText: "Please use the fallback form below to upload your files like in the olden days.",

        /**
         * If the filesize is too big.
         * `{{filesize}}` and `{{maxFilesize}}` will be replaced with the respective configuration values.
         */
        dictFileTooBig: "File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.",

        /**
         * If the file doesn't match the file type.
         */
        dictInvalidFileType: "You can't upload files of this type.",

        /**
         * If the server response was invalid.
         * `{{statusCode}}` will be replaced with the servers status code.
         */
        dictResponseError: "Server responded with {{statusCode}} code.",

        /**
         * If `addRemoveLinks` is true, the text to be used for the cancel upload link.
         */
        dictCancelUpload: "Cancel upload",

        /**
         * The text that is displayed if an upload was manually canceled
         */
        dictUploadCanceled: "Upload canceled.",

        /**
         * If `addRemoveLinks` is true, the text to be used for confirmation when cancelling upload.
         */
        dictCancelUploadConfirmation: "Are you sure you want to cancel this upload?",

        /**
         * If `addRemoveLinks` is true, the text to be used to remove a file.
         */
        dictRemoveFile: "Remove file",

        /**
         * If this is not null, then the user will be prompted before removing a file.
         */
        dictRemoveFileConfirmation: null,

        /**
         * Displayed if `maxFiles` is st and exceeded.
         * The string `{{maxFiles}}` will be replaced by the configuration value.
         */
        dictMaxFilesExceeded: "You can not upload any more files.",

        /**
         * Allows you to translate the different units. Starting with `tb` for terabytes and going down to
         * `b` for bytes.
         */
        dictFileSizeUnits: {
          tb: "TB",
          gb: "GB",
          mb: "MB",
          kb: "KB",
          b: "b"
        },

        /**
         * Called when dropzone initialized
         * You can add event listeners here
         */
        init: function init() {},

        /**
         * Can be an **object** of additional parameters to transfer to the server, **or** a `Function`
         * that gets invoked with the `files`, `xhr` and, if it's a chunked upload, `chunk` arguments. In case
         * of a function, this needs to return a map.
         *
         * The default implementation does nothing for normal uploads, but adds relevant information for
         * chunked uploads.
         *
         * This is the same as adding hidden input fields in the form element.
         */
        params: function params(files, xhr, chunk) {
          if (chunk) {
            return {
              dzuuid: chunk.file.upload.uuid,
              dzchunkindex: chunk.index,
              dztotalfilesize: chunk.file.size,
              dzchunksize: this.options.chunkSize,
              dztotalchunkcount: chunk.file.upload.totalChunkCount,
              dzchunkbyteoffset: chunk.index * this.options.chunkSize
            };
          }
        },

        /**
         * A function that gets a [file](https://developer.mozilla.org/en-US/docs/DOM/File)
         * and a `done` function as parameters.
         *
         * If the done function is invoked without arguments, the file is "accepted" and will
         * be processed. If you pass an error message, the file is rejected, and the error
         * message will be displayed.
         * This function will not be called if the file is too big or doesn't match the mime types.
         */
        accept: function accept(file, done) {
          return done();
        },

        /**
         * The callback that will be invoked when all chunks have been uploaded for a file.
         * It gets the file for which the chunks have been uploaded as the first parameter,
         * and the `done` function as second. `done()` needs to be invoked when everything
         * needed to finish the upload process is done.
         */
        chunksUploaded: function chunksUploaded(file, done) {
          done();
        },

        /**
         * Gets called when the browser is not supported.
         * The default implementation shows the fallback input field and adds
         * a text.
         */
        fallback: function fallback() {
          // This code should pass in IE7... :(
          var messageElement;
          this.element.className = "".concat(this.element.className, " dz-browser-not-supported");
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = this.element.getElementsByTagName("div")[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var child = _step2.value;

              if (/(^| )dz-message($| )/.test(child.className)) {
                messageElement = child;
                child.className = "dz-message"; // Removes the 'dz-default' class

                break;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          if (!messageElement) {
            messageElement = Dropzone.createElement("<div class=\"dz-message\"><span></span></div>");
            this.element.appendChild(messageElement);
          }

          var span = messageElement.getElementsByTagName("span")[0];

          if (span) {
            if (span.textContent != null) {
              span.textContent = this.options.dictFallbackMessage;
            } else if (span.innerText != null) {
              span.innerText = this.options.dictFallbackMessage;
            }
          }

          return this.element.appendChild(this.getFallbackForm());
        },

        /**
         * Gets called to calculate the thumbnail dimensions.
         *
         * It gets `file`, `width` and `height` (both may be `null`) as parameters and must return an object containing:
         *
         *  - `srcWidth` & `srcHeight` (required)
         *  - `trgWidth` & `trgHeight` (required)
         *  - `srcX` & `srcY` (optional, default `0`)
         *  - `trgX` & `trgY` (optional, default `0`)
         *
         * Those values are going to be used by `ctx.drawImage()`.
         */
        resize: function resize(file, width, height, resizeMethod) {
          var info = {
            srcX: 0,
            srcY: 0,
            srcWidth: file.width,
            srcHeight: file.height
          };
          var srcRatio = file.width / file.height; // Automatically calculate dimensions if not specified

          if (width == null && height == null) {
            width = info.srcWidth;
            height = info.srcHeight;
          } else if (width == null) {
            width = height * srcRatio;
          } else if (height == null) {
            height = width / srcRatio;
          } // Make sure images aren't upscaled


          width = Math.min(width, info.srcWidth);
          height = Math.min(height, info.srcHeight);
          var trgRatio = width / height;

          if (info.srcWidth > width || info.srcHeight > height) {
            // Image is bigger and needs rescaling
            if (resizeMethod === 'crop') {
              if (srcRatio > trgRatio) {
                info.srcHeight = file.height;
                info.srcWidth = info.srcHeight * trgRatio;
              } else {
                info.srcWidth = file.width;
                info.srcHeight = info.srcWidth / trgRatio;
              }
            } else if (resizeMethod === 'contain') {
              // Method 'contain'
              if (srcRatio > trgRatio) {
                height = width / srcRatio;
              } else {
                width = height * srcRatio;
              }
            } else {
              throw new Error("Unknown resizeMethod '".concat(resizeMethod, "'"));
            }
          }

          info.srcX = (file.width - info.srcWidth) / 2;
          info.srcY = (file.height - info.srcHeight) / 2;
          info.trgWidth = width;
          info.trgHeight = height;
          return info;
        },

        /**
         * Can be used to transform the file (for example, resize an image if necessary).
         *
         * The default implementation uses `resizeWidth` and `resizeHeight` (if provided) and resizes
         * images according to those dimensions.
         *
         * Gets the `file` as the first parameter, and a `done()` function as the second, that needs
         * to be invoked with the file when the transformation is done.
         */
        transformFile: function transformFile(file, done) {
          if ((this.options.resizeWidth || this.options.resizeHeight) && file.type.match(/image.*/)) {
            return this.resizeImage(file, this.options.resizeWidth, this.options.resizeHeight, this.options.resizeMethod, done);
          } else {
            return done(file);
          }
        },

        /**
         * A string that contains the template used for each dropped
         * file. Change it to fulfill your needs but make sure to properly
         * provide all elements.
         *
         * If you want to use an actual HTML element instead of providing a String
         * as a config option, you could create a div with the id `tpl`,
         * put the template inside it and provide the element like this:
         *
         *     document
         *       .querySelector('#tpl')
         *       .innerHTML
         *
         */
        previewTemplate: "<div class=\"dz-preview dz-file-preview\">\n  <div class=\"dz-image\"><img data-dz-thumbnail /></div>\n  <div class=\"dz-details\">\n    <div class=\"dz-size\"><span data-dz-size></span></div>\n    <div class=\"dz-filename\"><span data-dz-name></span></div>\n  </div>\n  <div class=\"dz-progress\"><span class=\"dz-upload\" data-dz-uploadprogress></span></div>\n  <div class=\"dz-error-message\"><span data-dz-errormessage></span></div>\n  <div class=\"dz-success-mark\">\n    <svg width=\"54px\" height=\"54px\" viewBox=\"0 0 54 54\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n      <title>Check</title>\n      <g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n        <path d=\"M23.5,31.8431458 L17.5852419,25.9283877 C16.0248253,24.3679711 13.4910294,24.366835 11.9289322,25.9289322 C10.3700136,27.4878508 10.3665912,30.0234455 11.9283877,31.5852419 L20.4147581,40.0716123 C20.5133999,40.1702541 20.6159315,40.2626649 20.7218615,40.3488435 C22.2835669,41.8725651 24.794234,41.8626202 26.3461564,40.3106978 L43.3106978,23.3461564 C44.8771021,21.7797521 44.8758057,19.2483887 43.3137085,17.6862915 C41.7547899,16.1273729 39.2176035,16.1255422 37.6538436,17.6893022 L23.5,31.8431458 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\" stroke-opacity=\"0.198794158\" stroke=\"#747474\" fill-opacity=\"0.816519475\" fill=\"#FFFFFF\"></path>\n      </g>\n    </svg>\n  </div>\n  <div class=\"dz-error-mark\">\n    <svg width=\"54px\" height=\"54px\" viewBox=\"0 0 54 54\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n      <title>Error</title>\n      <g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n        <g stroke=\"#747474\" stroke-opacity=\"0.198794158\" fill=\"#FFFFFF\" fill-opacity=\"0.816519475\">\n          <path d=\"M32.6568542,29 L38.3106978,23.3461564 C39.8771021,21.7797521 39.8758057,19.2483887 38.3137085,17.6862915 C36.7547899,16.1273729 34.2176035,16.1255422 32.6538436,17.6893022 L27,23.3431458 L21.3461564,17.6893022 C19.7823965,16.1255422 17.2452101,16.1273729 15.6862915,17.6862915 C14.1241943,19.2483887 14.1228979,21.7797521 15.6893022,23.3461564 L21.3431458,29 L15.6893022,34.6538436 C14.1228979,36.2202479 14.1241943,38.7516113 15.6862915,40.3137085 C17.2452101,41.8726271 19.7823965,41.8744578 21.3461564,40.3106978 L27,34.6568542 L32.6538436,40.3106978 C34.2176035,41.8744578 36.7547899,41.8726271 38.3137085,40.3137085 C39.8758057,38.7516113 39.8771021,36.2202479 38.3106978,34.6538436 L32.6568542,29 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\"></path>\n        </g>\n      </g>\n    </svg>\n  </div>\n</div>",
        // END OPTIONS
        // (Required by the dropzone documentation parser)

        /*
         Those functions register themselves to the events on init and handle all
         the user interface specific stuff. Overwriting them won't break the upload
         but can break the way it's displayed.
         You can overwrite them if you don't like the default behavior. If you just
         want to add an additional event handler, register it on the dropzone object
         and don't overwrite those options.
         */
        // Those are self explanatory and simply concern the DragnDrop.
        drop: function drop(e) {
          return this.element.classList.remove("dz-drag-hover");
        },
        dragstart: function dragstart(e) {},
        dragend: function dragend(e) {
          return this.element.classList.remove("dz-drag-hover");
        },
        dragenter: function dragenter(e) {
          return this.element.classList.add("dz-drag-hover");
        },
        dragover: function dragover(e) {
          return this.element.classList.add("dz-drag-hover");
        },
        dragleave: function dragleave(e) {
          return this.element.classList.remove("dz-drag-hover");
        },
        paste: function paste(e) {},
        // Called whenever there are no files left in the dropzone anymore, and the
        // dropzone should be displayed as if in the initial state.
        reset: function reset() {
          return this.element.classList.remove("dz-started");
        },
        // Called when a file is added to the queue
        // Receives `file`
        addedfile: function addedfile(file) {
          var _this2 = this;

          if (this.element === this.previewsContainer) {
            this.element.classList.add("dz-started");
          }

          if (this.previewsContainer) {
            file.previewElement = Dropzone.createElement(this.options.previewTemplate.trim());
            file.previewTemplate = file.previewElement; // Backwards compatibility

            this.previewsContainer.appendChild(file.previewElement);
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = file.previewElement.querySelectorAll("[data-dz-name]")[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var node = _step3.value;
                node.textContent = file.name;
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                  _iterator3["return"]();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = file.previewElement.querySelectorAll("[data-dz-size]")[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                node = _step4.value;
                node.innerHTML = this.filesize(file.size);
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                  _iterator4["return"]();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }

            if (this.options.addRemoveLinks) {
              file._removeLink = Dropzone.createElement("<a class=\"dz-remove\" href=\"javascript:undefined;\" data-dz-remove>".concat(this.options.dictRemoveFile, "</a>"));
              file.previewElement.appendChild(file._removeLink);
            }

            var removeFileEvent = function removeFileEvent(e) {
              e.preventDefault();
              e.stopPropagation();

              if (file.status === Dropzone.UPLOADING) {
                return Dropzone.confirm(_this2.options.dictCancelUploadConfirmation, function () {
                  return _this2.removeFile(file);
                });
              } else {
                if (_this2.options.dictRemoveFileConfirmation) {
                  return Dropzone.confirm(_this2.options.dictRemoveFileConfirmation, function () {
                    return _this2.removeFile(file);
                  });
                } else {
                  return _this2.removeFile(file);
                }
              }
            };

            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
              for (var _iterator5 = file.previewElement.querySelectorAll("[data-dz-remove]")[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var removeLink = _step5.value;
                removeLink.addEventListener("click", removeFileEvent);
              }
            } catch (err) {
              _didIteratorError5 = true;
              _iteratorError5 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                  _iterator5["return"]();
                }
              } finally {
                if (_didIteratorError5) {
                  throw _iteratorError5;
                }
              }
            }
          }
        },
        // Called whenever a file is removed.
        removedfile: function removedfile(file) {
          if (file.previewElement != null && file.previewElement.parentNode != null) {
            file.previewElement.parentNode.removeChild(file.previewElement);
          }

          return this._updateMaxFilesReachedClass();
        },
        // Called when a thumbnail has been generated
        // Receives `file` and `dataUrl`
        thumbnail: function thumbnail(file, dataUrl) {
          if (file.previewElement) {
            file.previewElement.classList.remove("dz-file-preview");
            var _iteratorNormalCompletion6 = true;
            var _didIteratorError6 = false;
            var _iteratorError6 = undefined;

            try {
              for (var _iterator6 = file.previewElement.querySelectorAll("[data-dz-thumbnail]")[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                var thumbnailElement = _step6.value;
                thumbnailElement.alt = file.name;
                thumbnailElement.src = dataUrl;
              }
            } catch (err) {
              _didIteratorError6 = true;
              _iteratorError6 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                  _iterator6["return"]();
                }
              } finally {
                if (_didIteratorError6) {
                  throw _iteratorError6;
                }
              }
            }

            return setTimeout(function () {
              return file.previewElement.classList.add("dz-image-preview");
            }, 1);
          }
        },
        // Called whenever an error occurs
        // Receives `file` and `message`
        error: function error(file, message) {
          if (file.previewElement) {
            file.previewElement.classList.add("dz-error");

            if (typeof message !== "String" && message.error) {
              message = message.error;
            }

            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
              for (var _iterator7 = file.previewElement.querySelectorAll("[data-dz-errormessage]")[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var node = _step7.value;
                node.textContent = message;
              }
            } catch (err) {
              _didIteratorError7 = true;
              _iteratorError7 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
                  _iterator7["return"]();
                }
              } finally {
                if (_didIteratorError7) {
                  throw _iteratorError7;
                }
              }
            }
          }
        },
        errormultiple: function errormultiple() {},
        // Called when a file gets processed. Since there is a cue, not all added
        // files are processed immediately.
        // Receives `file`
        processing: function processing(file) {
          if (file.previewElement) {
            file.previewElement.classList.add("dz-processing");

            if (file._removeLink) {
              return file._removeLink.innerHTML = this.options.dictCancelUpload;
            }
          }
        },
        processingmultiple: function processingmultiple() {},
        // Called whenever the upload progress gets updated.
        // Receives `file`, `progress` (percentage 0-100) and `bytesSent`.
        // To get the total number of bytes of the file, use `file.size`
        uploadprogress: function uploadprogress(file, progress, bytesSent) {
          if (file.previewElement) {
            var _iteratorNormalCompletion8 = true;
            var _didIteratorError8 = false;
            var _iteratorError8 = undefined;

            try {
              for (var _iterator8 = file.previewElement.querySelectorAll("[data-dz-uploadprogress]")[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var node = _step8.value;
                node.nodeName === 'PROGRESS' ? node.value = progress : node.style.width = "".concat(progress, "%");
              }
            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
                  _iterator8["return"]();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }
          }
        },
        // Called whenever the total upload progress gets updated.
        // Called with totalUploadProgress (0-100), totalBytes and totalBytesSent
        totaluploadprogress: function totaluploadprogress() {},
        // Called just before the file is sent. Gets the `xhr` object as second
        // parameter, so you can modify it (for example to add a CSRF token) and a
        // `formData` object to add additional information.
        sending: function sending() {},
        sendingmultiple: function sendingmultiple() {},
        // When the complete upload is finished and successful
        // Receives `file`
        success: function success(file) {
          if (file.previewElement) {
            return file.previewElement.classList.add("dz-success");
          }
        },
        successmultiple: function successmultiple() {},
        // When the upload is canceled.
        canceled: function canceled(file) {
          return this.emit("error", file, this.options.dictUploadCanceled);
        },
        canceledmultiple: function canceledmultiple() {},
        // When the upload is finished, either with success or an error.
        // Receives `file`
        complete: function complete(file) {
          if (file._removeLink) {
            file._removeLink.innerHTML = this.options.dictRemoveFile;
          }

          if (file.previewElement) {
            return file.previewElement.classList.add("dz-complete");
          }
        },
        completemultiple: function completemultiple() {},
        maxfilesexceeded: function maxfilesexceeded() {},
        maxfilesreached: function maxfilesreached() {},
        queuecomplete: function queuecomplete() {},
        addedfiles: function addedfiles() {}
      };
      this.prototype._thumbnailQueue = [];
      this.prototype._processingThumbnail = false;
    } // global utility

  }, {
    key: "extend",
    value: function extend(target) {
      for (var _len2 = arguments.length, objects = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        objects[_key2 - 1] = arguments[_key2];
      }

      for (var _i = 0, _objects = objects; _i < _objects.length; _i++) {
        var object = _objects[_i];

        for (var key in object) {
          var val = object[key];
          target[key] = val;
        }
      }

      return target;
    }
  }]);

  function Dropzone(el, options) {
    var _this;

    _classCallCheck(this, Dropzone);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Dropzone).call(this));
    var fallback, left;
    _this.element = el; // For backwards compatibility since the version was in the prototype previously

    _this.version = Dropzone.version;
    _this.defaultOptions.previewTemplate = _this.defaultOptions.previewTemplate.replace(/\n*/g, "");
    _this.clickableElements = [];
    _this.listeners = [];
    _this.files = []; // All files

    if (typeof _this.element === "string") {
      _this.element = document.querySelector(_this.element);
    } // Not checking if instance of HTMLElement or Element since IE9 is extremely weird.


    if (!_this.element || _this.element.nodeType == null) {
      throw new Error("Invalid dropzone element.");
    }

    if (_this.element.dropzone) {
      throw new Error("Dropzone already attached.");
    } // Now add this dropzone to the instances.


    Dropzone.instances.push(_assertThisInitialized(_this)); // Put the dropzone inside the element itself.

    _this.element.dropzone = _assertThisInitialized(_this);
    var elementOptions = (left = Dropzone.optionsForElement(_this.element)) != null ? left : {};
    _this.options = Dropzone.extend({}, _this.defaultOptions, elementOptions, options != null ? options : {}); // If the browser failed, just call the fallback and leave

    if (_this.options.forceFallback || !Dropzone.isBrowserSupported()) {
      return _possibleConstructorReturn(_this, _this.options.fallback.call(_assertThisInitialized(_this)));
    } // @options.url = @element.getAttribute "action" unless @options.url?


    if (_this.options.url == null) {
      _this.options.url = _this.element.getAttribute("action");
    }

    if (!_this.options.url) {
      throw new Error("No URL provided.");
    }

    if (_this.options.acceptedFiles && _this.options.acceptedMimeTypes) {
      throw new Error("You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.");
    }

    if (_this.options.uploadMultiple && _this.options.chunking) {
      throw new Error('You cannot set both: uploadMultiple and chunking.');
    } // Backwards compatibility


    if (_this.options.acceptedMimeTypes) {
      _this.options.acceptedFiles = _this.options.acceptedMimeTypes;
      delete _this.options.acceptedMimeTypes;
    } // Backwards compatibility


    if (_this.options.renameFilename != null) {
      _this.options.renameFile = function (file) {
        return _this.options.renameFilename.call(_assertThisInitialized(_this), file.name, file);
      };
    }

    _this.options.method = _this.options.method.toUpperCase();

    if ((fallback = _this.getExistingFallback()) && fallback.parentNode) {
      // Remove the fallback
      fallback.parentNode.removeChild(fallback);
    } // Display previews in the previewsContainer element or the Dropzone element unless explicitly set to false


    if (_this.options.previewsContainer !== false) {
      if (_this.options.previewsContainer) {
        _this.previewsContainer = Dropzone.getElement(_this.options.previewsContainer, "previewsContainer");
      } else {
        _this.previewsContainer = _this.element;
      }
    }

    if (_this.options.clickable) {
      if (_this.options.clickable === true) {
        _this.clickableElements = [_this.element];
      } else {
        _this.clickableElements = Dropzone.getElements(_this.options.clickable, "clickable");
      }
    }

    _this.init();

    return _this;
  } // Returns all files that have been accepted


  _createClass(Dropzone, [{
    key: "getAcceptedFiles",
    value: function getAcceptedFiles() {
      return this.files.filter(function (file) {
        return file.accepted;
      }).map(function (file) {
        return file;
      });
    } // Returns all files that have been rejected
    // Not sure when that's going to be useful, but added for completeness.

  }, {
    key: "getRejectedFiles",
    value: function getRejectedFiles() {
      return this.files.filter(function (file) {
        return !file.accepted;
      }).map(function (file) {
        return file;
      });
    }
  }, {
    key: "getFilesWithStatus",
    value: function getFilesWithStatus(status) {
      return this.files.filter(function (file) {
        return file.status === status;
      }).map(function (file) {
        return file;
      });
    } // Returns all files that are in the queue

  }, {
    key: "getQueuedFiles",
    value: function getQueuedFiles() {
      return this.getFilesWithStatus(Dropzone.QUEUED);
    }
  }, {
    key: "getUploadingFiles",
    value: function getUploadingFiles() {
      return this.getFilesWithStatus(Dropzone.UPLOADING);
    }
  }, {
    key: "getAddedFiles",
    value: function getAddedFiles() {
      return this.getFilesWithStatus(Dropzone.ADDED);
    } // Files that are either queued or uploading

  }, {
    key: "getActiveFiles",
    value: function getActiveFiles() {
      return this.files.filter(function (file) {
        return file.status === Dropzone.UPLOADING || file.status === Dropzone.QUEUED;
      }).map(function (file) {
        return file;
      });
    } // The function that gets called when Dropzone is initialized. You
    // can (and should) setup event listeners inside this function.

  }, {
    key: "init",
    value: function init() {
      var _this3 = this;

      // In case it isn't set already
      if (this.element.tagName === "form") {
        this.element.setAttribute("enctype", "multipart/form-data");
      }

      if (this.element.classList.contains("dropzone") && !this.element.querySelector(".dz-message")) {
        this.element.appendChild(Dropzone.createElement("<div class=\"dz-default dz-message\"><button class=\"dz-button\" type=\"button\">".concat(this.options.dictDefaultMessage, "</button></div>")));
      }

      if (this.clickableElements.length) {
        var setupHiddenFileInput = function setupHiddenFileInput() {
          if (_this3.hiddenFileInput) {
            _this3.hiddenFileInput.parentNode.removeChild(_this3.hiddenFileInput);
          }

          _this3.hiddenFileInput = document.createElement("input");

          _this3.hiddenFileInput.setAttribute("type", "file");

          if (_this3.options.maxFiles === null || _this3.options.maxFiles > 1) {
            _this3.hiddenFileInput.setAttribute("multiple", "multiple");
          }

          _this3.hiddenFileInput.className = "dz-hidden-input";

          if (_this3.options.acceptedFiles !== null) {
            _this3.hiddenFileInput.setAttribute("accept", _this3.options.acceptedFiles);
          }

          if (_this3.options.capture !== null) {
            _this3.hiddenFileInput.setAttribute("capture", _this3.options.capture);
          } // Not setting `display="none"` because some browsers don't accept clicks
          // on elements that aren't displayed.


          _this3.hiddenFileInput.style.visibility = "hidden";
          _this3.hiddenFileInput.style.position = "absolute";
          _this3.hiddenFileInput.style.top = "0";
          _this3.hiddenFileInput.style.left = "0";
          _this3.hiddenFileInput.style.height = "0";
          _this3.hiddenFileInput.style.width = "0";
          Dropzone.getElement(_this3.options.hiddenInputContainer, 'hiddenInputContainer').appendChild(_this3.hiddenFileInput);
          return _this3.hiddenFileInput.addEventListener("change", function () {
            var files = _this3.hiddenFileInput.files;

            if (files.length) {
              var _iteratorNormalCompletion9 = true;
              var _didIteratorError9 = false;
              var _iteratorError9 = undefined;

              try {
                for (var _iterator9 = files[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                  var file = _step9.value;

                  _this3.addFile(file);
                }
              } catch (err) {
                _didIteratorError9 = true;
                _iteratorError9 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
                    _iterator9["return"]();
                  }
                } finally {
                  if (_didIteratorError9) {
                    throw _iteratorError9;
                  }
                }
              }
            }

            _this3.emit("addedfiles", files);

            return setupHiddenFileInput();
          });
        };

        setupHiddenFileInput();
      }

      this.URL = window.URL !== null ? window.URL : window.webkitURL; // Setup all event listeners on the Dropzone object itself.
      // They're not in @setupEventListeners() because they shouldn't be removed
      // again when the dropzone gets disabled.

      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        for (var _iterator10 = this.events[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          var eventName = _step10.value;
          this.on(eventName, this.options[eventName]);
        }
      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
            _iterator10["return"]();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }

      this.on("uploadprogress", function () {
        return _this3.updateTotalUploadProgress();
      });
      this.on("removedfile", function () {
        return _this3.updateTotalUploadProgress();
      });
      this.on("canceled", function (file) {
        return _this3.emit("complete", file);
      }); // Emit a `queuecomplete` event if all files finished uploading.

      this.on("complete", function (file) {
        if (_this3.getAddedFiles().length === 0 && _this3.getUploadingFiles().length === 0 && _this3.getQueuedFiles().length === 0) {
          // This needs to be deferred so that `queuecomplete` really triggers after `complete`
          return setTimeout(function () {
            return _this3.emit("queuecomplete");
          }, 0);
        }
      });

      var containsFiles = function containsFiles(e) {
        return e.dataTransfer.types && e.dataTransfer.types.some(function (type) {
          return type == "Files";
        });
      };

      var noPropagation = function noPropagation(e) {
        // If there are no files, we don't want to stop
        // propagation so we don't interfere with other
        // drag and drop behaviour.
        if (!containsFiles(e)) return;
        e.stopPropagation();

        if (e.preventDefault) {
          return e.preventDefault();
        } else {
          return e.returnValue = false;
        }
      }; // Create the listeners


      this.listeners = [{
        element: this.element,
        events: {
          "dragstart": function dragstart(e) {
            return _this3.emit("dragstart", e);
          },
          "dragenter": function dragenter(e) {
            noPropagation(e);
            return _this3.emit("dragenter", e);
          },
          "dragover": function dragover(e) {
            // Makes it possible to drag files from chrome's download bar
            // http://stackoverflow.com/questions/19526430/drag-and-drop-file-uploads-from-chrome-downloads-bar
            // Try is required to prevent bug in Internet Explorer 11 (SCRIPT65535 exception)
            var efct;

            try {
              efct = e.dataTransfer.effectAllowed;
            } catch (error) {}

            e.dataTransfer.dropEffect = 'move' === efct || 'linkMove' === efct ? 'move' : 'copy';
            noPropagation(e);
            return _this3.emit("dragover", e);
          },
          "dragleave": function dragleave(e) {
            return _this3.emit("dragleave", e);
          },
          "drop": function drop(e) {
            noPropagation(e);
            return _this3.drop(e);
          },
          "dragend": function dragend(e) {
            return _this3.emit("dragend", e);
          }
        } // This is disabled right now, because the browsers don't implement it properly.
        // "paste": (e) =>
        //   noPropagation e
        //   @paste e

      }];
      this.clickableElements.forEach(function (clickableElement) {
        return _this3.listeners.push({
          element: clickableElement,
          events: {
            "click": function click(evt) {
              // Only the actual dropzone or the message element should trigger file selection
              if (clickableElement !== _this3.element || evt.target === _this3.element || Dropzone.elementInside(evt.target, _this3.element.querySelector(".dz-message"))) {
                _this3.hiddenFileInput.click(); // Forward the click

              }

              return true;
            }
          }
        });
      });
      this.enable();
      return this.options.init.call(this);
    } // Not fully tested yet

  }, {
    key: "destroy",
    value: function destroy() {
      this.disable();
      this.removeAllFiles(true);

      if (this.hiddenFileInput != null ? this.hiddenFileInput.parentNode : undefined) {
        this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);
        this.hiddenFileInput = null;
      }

      delete this.element.dropzone;
      return Dropzone.instances.splice(Dropzone.instances.indexOf(this), 1);
    }
  }, {
    key: "updateTotalUploadProgress",
    value: function updateTotalUploadProgress() {
      var totalUploadProgress;
      var totalBytesSent = 0;
      var totalBytes = 0;
      var activeFiles = this.getActiveFiles();

      if (activeFiles.length) {
        var _iteratorNormalCompletion11 = true;
        var _didIteratorError11 = false;
        var _iteratorError11 = undefined;

        try {
          for (var _iterator11 = this.getActiveFiles()[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
            var file = _step11.value;
            totalBytesSent += file.upload.bytesSent;
            totalBytes += file.upload.total;
          }
        } catch (err) {
          _didIteratorError11 = true;
          _iteratorError11 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
              _iterator11["return"]();
            }
          } finally {
            if (_didIteratorError11) {
              throw _iteratorError11;
            }
          }
        }

        totalUploadProgress = 100 * totalBytesSent / totalBytes;
      } else {
        totalUploadProgress = 100;
      }

      return this.emit("totaluploadprogress", totalUploadProgress, totalBytes, totalBytesSent);
    } // @options.paramName can be a function taking one parameter rather than a string.
    // A parameter name for a file is obtained simply by calling this with an index number.

  }, {
    key: "_getParamName",
    value: function _getParamName(n) {
      if (typeof this.options.paramName === "function") {
        return this.options.paramName(n);
      } else {
        return "".concat(this.options.paramName).concat(this.options.uploadMultiple ? "[".concat(n, "]") : "");
      }
    } // If @options.renameFile is a function,
    // the function will be used to rename the file.name before appending it to the formData

  }, {
    key: "_renameFile",
    value: function _renameFile(file) {
      if (typeof this.options.renameFile !== "function") {
        return file.name;
      }

      return this.options.renameFile(file);
    } // Returns a form that can be used as fallback if the browser does not support DragnDrop
    //
    // If the dropzone is already a form, only the input field and button are returned. Otherwise a complete form element is provided.
    // This code has to pass in IE7 :(

  }, {
    key: "getFallbackForm",
    value: function getFallbackForm() {
      var existingFallback, form;

      if (existingFallback = this.getExistingFallback()) {
        return existingFallback;
      }

      var fieldsString = "<div class=\"dz-fallback\">";

      if (this.options.dictFallbackText) {
        fieldsString += "<p>".concat(this.options.dictFallbackText, "</p>");
      }

      fieldsString += "<input type=\"file\" name=\"".concat(this._getParamName(0), "\" ").concat(this.options.uploadMultiple ? 'multiple="multiple"' : undefined, " /><input type=\"submit\" value=\"Upload!\"></div>");
      var fields = Dropzone.createElement(fieldsString);

      if (this.element.tagName !== "FORM") {
        form = Dropzone.createElement("<form action=\"".concat(this.options.url, "\" enctype=\"multipart/form-data\" method=\"").concat(this.options.method, "\"></form>"));
        form.appendChild(fields);
      } else {
        // Make sure that the enctype and method attributes are set properly
        this.element.setAttribute("enctype", "multipart/form-data");
        this.element.setAttribute("method", this.options.method);
      }

      return form != null ? form : fields;
    } // Returns the fallback elements if they exist already
    //
    // This code has to pass in IE7 :(

  }, {
    key: "getExistingFallback",
    value: function getExistingFallback() {
      var getFallback = function getFallback(elements) {
        var _iteratorNormalCompletion12 = true;
        var _didIteratorError12 = false;
        var _iteratorError12 = undefined;

        try {
          for (var _iterator12 = elements[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
            var el = _step12.value;

            if (/(^| )fallback($| )/.test(el.className)) {
              return el;
            }
          }
        } catch (err) {
          _didIteratorError12 = true;
          _iteratorError12 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
              _iterator12["return"]();
            }
          } finally {
            if (_didIteratorError12) {
              throw _iteratorError12;
            }
          }
        }
      };

      for (var _i2 = 0, _arr = ["div", "form"]; _i2 < _arr.length; _i2++) {
        var tagName = _arr[_i2];
        var fallback;

        if (fallback = getFallback(this.element.getElementsByTagName(tagName))) {
          return fallback;
        }
      }
    } // Activates all listeners stored in @listeners

  }, {
    key: "setupEventListeners",
    value: function setupEventListeners() {
      return this.listeners.map(function (elementListeners) {
        return function () {
          var result = [];

          for (var event in elementListeners.events) {
            var listener = elementListeners.events[event];
            result.push(elementListeners.element.addEventListener(event, listener, false));
          }

          return result;
        }();
      });
    } // Deactivates all listeners stored in @listeners

  }, {
    key: "removeEventListeners",
    value: function removeEventListeners() {
      return this.listeners.map(function (elementListeners) {
        return function () {
          var result = [];

          for (var event in elementListeners.events) {
            var listener = elementListeners.events[event];
            result.push(elementListeners.element.removeEventListener(event, listener, false));
          }

          return result;
        }();
      });
    } // Removes all event listeners and cancels all files in the queue or being processed.

  }, {
    key: "disable",
    value: function disable() {
      var _this4 = this;

      this.clickableElements.forEach(function (element) {
        return element.classList.remove("dz-clickable");
      });
      this.removeEventListeners();
      this.disabled = true;
      return this.files.map(function (file) {
        return _this4.cancelUpload(file);
      });
    }
  }, {
    key: "enable",
    value: function enable() {
      delete this.disabled;
      this.clickableElements.forEach(function (element) {
        return element.classList.add("dz-clickable");
      });
      return this.setupEventListeners();
    } // Returns a nicely formatted filesize

  }, {
    key: "filesize",
    value: function filesize(size) {
      var selectedSize = 0;
      var selectedUnit = "b";

      if (size > 0) {
        var units = ['tb', 'gb', 'mb', 'kb', 'b'];

        for (var i = 0; i < units.length; i++) {
          var unit = units[i];
          var cutoff = Math.pow(this.options.filesizeBase, 4 - i) / 10;

          if (size >= cutoff) {
            selectedSize = size / Math.pow(this.options.filesizeBase, 4 - i);
            selectedUnit = unit;
            break;
          }
        }

        selectedSize = Math.round(10 * selectedSize) / 10; // Cutting of digits
      }

      return "<strong>".concat(selectedSize, "</strong> ").concat(this.options.dictFileSizeUnits[selectedUnit]);
    } // Adds or removes the `dz-max-files-reached` class from the form.

  }, {
    key: "_updateMaxFilesReachedClass",
    value: function _updateMaxFilesReachedClass() {
      if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
        if (this.getAcceptedFiles().length === this.options.maxFiles) {
          this.emit('maxfilesreached', this.files);
        }

        return this.element.classList.add("dz-max-files-reached");
      } else {
        return this.element.classList.remove("dz-max-files-reached");
      }
    }
  }, {
    key: "drop",
    value: function drop(e) {
      if (!e.dataTransfer) {
        return;
      }

      this.emit("drop", e); // Convert the FileList to an Array
      // This is necessary for IE11

      var files = [];

      for (var i = 0; i < e.dataTransfer.files.length; i++) {
        files[i] = e.dataTransfer.files[i];
      } // Even if it's a folder, files.length will contain the folders.


      if (files.length) {
        var items = e.dataTransfer.items;

        if (items && items.length && items[0].webkitGetAsEntry != null) {
          // The browser supports dropping of folders, so handle items instead of files
          this._addFilesFromItems(items);
        } else {
          this.handleFiles(files);
        }
      }

      this.emit("addedfiles", files);
    }
  }, {
    key: "paste",
    value: function paste(e) {
      if (__guard__(e != null ? e.clipboardData : undefined, function (x) {
        return x.items;
      }) == null) {
        return;
      }

      this.emit("paste", e);
      var items = e.clipboardData.items;

      if (items.length) {
        return this._addFilesFromItems(items);
      }
    }
  }, {
    key: "handleFiles",
    value: function handleFiles(files) {
      var _iteratorNormalCompletion13 = true;
      var _didIteratorError13 = false;
      var _iteratorError13 = undefined;

      try {
        for (var _iterator13 = files[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
          var file = _step13.value;
          this.addFile(file);
        }
      } catch (err) {
        _didIteratorError13 = true;
        _iteratorError13 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
            _iterator13["return"]();
          }
        } finally {
          if (_didIteratorError13) {
            throw _iteratorError13;
          }
        }
      }
    } // When a folder is dropped (or files are pasted), items must be handled
    // instead of files.

  }, {
    key: "_addFilesFromItems",
    value: function _addFilesFromItems(items) {
      var _this5 = this;

      return function () {
        var result = [];
        var _iteratorNormalCompletion14 = true;
        var _didIteratorError14 = false;
        var _iteratorError14 = undefined;

        try {
          for (var _iterator14 = items[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
            var item = _step14.value;
            var entry;

            if (item.webkitGetAsEntry != null && (entry = item.webkitGetAsEntry())) {
              if (entry.isFile) {
                result.push(_this5.addFile(item.getAsFile()));
              } else if (entry.isDirectory) {
                // Append all files from that directory to files
                result.push(_this5._addFilesFromDirectory(entry, entry.name));
              } else {
                result.push(undefined);
              }
            } else if (item.getAsFile != null) {
              if (item.kind == null || item.kind === "file") {
                result.push(_this5.addFile(item.getAsFile()));
              } else {
                result.push(undefined);
              }
            } else {
              result.push(undefined);
            }
          }
        } catch (err) {
          _didIteratorError14 = true;
          _iteratorError14 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
              _iterator14["return"]();
            }
          } finally {
            if (_didIteratorError14) {
              throw _iteratorError14;
            }
          }
        }

        return result;
      }();
    } // Goes through the directory, and adds each file it finds recursively

  }, {
    key: "_addFilesFromDirectory",
    value: function _addFilesFromDirectory(directory, path) {
      var _this6 = this;

      var dirReader = directory.createReader();

      var errorHandler = function errorHandler(error) {
        return __guardMethod__(console, 'log', function (o) {
          return o.log(error);
        });
      };

      var readEntries = function readEntries() {
        return dirReader.readEntries(function (entries) {
          if (entries.length > 0) {
            var _iteratorNormalCompletion15 = true;
            var _didIteratorError15 = false;
            var _iteratorError15 = undefined;

            try {
              for (var _iterator15 = entries[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                var entry = _step15.value;

                if (entry.isFile) {
                  entry.file(function (file) {
                    if (_this6.options.ignoreHiddenFiles && file.name.substring(0, 1) === '.') {
                      return;
                    }

                    file.fullPath = "".concat(path, "/").concat(file.name);
                    return _this6.addFile(file);
                  });
                } else if (entry.isDirectory) {
                  _this6._addFilesFromDirectory(entry, "".concat(path, "/").concat(entry.name));
                }
              } // Recursively call readEntries() again, since browser only handle
              // the first 100 entries.
              // See: https://developer.mozilla.org/en-US/docs/Web/API/DirectoryReader#readEntries

            } catch (err) {
              _didIteratorError15 = true;
              _iteratorError15 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
                  _iterator15["return"]();
                }
              } finally {
                if (_didIteratorError15) {
                  throw _iteratorError15;
                }
              }
            }

            readEntries();
          }

          return null;
        }, errorHandler);
      };

      return readEntries();
    } // If `done()` is called without argument the file is accepted
    // If you call it with an error message, the file is rejected
    // (This allows for asynchronous validation)
    //
    // This function checks the filesize, and if the file.type passes the
    // `acceptedFiles` check.

  }, {
    key: "accept",
    value: function accept(file, done) {
      if (this.options.maxFilesize && file.size > this.options.maxFilesize * 1024 * 1024) {
        done(this.options.dictFileTooBig.replace("{{filesize}}", Math.round(file.size / 1024 / 10.24) / 100).replace("{{maxFilesize}}", this.options.maxFilesize));
      } else if (!Dropzone.isValidFile(file, this.options.acceptedFiles)) {
        done(this.options.dictInvalidFileType);
      } else if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
        done(this.options.dictMaxFilesExceeded.replace("{{maxFiles}}", this.options.maxFiles));
        this.emit("maxfilesexceeded", file);
      } else {
        this.options.accept.call(this, file, done);
      }
    }
  }, {
    key: "addFile",
    value: function addFile(file) {
      var _this7 = this;

      file.upload = {
        uuid: Dropzone.uuidv4(),
        progress: 0,
        // Setting the total upload size to file.size for the beginning
        // It's actual different than the size to be transmitted.
        total: file.size,
        bytesSent: 0,
        filename: this._renameFile(file) // Not setting chunking information here, because the acutal data — and
        // thus the chunks — might change if `options.transformFile` is set
        // and does something to the data.

      };
      this.files.push(file);
      file.status = Dropzone.ADDED;
      this.emit("addedfile", file);

      this._enqueueThumbnail(file);

      this.accept(file, function (error) {
        if (error) {
          file.accepted = false;

          _this7._errorProcessing([file], error); // Will set the file.status

        } else {
          file.accepted = true;

          if (_this7.options.autoQueue) {
            _this7.enqueueFile(file);
          } // Will set .accepted = true

        }

        _this7._updateMaxFilesReachedClass();
      });
    } // Wrapper for enqueueFile

  }, {
    key: "enqueueFiles",
    value: function enqueueFiles(files) {
      var _iteratorNormalCompletion16 = true;
      var _didIteratorError16 = false;
      var _iteratorError16 = undefined;

      try {
        for (var _iterator16 = files[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
          var file = _step16.value;
          this.enqueueFile(file);
        }
      } catch (err) {
        _didIteratorError16 = true;
        _iteratorError16 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
            _iterator16["return"]();
          }
        } finally {
          if (_didIteratorError16) {
            throw _iteratorError16;
          }
        }
      }

      return null;
    }
  }, {
    key: "enqueueFile",
    value: function enqueueFile(file) {
      var _this8 = this;

      if (file.status === Dropzone.ADDED && file.accepted === true) {
        file.status = Dropzone.QUEUED;

        if (this.options.autoProcessQueue) {
          return setTimeout(function () {
            return _this8.processQueue();
          }, 0); // Deferring the call
        }
      } else {
        throw new Error("This file can't be queued because it has already been processed or was rejected.");
      }
    }
  }, {
    key: "_enqueueThumbnail",
    value: function _enqueueThumbnail(file) {
      var _this9 = this;

      if (this.options.createImageThumbnails && file.type.match(/image.*/) && file.size <= this.options.maxThumbnailFilesize * 1024 * 1024) {
        this._thumbnailQueue.push(file);

        return setTimeout(function () {
          return _this9._processThumbnailQueue();
        }, 0); // Deferring the call
      }
    }
  }, {
    key: "_processThumbnailQueue",
    value: function _processThumbnailQueue() {
      var _this10 = this;

      if (this._processingThumbnail || this._thumbnailQueue.length === 0) {
        return;
      }

      this._processingThumbnail = true;

      var file = this._thumbnailQueue.shift();

      return this.createThumbnail(file, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, true, function (dataUrl) {
        _this10.emit("thumbnail", file, dataUrl);

        _this10._processingThumbnail = false;
        return _this10._processThumbnailQueue();
      });
    } // Can be called by the user to remove a file

  }, {
    key: "removeFile",
    value: function removeFile(file) {
      if (file.status === Dropzone.UPLOADING) {
        this.cancelUpload(file);
      }

      this.files = without(this.files, file);
      this.emit("removedfile", file);

      if (this.files.length === 0) {
        return this.emit("reset");
      }
    } // Removes all files that aren't currently processed from the list

  }, {
    key: "removeAllFiles",
    value: function removeAllFiles(cancelIfNecessary) {
      // Create a copy of files since removeFile() changes the @files array.
      if (cancelIfNecessary == null) {
        cancelIfNecessary = false;
      }

      var _iteratorNormalCompletion17 = true;
      var _didIteratorError17 = false;
      var _iteratorError17 = undefined;

      try {
        for (var _iterator17 = this.files.slice()[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
          var file = _step17.value;

          if (file.status !== Dropzone.UPLOADING || cancelIfNecessary) {
            this.removeFile(file);
          }
        }
      } catch (err) {
        _didIteratorError17 = true;
        _iteratorError17 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion17 && _iterator17["return"] != null) {
            _iterator17["return"]();
          }
        } finally {
          if (_didIteratorError17) {
            throw _iteratorError17;
          }
        }
      }

      return null;
    } // Resizes an image before it gets sent to the server. This function is the default behavior of
    // `options.transformFile` if `resizeWidth` or `resizeHeight` are set. The callback is invoked with
    // the resized blob.

  }, {
    key: "resizeImage",
    value: function resizeImage(file, width, height, resizeMethod, callback) {
      var _this11 = this;

      return this.createThumbnail(file, width, height, resizeMethod, true, function (dataUrl, canvas) {
        if (canvas == null) {
          // The image has not been resized
          return callback(file);
        } else {
          var resizeMimeType = _this11.options.resizeMimeType;

          if (resizeMimeType == null) {
            resizeMimeType = file.type;
          }

          var resizedDataURL = canvas.toDataURL(resizeMimeType, _this11.options.resizeQuality);

          if (resizeMimeType === 'image/jpeg' || resizeMimeType === 'image/jpg') {
            // Now add the original EXIF information
            resizedDataURL = ExifRestore.restore(file.dataURL, resizedDataURL);
          }

          return callback(Dropzone.dataURItoBlob(resizedDataURL));
        }
      });
    }
  }, {
    key: "createThumbnail",
    value: function createThumbnail(file, width, height, resizeMethod, fixOrientation, callback) {
      var _this12 = this;

      var fileReader = new FileReader();

      fileReader.onload = function () {
        file.dataURL = fileReader.result; // Don't bother creating a thumbnail for SVG images since they're vector

        if (file.type === "image/svg+xml") {
          if (callback != null) {
            callback(fileReader.result);
          }

          return;
        }

        _this12.createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback);
      };

      fileReader.readAsDataURL(file);
    } // `mockFile` needs to have these attributes:
    // 
    //     { name: 'name', size: 12345, imageUrl: '' }
    //
    // `callback` will be invoked when the image has been downloaded and displayed.
    // `crossOrigin` will be added to the `img` tag when accessing the file.

  }, {
    key: "displayExistingFile",
    value: function displayExistingFile(mockFile, imageUrl, callback, crossOrigin) {
      var _this13 = this;

      var resizeThumbnail = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      this.emit("addedfile", mockFile);
      this.emit("complete", mockFile);

      if (!resizeThumbnail) {
        this.emit("thumbnail", mockFile, imageUrl);
        if (callback) callback();
      } else {
        var onDone = function onDone(thumbnail) {
          _this13.emit('thumbnail', mockFile, thumbnail);

          if (callback) callback();
        };

        mockFile.dataURL = imageUrl;
        this.createThumbnailFromUrl(mockFile, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.resizeMethod, this.options.fixOrientation, onDone, crossOrigin);
      }
    }
  }, {
    key: "createThumbnailFromUrl",
    value: function createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback, crossOrigin) {
      var _this14 = this;

      // Not using `new Image` here because of a bug in latest Chrome versions.
      // See https://github.com/enyo/dropzone/pull/226
      var img = document.createElement("img");

      if (crossOrigin) {
        img.crossOrigin = crossOrigin;
      }

      img.onload = function () {
        var loadExif = function loadExif(callback) {
          return callback(1);
        };

        if (typeof EXIF !== 'undefined' && EXIF !== null && fixOrientation) {
          loadExif = function loadExif(callback) {
            return EXIF.getData(img, function () {
              return callback(EXIF.getTag(this, 'Orientation'));
            });
          };
        }

        return loadExif(function (orientation) {
          file.width = img.width;
          file.height = img.height;

          var resizeInfo = _this14.options.resize.call(_this14, file, width, height, resizeMethod);

          var canvas = document.createElement("canvas");
          var ctx = canvas.getContext("2d");
          canvas.width = resizeInfo.trgWidth;
          canvas.height = resizeInfo.trgHeight;

          if (orientation > 4) {
            canvas.width = resizeInfo.trgHeight;
            canvas.height = resizeInfo.trgWidth;
          }

          switch (orientation) {
            case 2:
              // horizontal flip
              ctx.translate(canvas.width, 0);
              ctx.scale(-1, 1);
              break;

            case 3:
              // 180° rotate left
              ctx.translate(canvas.width, canvas.height);
              ctx.rotate(Math.PI);
              break;

            case 4:
              // vertical flip
              ctx.translate(0, canvas.height);
              ctx.scale(1, -1);
              break;

            case 5:
              // vertical flip + 90 rotate right
              ctx.rotate(0.5 * Math.PI);
              ctx.scale(1, -1);
              break;

            case 6:
              // 90° rotate right
              ctx.rotate(0.5 * Math.PI);
              ctx.translate(0, -canvas.width);
              break;

            case 7:
              // horizontal flip + 90 rotate right
              ctx.rotate(0.5 * Math.PI);
              ctx.translate(canvas.height, -canvas.width);
              ctx.scale(-1, 1);
              break;

            case 8:
              // 90° rotate left
              ctx.rotate(-0.5 * Math.PI);
              ctx.translate(-canvas.height, 0);
              break;
          } // This is a bugfix for iOS' scaling bug.


          drawImageIOSFix(ctx, img, resizeInfo.srcX != null ? resizeInfo.srcX : 0, resizeInfo.srcY != null ? resizeInfo.srcY : 0, resizeInfo.srcWidth, resizeInfo.srcHeight, resizeInfo.trgX != null ? resizeInfo.trgX : 0, resizeInfo.trgY != null ? resizeInfo.trgY : 0, resizeInfo.trgWidth, resizeInfo.trgHeight);
          var thumbnail = canvas.toDataURL("image/png");

          if (callback != null) {
            return callback(thumbnail, canvas);
          }
        });
      };

      if (callback != null) {
        img.onerror = callback;
      }

      return img.src = file.dataURL;
    } // Goes through the queue and processes files if there aren't too many already.

  }, {
    key: "processQueue",
    value: function processQueue() {
      var parallelUploads = this.options.parallelUploads;
      var processingLength = this.getUploadingFiles().length;
      var i = processingLength; // There are already at least as many files uploading than should be

      if (processingLength >= parallelUploads) {
        return;
      }

      var queuedFiles = this.getQueuedFiles();

      if (!(queuedFiles.length > 0)) {
        return;
      }

      if (this.options.uploadMultiple) {
        // The files should be uploaded in one request
        return this.processFiles(queuedFiles.slice(0, parallelUploads - processingLength));
      } else {
        while (i < parallelUploads) {
          if (!queuedFiles.length) {
            return;
          } // Nothing left to process


          this.processFile(queuedFiles.shift());
          i++;
        }
      }
    } // Wrapper for `processFiles`

  }, {
    key: "processFile",
    value: function processFile(file) {
      return this.processFiles([file]);
    } // Loads the file, then calls finishedLoading()

  }, {
    key: "processFiles",
    value: function processFiles(files) {
      var _iteratorNormalCompletion18 = true;
      var _didIteratorError18 = false;
      var _iteratorError18 = undefined;

      try {
        for (var _iterator18 = files[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
          var file = _step18.value;
          file.processing = true; // Backwards compatibility

          file.status = Dropzone.UPLOADING;
          this.emit("processing", file);
        }
      } catch (err) {
        _didIteratorError18 = true;
        _iteratorError18 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion18 && _iterator18["return"] != null) {
            _iterator18["return"]();
          }
        } finally {
          if (_didIteratorError18) {
            throw _iteratorError18;
          }
        }
      }

      if (this.options.uploadMultiple) {
        this.emit("processingmultiple", files);
      }

      return this.uploadFiles(files);
    }
  }, {
    key: "_getFilesWithXhr",
    value: function _getFilesWithXhr(xhr) {
      var files;
      return files = this.files.filter(function (file) {
        return file.xhr === xhr;
      }).map(function (file) {
        return file;
      });
    } // Cancels the file upload and sets the status to CANCELED
    // **if** the file is actually being uploaded.
    // If it's still in the queue, the file is being removed from it and the status
    // set to CANCELED.

  }, {
    key: "cancelUpload",
    value: function cancelUpload(file) {
      if (file.status === Dropzone.UPLOADING) {
        var groupedFiles = this._getFilesWithXhr(file.xhr);

        var _iteratorNormalCompletion19 = true;
        var _didIteratorError19 = false;
        var _iteratorError19 = undefined;

        try {
          for (var _iterator19 = groupedFiles[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
            var groupedFile = _step19.value;
            groupedFile.status = Dropzone.CANCELED;
          }
        } catch (err) {
          _didIteratorError19 = true;
          _iteratorError19 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion19 && _iterator19["return"] != null) {
              _iterator19["return"]();
            }
          } finally {
            if (_didIteratorError19) {
              throw _iteratorError19;
            }
          }
        }

        if (typeof file.xhr !== 'undefined') {
          file.xhr.abort();
        }

        var _iteratorNormalCompletion20 = true;
        var _didIteratorError20 = false;
        var _iteratorError20 = undefined;

        try {
          for (var _iterator20 = groupedFiles[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
            var _groupedFile = _step20.value;
            this.emit("canceled", _groupedFile);
          }
        } catch (err) {
          _didIteratorError20 = true;
          _iteratorError20 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion20 && _iterator20["return"] != null) {
              _iterator20["return"]();
            }
          } finally {
            if (_didIteratorError20) {
              throw _iteratorError20;
            }
          }
        }

        if (this.options.uploadMultiple) {
          this.emit("canceledmultiple", groupedFiles);
        }
      } else if (file.status === Dropzone.ADDED || file.status === Dropzone.QUEUED) {
        file.status = Dropzone.CANCELED;
        this.emit("canceled", file);

        if (this.options.uploadMultiple) {
          this.emit("canceledmultiple", [file]);
        }
      }

      if (this.options.autoProcessQueue) {
        return this.processQueue();
      }
    }
  }, {
    key: "resolveOption",
    value: function resolveOption(option) {
      if (typeof option === 'function') {
        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }

        return option.apply(this, args);
      }

      return option;
    }
  }, {
    key: "uploadFile",
    value: function uploadFile(file) {
      return this.uploadFiles([file]);
    }
  }, {
    key: "uploadFiles",
    value: function uploadFiles(files) {
      var _this15 = this;

      this._transformFiles(files, function (transformedFiles) {
        if (_this15.options.chunking) {
          // Chunking is not allowed to be used with `uploadMultiple` so we know
          // that there is only __one__file.
          var transformedFile = transformedFiles[0];
          files[0].upload.chunked = _this15.options.chunking && (_this15.options.forceChunking || transformedFile.size > _this15.options.chunkSize);
          files[0].upload.totalChunkCount = Math.ceil(transformedFile.size / _this15.options.chunkSize);
        }

        if (files[0].upload.chunked) {
          // This file should be sent in chunks!
          // If the chunking option is set, we **know** that there can only be **one** file, since
          // uploadMultiple is not allowed with this option.
          var file = files[0];
          var _transformedFile = transformedFiles[0];
          var startedChunkCount = 0;
          file.upload.chunks = [];

          var handleNextChunk = function handleNextChunk() {
            var chunkIndex = 0; // Find the next item in file.upload.chunks that is not defined yet.

            while (file.upload.chunks[chunkIndex] !== undefined) {
              chunkIndex++;
            } // This means, that all chunks have already been started.


            if (chunkIndex >= file.upload.totalChunkCount) return;
            startedChunkCount++;
            var start = chunkIndex * _this15.options.chunkSize;
            var end = Math.min(start + _this15.options.chunkSize, file.size);
            var dataBlock = {
              name: _this15._getParamName(0),
              data: _transformedFile.webkitSlice ? _transformedFile.webkitSlice(start, end) : _transformedFile.slice(start, end),
              filename: file.upload.filename,
              chunkIndex: chunkIndex
            };
            file.upload.chunks[chunkIndex] = {
              file: file,
              index: chunkIndex,
              dataBlock: dataBlock,
              // In case we want to retry.
              status: Dropzone.UPLOADING,
              progress: 0,
              retries: 0 // The number of times this block has been retried.

            };

            _this15._uploadData(files, [dataBlock]);
          };

          file.upload.finishedChunkUpload = function (chunk) {
            var allFinished = true;
            chunk.status = Dropzone.SUCCESS; // Clear the data from the chunk

            chunk.dataBlock = null; // Leaving this reference to xhr intact here will cause memory leaks in some browsers

            chunk.xhr = null;

            for (var i = 0; i < file.upload.totalChunkCount; i++) {
              if (file.upload.chunks[i] === undefined) {
                return handleNextChunk();
              }

              if (file.upload.chunks[i].status !== Dropzone.SUCCESS) {
                allFinished = false;
              }
            }

            if (allFinished) {
              _this15.options.chunksUploaded(file, function () {
                _this15._finished(files, '', null);
              });
            }
          };

          if (_this15.options.parallelChunkUploads) {
            for (var i = 0; i < file.upload.totalChunkCount; i++) {
              handleNextChunk();
            }
          } else {
            handleNextChunk();
          }
        } else {
          var dataBlocks = [];

          for (var _i3 = 0; _i3 < files.length; _i3++) {
            dataBlocks[_i3] = {
              name: _this15._getParamName(_i3),
              data: transformedFiles[_i3],
              filename: files[_i3].upload.filename
            };
          }

          _this15._uploadData(files, dataBlocks);
        }
      });
    } /// Returns the right chunk for given file and xhr

  }, {
    key: "_getChunk",
    value: function _getChunk(file, xhr) {
      for (var i = 0; i < file.upload.totalChunkCount; i++) {
        if (file.upload.chunks[i] !== undefined && file.upload.chunks[i].xhr === xhr) {
          return file.upload.chunks[i];
        }
      }
    } // This function actually uploads the file(s) to the server.
    // If dataBlocks contains the actual data to upload (meaning, that this could either be transformed
    // files, or individual chunks for chunked upload).

  }, {
    key: "_uploadData",
    value: function _uploadData(files, dataBlocks) {
      var _this16 = this;

      var xhr = new XMLHttpRequest(); // Put the xhr object in the file objects to be able to reference it later.

      var _iteratorNormalCompletion21 = true;
      var _didIteratorError21 = false;
      var _iteratorError21 = undefined;

      try {
        for (var _iterator21 = files[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
          var file = _step21.value;
          file.xhr = xhr;
        }
      } catch (err) {
        _didIteratorError21 = true;
        _iteratorError21 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion21 && _iterator21["return"] != null) {
            _iterator21["return"]();
          }
        } finally {
          if (_didIteratorError21) {
            throw _iteratorError21;
          }
        }
      }

      if (files[0].upload.chunked) {
        // Put the xhr object in the right chunk object, so it can be associated later, and found with _getChunk
        files[0].upload.chunks[dataBlocks[0].chunkIndex].xhr = xhr;
      }

      var method = this.resolveOption(this.options.method, files);
      var url = this.resolveOption(this.options.url, files);
      xhr.open(method, url, true); // Setting the timeout after open because of IE11 issue: https://gitlab.com/meno/dropzone/issues/8

      xhr.timeout = this.resolveOption(this.options.timeout, files); // Has to be after `.open()`. See https://github.com/enyo/dropzone/issues/179

      xhr.withCredentials = !!this.options.withCredentials;

      xhr.onload = function (e) {
        _this16._finishedUploading(files, xhr, e);
      };

      xhr.ontimeout = function () {
        _this16._handleUploadError(files, xhr, "Request timedout after ".concat(_this16.options.timeout, " seconds"));
      };

      xhr.onerror = function () {
        _this16._handleUploadError(files, xhr);
      }; // Some browsers do not have the .upload property


      var progressObj = xhr.upload != null ? xhr.upload : xhr;

      progressObj.onprogress = function (e) {
        return _this16._updateFilesUploadProgress(files, xhr, e);
      };

      var headers = {
        "Accept": "application/json",
        "Cache-Control": "no-cache",
        "X-Requested-With": "XMLHttpRequest"
      };

      if (this.options.headers) {
        Dropzone.extend(headers, this.options.headers);
      }

      for (var headerName in headers) {
        var headerValue = headers[headerName];

        if (headerValue) {
          xhr.setRequestHeader(headerName, headerValue);
        }
      }

      var formData = new FormData(); // Adding all @options parameters

      if (this.options.params) {
        var additionalParams = this.options.params;

        if (typeof additionalParams === 'function') {
          additionalParams = additionalParams.call(this, files, xhr, files[0].upload.chunked ? this._getChunk(files[0], xhr) : null);
        }

        for (var key in additionalParams) {
          var value = additionalParams[key];
          formData.append(key, value);
        }
      } // Let the user add additional data if necessary


      var _iteratorNormalCompletion22 = true;
      var _didIteratorError22 = false;
      var _iteratorError22 = undefined;

      try {
        for (var _iterator22 = files[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
          var _file = _step22.value;
          this.emit("sending", _file, xhr, formData);
        }
      } catch (err) {
        _didIteratorError22 = true;
        _iteratorError22 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion22 && _iterator22["return"] != null) {
            _iterator22["return"]();
          }
        } finally {
          if (_didIteratorError22) {
            throw _iteratorError22;
          }
        }
      }

      if (this.options.uploadMultiple) {
        this.emit("sendingmultiple", files, xhr, formData);
      }

      this._addFormElementData(formData); // Finally add the files
      // Has to be last because some servers (eg: S3) expect the file to be the last parameter


      for (var i = 0; i < dataBlocks.length; i++) {
        var dataBlock = dataBlocks[i];
        formData.append(dataBlock.name, dataBlock.data, dataBlock.filename);
      }

      this.submitRequest(xhr, formData, files);
    } // Transforms all files with this.options.transformFile and invokes done with the transformed files when done.

  }, {
    key: "_transformFiles",
    value: function _transformFiles(files, done) {
      var _this17 = this;

      var transformedFiles = []; // Clumsy way of handling asynchronous calls, until I get to add a proper Future library.

      var doneCounter = 0;

      var _loop = function _loop(i) {
        _this17.options.transformFile.call(_this17, files[i], function (transformedFile) {
          transformedFiles[i] = transformedFile;

          if (++doneCounter === files.length) {
            done(transformedFiles);
          }
        });
      };

      for (var i = 0; i < files.length; i++) {
        _loop(i);
      }
    } // Takes care of adding other input elements of the form to the AJAX request

  }, {
    key: "_addFormElementData",
    value: function _addFormElementData(formData) {
      // Take care of other input elements
      if (this.element.tagName === "FORM") {
        var _iteratorNormalCompletion23 = true;
        var _didIteratorError23 = false;
        var _iteratorError23 = undefined;

        try {
          for (var _iterator23 = this.element.querySelectorAll("input, textarea, select, button")[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
            var input = _step23.value;
            var inputName = input.getAttribute("name");
            var inputType = input.getAttribute("type");
            if (inputType) inputType = inputType.toLowerCase(); // If the input doesn't have a name, we can't use it.

            if (typeof inputName === 'undefined' || inputName === null) continue;

            if (input.tagName === "SELECT" && input.hasAttribute("multiple")) {
              // Possibly multiple values
              var _iteratorNormalCompletion24 = true;
              var _didIteratorError24 = false;
              var _iteratorError24 = undefined;

              try {
                for (var _iterator24 = input.options[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
                  var option = _step24.value;

                  if (option.selected) {
                    formData.append(inputName, option.value);
                  }
                }
              } catch (err) {
                _didIteratorError24 = true;
                _iteratorError24 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion24 && _iterator24["return"] != null) {
                    _iterator24["return"]();
                  }
                } finally {
                  if (_didIteratorError24) {
                    throw _iteratorError24;
                  }
                }
              }
            } else if (!inputType || inputType !== "checkbox" && inputType !== "radio" || input.checked) {
              formData.append(inputName, input.value);
            }
          }
        } catch (err) {
          _didIteratorError23 = true;
          _iteratorError23 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion23 && _iterator23["return"] != null) {
              _iterator23["return"]();
            }
          } finally {
            if (_didIteratorError23) {
              throw _iteratorError23;
            }
          }
        }
      }
    } // Invoked when there is new progress information about given files.
    // If e is not provided, it is assumed that the upload is finished.

  }, {
    key: "_updateFilesUploadProgress",
    value: function _updateFilesUploadProgress(files, xhr, e) {
      var progress;

      if (typeof e !== 'undefined') {
        progress = 100 * e.loaded / e.total;

        if (files[0].upload.chunked) {
          var file = files[0]; // Since this is a chunked upload, we need to update the appropriate chunk progress.

          var chunk = this._getChunk(file, xhr);

          chunk.progress = progress;
          chunk.total = e.total;
          chunk.bytesSent = e.loaded;
          var fileProgress = 0,
              fileTotal,
              fileBytesSent;
          file.upload.progress = 0;
          file.upload.total = 0;
          file.upload.bytesSent = 0;

          for (var i = 0; i < file.upload.totalChunkCount; i++) {
            if (file.upload.chunks[i] !== undefined && file.upload.chunks[i].progress !== undefined) {
              file.upload.progress += file.upload.chunks[i].progress;
              file.upload.total += file.upload.chunks[i].total;
              file.upload.bytesSent += file.upload.chunks[i].bytesSent;
            }
          }

          file.upload.progress = file.upload.progress / file.upload.totalChunkCount;
        } else {
          var _iteratorNormalCompletion25 = true;
          var _didIteratorError25 = false;
          var _iteratorError25 = undefined;

          try {
            for (var _iterator25 = files[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
              var _file2 = _step25.value;
              _file2.upload.progress = progress;
              _file2.upload.total = e.total;
              _file2.upload.bytesSent = e.loaded;
            }
          } catch (err) {
            _didIteratorError25 = true;
            _iteratorError25 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion25 && _iterator25["return"] != null) {
                _iterator25["return"]();
              }
            } finally {
              if (_didIteratorError25) {
                throw _iteratorError25;
              }
            }
          }
        }

        var _iteratorNormalCompletion26 = true;
        var _didIteratorError26 = false;
        var _iteratorError26 = undefined;

        try {
          for (var _iterator26 = files[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
            var _file3 = _step26.value;
            this.emit("uploadprogress", _file3, _file3.upload.progress, _file3.upload.bytesSent);
          }
        } catch (err) {
          _didIteratorError26 = true;
          _iteratorError26 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion26 && _iterator26["return"] != null) {
              _iterator26["return"]();
            }
          } finally {
            if (_didIteratorError26) {
              throw _iteratorError26;
            }
          }
        }
      } else {
        // Called when the file finished uploading
        var allFilesFinished = true;
        progress = 100;
        var _iteratorNormalCompletion27 = true;
        var _didIteratorError27 = false;
        var _iteratorError27 = undefined;

        try {
          for (var _iterator27 = files[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
            var _file4 = _step27.value;

            if (_file4.upload.progress !== 100 || _file4.upload.bytesSent !== _file4.upload.total) {
              allFilesFinished = false;
            }

            _file4.upload.progress = progress;
            _file4.upload.bytesSent = _file4.upload.total;
          } // Nothing to do, all files already at 100%

        } catch (err) {
          _didIteratorError27 = true;
          _iteratorError27 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion27 && _iterator27["return"] != null) {
              _iterator27["return"]();
            }
          } finally {
            if (_didIteratorError27) {
              throw _iteratorError27;
            }
          }
        }

        if (allFilesFinished) {
          return;
        }

        var _iteratorNormalCompletion28 = true;
        var _didIteratorError28 = false;
        var _iteratorError28 = undefined;

        try {
          for (var _iterator28 = files[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
            var _file5 = _step28.value;
            this.emit("uploadprogress", _file5, progress, _file5.upload.bytesSent);
          }
        } catch (err) {
          _didIteratorError28 = true;
          _iteratorError28 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion28 && _iterator28["return"] != null) {
              _iterator28["return"]();
            }
          } finally {
            if (_didIteratorError28) {
              throw _iteratorError28;
            }
          }
        }
      }
    }
  }, {
    key: "_finishedUploading",
    value: function _finishedUploading(files, xhr, e) {
      var response;

      if (files[0].status === Dropzone.CANCELED) {
        return;
      }

      if (xhr.readyState !== 4) {
        return;
      }

      if (xhr.responseType !== 'arraybuffer' && xhr.responseType !== 'blob') {
        response = xhr.responseText;

        if (xhr.getResponseHeader("content-type") && ~xhr.getResponseHeader("content-type").indexOf("application/json")) {
          try {
            response = JSON.parse(response);
          } catch (error) {
            e = error;
            response = "Invalid JSON response from server.";
          }
        }
      }

      this._updateFilesUploadProgress(files);

      if (!(200 <= xhr.status && xhr.status < 300)) {
        this._handleUploadError(files, xhr, response);
      } else {
        if (files[0].upload.chunked) {
          files[0].upload.finishedChunkUpload(this._getChunk(files[0], xhr));
        } else {
          this._finished(files, response, e);
        }
      }
    }
  }, {
    key: "_handleUploadError",
    value: function _handleUploadError(files, xhr, response) {
      if (files[0].status === Dropzone.CANCELED) {
        return;
      }

      if (files[0].upload.chunked && this.options.retryChunks) {
        var chunk = this._getChunk(files[0], xhr);

        if (chunk.retries++ < this.options.retryChunksLimit) {
          this._uploadData(files, [chunk.dataBlock]);

          return;
        } else {
          console.warn('Retried this chunk too often. Giving up.');
        }
      }

      this._errorProcessing(files, response || this.options.dictResponseError.replace("{{statusCode}}", xhr.status), xhr);
    }
  }, {
    key: "submitRequest",
    value: function submitRequest(xhr, formData, files) {
      xhr.send(formData);
    } // Called internally when processing is finished.
    // Individual callbacks have to be called in the appropriate sections.

  }, {
    key: "_finished",
    value: function _finished(files, responseText, e) {
      var _iteratorNormalCompletion29 = true;
      var _didIteratorError29 = false;
      var _iteratorError29 = undefined;

      try {
        for (var _iterator29 = files[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {
          var file = _step29.value;
          file.status = Dropzone.SUCCESS;
          this.emit("success", file, responseText, e);
          this.emit("complete", file);
        }
      } catch (err) {
        _didIteratorError29 = true;
        _iteratorError29 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion29 && _iterator29["return"] != null) {
            _iterator29["return"]();
          }
        } finally {
          if (_didIteratorError29) {
            throw _iteratorError29;
          }
        }
      }

      if (this.options.uploadMultiple) {
        this.emit("successmultiple", files, responseText, e);
        this.emit("completemultiple", files);
      }

      if (this.options.autoProcessQueue) {
        return this.processQueue();
      }
    } // Called internally when processing is finished.
    // Individual callbacks have to be called in the appropriate sections.

  }, {
    key: "_errorProcessing",
    value: function _errorProcessing(files, message, xhr) {
      var _iteratorNormalCompletion30 = true;
      var _didIteratorError30 = false;
      var _iteratorError30 = undefined;

      try {
        for (var _iterator30 = files[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
          var file = _step30.value;
          file.status = Dropzone.ERROR;
          this.emit("error", file, message, xhr);
          this.emit("complete", file);
        }
      } catch (err) {
        _didIteratorError30 = true;
        _iteratorError30 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion30 && _iterator30["return"] != null) {
            _iterator30["return"]();
          }
        } finally {
          if (_didIteratorError30) {
            throw _iteratorError30;
          }
        }
      }

      if (this.options.uploadMultiple) {
        this.emit("errormultiple", files, message, xhr);
        this.emit("completemultiple", files);
      }

      if (this.options.autoProcessQueue) {
        return this.processQueue();
      }
    }
  }], [{
    key: "uuidv4",
    value: function uuidv4() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0,
            v = c === 'x' ? r : r & 0x3 | 0x8;
        return v.toString(16);
      });
    }
  }]);

  return Dropzone;
}(Emitter);

Dropzone.initClass();
Dropzone.version = "5.7.0"; // This is a map of options for your different dropzones. Add configurations
// to this object for your different dropzone elemens.
//
// Example:
//
//     Dropzone.options.myDropzoneElementId = { maxFilesize: 1 };
//
// To disable autoDiscover for a specific element, you can set `false` as an option:
//
//     Dropzone.options.myDisabledElementId = false;
//
// And in html:
//
//     <form action="/upload" id="my-dropzone-element-id" class="dropzone"></form>

Dropzone.options = {}; // Returns the options for an element or undefined if none available.

Dropzone.optionsForElement = function (element) {
  // Get the `Dropzone.options.elementId` for this element if it exists
  if (element.getAttribute("id")) {
    return Dropzone.options[camelize(element.getAttribute("id"))];
  } else {
    return undefined;
  }
}; // Holds a list of all dropzone instances


Dropzone.instances = []; // Returns the dropzone for given element if any

Dropzone.forElement = function (element) {
  if (typeof element === "string") {
    element = document.querySelector(element);
  }

  if ((element != null ? element.dropzone : undefined) == null) {
    throw new Error("No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.");
  }

  return element.dropzone;
}; // Set to false if you don't want Dropzone to automatically find and attach to .dropzone elements.


Dropzone.autoDiscover = true; // Looks for all .dropzone elements and creates a dropzone for them

Dropzone.discover = function () {
  var dropzones;

  if (document.querySelectorAll) {
    dropzones = document.querySelectorAll(".dropzone");
  } else {
    dropzones = []; // IE :(

    var checkElements = function checkElements(elements) {
      return function () {
        var result = [];
        var _iteratorNormalCompletion31 = true;
        var _didIteratorError31 = false;
        var _iteratorError31 = undefined;

        try {
          for (var _iterator31 = elements[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {
            var el = _step31.value;

            if (/(^| )dropzone($| )/.test(el.className)) {
              result.push(dropzones.push(el));
            } else {
              result.push(undefined);
            }
          }
        } catch (err) {
          _didIteratorError31 = true;
          _iteratorError31 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion31 && _iterator31["return"] != null) {
              _iterator31["return"]();
            }
          } finally {
            if (_didIteratorError31) {
              throw _iteratorError31;
            }
          }
        }

        return result;
      }();
    };

    checkElements(document.getElementsByTagName("div"));
    checkElements(document.getElementsByTagName("form"));
  }

  return function () {
    var result = [];
    var _iteratorNormalCompletion32 = true;
    var _didIteratorError32 = false;
    var _iteratorError32 = undefined;

    try {
      for (var _iterator32 = dropzones[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {
        var dropzone = _step32.value;

        // Create a dropzone unless auto discover has been disabled for specific element
        if (Dropzone.optionsForElement(dropzone) !== false) {
          result.push(new Dropzone(dropzone));
        } else {
          result.push(undefined);
        }
      }
    } catch (err) {
      _didIteratorError32 = true;
      _iteratorError32 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion32 && _iterator32["return"] != null) {
          _iterator32["return"]();
        }
      } finally {
        if (_didIteratorError32) {
          throw _iteratorError32;
        }
      }
    }

    return result;
  }();
}; // Since the whole Drag'n'Drop API is pretty new, some browsers implement it,
// but not correctly.
// So I created a blacklist of userAgents. Yes, yes. Browser sniffing, I know.
// But what to do when browsers *theoretically* support an API, but crash
// when using it.
//
// This is a list of regular expressions tested against navigator.userAgent
//
// ** It should only be used on browser that *do* support the API, but
// incorrectly **
//


Dropzone.blacklistedBrowsers = [// The mac os and windows phone version of opera 12 seems to have a problem with the File drag'n'drop API.
/opera.*(Macintosh|Windows Phone).*version\/12/i]; // Checks if the browser is supported

Dropzone.isBrowserSupported = function () {
  var capableBrowser = true;

  if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) {
    if (!("classList" in document.createElement("a"))) {
      capableBrowser = false;
    } else {
      // The browser supports the API, but may be blacklisted.
      var _iteratorNormalCompletion33 = true;
      var _didIteratorError33 = false;
      var _iteratorError33 = undefined;

      try {
        for (var _iterator33 = Dropzone.blacklistedBrowsers[Symbol.iterator](), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {
          var regex = _step33.value;

          if (regex.test(navigator.userAgent)) {
            capableBrowser = false;
            continue;
          }
        }
      } catch (err) {
        _didIteratorError33 = true;
        _iteratorError33 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion33 && _iterator33["return"] != null) {
            _iterator33["return"]();
          }
        } finally {
          if (_didIteratorError33) {
            throw _iteratorError33;
          }
        }
      }
    }
  } else {
    capableBrowser = false;
  }

  return capableBrowser;
};

Dropzone.dataURItoBlob = function (dataURI) {
  // convert base64 to raw binary data held in a string
  // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
  var byteString = atob(dataURI.split(',')[1]); // separate out the mime component

  var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]; // write the bytes of the string to an ArrayBuffer

  var ab = new ArrayBuffer(byteString.length);
  var ia = new Uint8Array(ab);

  for (var i = 0, end = byteString.length, asc = 0 <= end; asc ? i <= end : i >= end; asc ? i++ : i--) {
    ia[i] = byteString.charCodeAt(i);
  } // write the ArrayBuffer to a blob


  return new Blob([ab], {
    type: mimeString
  });
}; // Returns an array without the rejected item


var without = function without(list, rejectedItem) {
  return list.filter(function (item) {
    return item !== rejectedItem;
  }).map(function (item) {
    return item;
  });
}; // abc-def_ghi -> abcDefGhi


var camelize = function camelize(str) {
  return str.replace(/[\-_](\w)/g, function (match) {
    return match.charAt(1).toUpperCase();
  });
}; // Creates an element from string


Dropzone.createElement = function (string) {
  var div = document.createElement("div");
  div.innerHTML = string;
  return div.childNodes[0];
}; // Tests if given element is inside (or simply is) the container


Dropzone.elementInside = function (element, container) {
  if (element === container) {
    return true;
  } // Coffeescript doesn't support do/while loops


  while (element = element.parentNode) {
    if (element === container) {
      return true;
    }
  }

  return false;
};

Dropzone.getElement = function (el, name) {
  var element;

  if (typeof el === "string") {
    element = document.querySelector(el);
  } else if (el.nodeType != null) {
    element = el;
  }

  if (element == null) {
    throw new Error("Invalid `".concat(name, "` option provided. Please provide a CSS selector or a plain HTML element."));
  }

  return element;
};

Dropzone.getElements = function (els, name) {
  var el, elements;

  if (els instanceof Array) {
    elements = [];

    try {
      var _iteratorNormalCompletion34 = true;
      var _didIteratorError34 = false;
      var _iteratorError34 = undefined;

      try {
        for (var _iterator34 = els[Symbol.iterator](), _step34; !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {
          el = _step34.value;
          elements.push(this.getElement(el, name));
        }
      } catch (err) {
        _didIteratorError34 = true;
        _iteratorError34 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion34 && _iterator34["return"] != null) {
            _iterator34["return"]();
          }
        } finally {
          if (_didIteratorError34) {
            throw _iteratorError34;
          }
        }
      }
    } catch (e) {
      elements = null;
    }
  } else if (typeof els === "string") {
    elements = [];
    var _iteratorNormalCompletion35 = true;
    var _didIteratorError35 = false;
    var _iteratorError35 = undefined;

    try {
      for (var _iterator35 = document.querySelectorAll(els)[Symbol.iterator](), _step35; !(_iteratorNormalCompletion35 = (_step35 = _iterator35.next()).done); _iteratorNormalCompletion35 = true) {
        el = _step35.value;
        elements.push(el);
      }
    } catch (err) {
      _didIteratorError35 = true;
      _iteratorError35 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion35 && _iterator35["return"] != null) {
          _iterator35["return"]();
        }
      } finally {
        if (_didIteratorError35) {
          throw _iteratorError35;
        }
      }
    }
  } else if (els.nodeType != null) {
    elements = [els];
  }

  if (elements == null || !elements.length) {
    throw new Error("Invalid `".concat(name, "` option provided. Please provide a CSS selector, a plain HTML element or a list of those."));
  }

  return elements;
}; // Asks the user the question and calls accepted or rejected accordingly
//
// The default implementation just uses `window.confirm` and then calls the
// appropriate callback.


Dropzone.confirm = function (question, accepted, rejected) {
  if (window.confirm(question)) {
    return accepted();
  } else if (rejected != null) {
    return rejected();
  }
}; // Validates the mime type like this:
//
// https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept


Dropzone.isValidFile = function (file, acceptedFiles) {
  if (!acceptedFiles) {
    return true;
  } // If there are no accepted mime types, it's OK


  acceptedFiles = acceptedFiles.split(",");
  var mimeType = file.type;
  var baseMimeType = mimeType.replace(/\/.*$/, "");
  var _iteratorNormalCompletion36 = true;
  var _didIteratorError36 = false;
  var _iteratorError36 = undefined;

  try {
    for (var _iterator36 = acceptedFiles[Symbol.iterator](), _step36; !(_iteratorNormalCompletion36 = (_step36 = _iterator36.next()).done); _iteratorNormalCompletion36 = true) {
      var validType = _step36.value;
      validType = validType.trim();

      if (validType.charAt(0) === ".") {
        if (file.name.toLowerCase().indexOf(validType.toLowerCase(), file.name.length - validType.length) !== -1) {
          return true;
        }
      } else if (/\/\*$/.test(validType)) {
        // This is something like a image/* mime type
        if (baseMimeType === validType.replace(/\/.*$/, "")) {
          return true;
        }
      } else {
        if (mimeType === validType) {
          return true;
        }
      }
    }
  } catch (err) {
    _didIteratorError36 = true;
    _iteratorError36 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion36 && _iterator36["return"] != null) {
        _iterator36["return"]();
      }
    } finally {
      if (_didIteratorError36) {
        throw _iteratorError36;
      }
    }
  }

  return false;
}; // Augment jQuery


if (typeof jQuery !== 'undefined' && jQuery !== null) {
  jQuery.fn.dropzone = function (options) {
    return this.each(function () {
      return new Dropzone(this, options);
    });
  };
}

if (typeof module !== 'undefined' && module !== null) {
  module.exports = Dropzone;
} else {
  window.Dropzone = Dropzone;
} // Dropzone file status codes


Dropzone.ADDED = "added";
Dropzone.QUEUED = "queued"; // For backwards compatibility. Now, if a file is accepted, it's either queued
// or uploading.

Dropzone.ACCEPTED = Dropzone.QUEUED;
Dropzone.UPLOADING = "uploading";
Dropzone.PROCESSING = Dropzone.UPLOADING; // alias

Dropzone.CANCELED = "canceled";
Dropzone.ERROR = "error";
Dropzone.SUCCESS = "success";
/*

 Bugfix for iOS 6 and 7
 Source: http://stackoverflow.com/questions/11929099/html5-canvas-drawimage-ratio-bug-ios
 based on the work of https://github.com/stomita/ios-imagefile-megapixel

 */
// Detecting vertical squash in loaded image.
// Fixes a bug which squash image vertically while drawing into canvas for some images.
// This is a bug in iOS6 devices. This function from https://github.com/stomita/ios-imagefile-megapixel

var detectVerticalSquash = function detectVerticalSquash(img) {
  var iw = img.naturalWidth;
  var ih = img.naturalHeight;
  var canvas = document.createElement("canvas");
  canvas.width = 1;
  canvas.height = ih;
  var ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);

  var _ctx$getImageData = ctx.getImageData(1, 0, 1, ih),
      data = _ctx$getImageData.data; // search image edge pixel position in case it is squashed vertically.


  var sy = 0;
  var ey = ih;
  var py = ih;

  while (py > sy) {
    var alpha = data[(py - 1) * 4 + 3];

    if (alpha === 0) {
      ey = py;
    } else {
      sy = py;
    }

    py = ey + sy >> 1;
  }

  var ratio = py / ih;

  if (ratio === 0) {
    return 1;
  } else {
    return ratio;
  }
}; // A replacement for context.drawImage
// (args are for source and destination).


var drawImageIOSFix = function drawImageIOSFix(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {
  var vertSquashRatio = detectVerticalSquash(img);
  return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);
}; // Based on MinifyJpeg
// Source: http://www.perry.cz/files/ExifRestorer.js
// http://elicon.blog57.fc2.com/blog-entry-206.html


var ExifRestore =
/*#__PURE__*/
function () {
  function ExifRestore() {
    _classCallCheck(this, ExifRestore);
  }

  _createClass(ExifRestore, null, [{
    key: "initClass",
    value: function initClass() {
      this.KEY_STR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    }
  }, {
    key: "encode64",
    value: function encode64(input) {
      var output = '';
      var chr1 = undefined;
      var chr2 = undefined;
      var chr3 = '';
      var enc1 = undefined;
      var enc2 = undefined;
      var enc3 = undefined;
      var enc4 = '';
      var i = 0;

      while (true) {
        chr1 = input[i++];
        chr2 = input[i++];
        chr3 = input[i++];
        enc1 = chr1 >> 2;
        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        enc3 = (chr2 & 15) << 2 | chr3 >> 6;
        enc4 = chr3 & 63;

        if (isNaN(chr2)) {
          enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
          enc4 = 64;
        }

        output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);
        chr1 = chr2 = chr3 = '';
        enc1 = enc2 = enc3 = enc4 = '';

        if (!(i < input.length)) {
          break;
        }
      }

      return output;
    }
  }, {
    key: "restore",
    value: function restore(origFileBase64, resizedFileBase64) {
      if (!origFileBase64.match('data:image/jpeg;base64,')) {
        return resizedFileBase64;
      }

      var rawImage = this.decode64(origFileBase64.replace('data:image/jpeg;base64,', ''));
      var segments = this.slice2Segments(rawImage);
      var image = this.exifManipulation(resizedFileBase64, segments);
      return "data:image/jpeg;base64,".concat(this.encode64(image));
    }
  }, {
    key: "exifManipulation",
    value: function exifManipulation(resizedFileBase64, segments) {
      var exifArray = this.getExifArray(segments);
      var newImageArray = this.insertExif(resizedFileBase64, exifArray);
      var aBuffer = new Uint8Array(newImageArray);
      return aBuffer;
    }
  }, {
    key: "getExifArray",
    value: function getExifArray(segments) {
      var seg = undefined;
      var x = 0;

      while (x < segments.length) {
        seg = segments[x];

        if (seg[0] === 255 & seg[1] === 225) {
          return seg;
        }

        x++;
      }

      return [];
    }
  }, {
    key: "insertExif",
    value: function insertExif(resizedFileBase64, exifArray) {
      var imageData = resizedFileBase64.replace('data:image/jpeg;base64,', '');
      var buf = this.decode64(imageData);
      var separatePoint = buf.indexOf(255, 3);
      var mae = buf.slice(0, separatePoint);
      var ato = buf.slice(separatePoint);
      var array = mae;
      array = array.concat(exifArray);
      array = array.concat(ato);
      return array;
    }
  }, {
    key: "slice2Segments",
    value: function slice2Segments(rawImageArray) {
      var head = 0;
      var segments = [];

      while (true) {
        var length;

        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) {
          break;
        }

        if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) {
          head += 2;
        } else {
          length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3];
          var endPoint = head + length + 2;
          var seg = rawImageArray.slice(head, endPoint);
          segments.push(seg);
          head = endPoint;
        }

        if (head > rawImageArray.length) {
          break;
        }
      }

      return segments;
    }
  }, {
    key: "decode64",
    value: function decode64(input) {
      var output = '';
      var chr1 = undefined;
      var chr2 = undefined;
      var chr3 = '';
      var enc1 = undefined;
      var enc2 = undefined;
      var enc3 = undefined;
      var enc4 = '';
      var i = 0;
      var buf = []; // remove all characters that are not A-Z, a-z, 0-9, +, /, or =

      var base64test = /[^A-Za-z0-9\+\/\=]/g;

      if (base64test.exec(input)) {
        console.warn('There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, \'+\', \'/\',and \'=\'\nExpect errors in decoding.');
      }

      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

      while (true) {
        enc1 = this.KEY_STR.indexOf(input.charAt(i++));
        enc2 = this.KEY_STR.indexOf(input.charAt(i++));
        enc3 = this.KEY_STR.indexOf(input.charAt(i++));
        enc4 = this.KEY_STR.indexOf(input.charAt(i++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        buf.push(chr1);

        if (enc3 !== 64) {
          buf.push(chr2);
        }

        if (enc4 !== 64) {
          buf.push(chr3);
        }

        chr1 = chr2 = chr3 = '';
        enc1 = enc2 = enc3 = enc4 = '';

        if (!(i < input.length)) {
          break;
        }
      }

      return buf;
    }
  }]);

  return ExifRestore;
}();

ExifRestore.initClass();
/*
 * contentloaded.js
 *
 * Author: Diego Perini (diego.perini at gmail.com)
 * Summary: cross-browser wrapper for DOMContentLoaded
 * Updated: 20101020
 * License: MIT
 * Version: 1.2
 *
 * URL:
 * http://javascript.nwbox.com/ContentLoaded/
 * http://javascript.nwbox.com/ContentLoaded/MIT-LICENSE
 */
// @win window reference
// @fn function reference

var contentLoaded = function contentLoaded(win, fn) {
  var done = false;
  var top = true;
  var doc = win.document;
  var root = doc.documentElement;
  var add = doc.addEventListener ? "addEventListener" : "attachEvent";
  var rem = doc.addEventListener ? "removeEventListener" : "detachEvent";
  var pre = doc.addEventListener ? "" : "on";

  var init = function init(e) {
    if (e.type === "readystatechange" && doc.readyState !== "complete") {
      return;
    }

    (e.type === "load" ? win : doc)[rem](pre + e.type, init, false);

    if (!done && (done = true)) {
      return fn.call(win, e.type || e);
    }
  };

  var poll = function poll() {
    try {
      root.doScroll("left");
    } catch (e) {
      setTimeout(poll, 50);
      return;
    }

    return init("poll");
  };

  if (doc.readyState !== "complete") {
    if (doc.createEventObject && root.doScroll) {
      try {
        top = !win.frameElement;
      } catch (error) {}

      if (top) {
        poll();
      }
    }

    doc[add](pre + "DOMContentLoaded", init, false);
    doc[add](pre + "readystatechange", init, false);
    return win[add](pre + "load", init, false);
  }
}; // As a single function to be able to write tests.


Dropzone._autoDiscoverFunction = function () {
  if (Dropzone.autoDiscover) {
    return Dropzone.discover();
  }
};

contentLoaded(window, Dropzone._autoDiscoverFunction);

function __guard__(value, transform) {
  return typeof value !== 'undefined' && value !== null ? transform(value) : undefined;
}

function __guardMethod__(obj, methodName, transform) {
  if (typeof obj !== 'undefined' && obj !== null && typeof obj[methodName] === 'function') {
    return transform(obj, methodName);
  } else {
    return undefined;
  }
}

/*
 Sticky-kit v1.1.2 | WTFPL | Leaf Corcoran 2015 | http://leafo.net
*/
(function(){var c,f;c=this.jQuery||window.jQuery;f=c(window);c.fn.stick_in_parent=function(b){var A,w,B,n,p,J,k,E,t,K,q,L;null==b&&(b={});t=b.sticky_class;B=b.inner_scrolling;E=b.recalc_every;k=b.parent;p=b.offset_top;n=b.spacer;w=b.bottoming;null==p&&(p=0);null==k&&(k=void 0);null==B&&(B=!0);null==t&&(t="is_stuck");A=c(document);null==w&&(w=!0);J=function(a){var b;return window.getComputedStyle?(a=window.getComputedStyle(a[0]),b=parseFloat(a.getPropertyValue("width"))+parseFloat(a.getPropertyValue("margin-left"))+
parseFloat(a.getPropertyValue("margin-right")),"border-box"!==a.getPropertyValue("box-sizing")&&(b+=parseFloat(a.getPropertyValue("border-left-width"))+parseFloat(a.getPropertyValue("border-right-width"))+parseFloat(a.getPropertyValue("padding-left"))+parseFloat(a.getPropertyValue("padding-right"))),b):a.outerWidth(!0)};K=function(a,b,q,C,F,u,r,G){var v,H,m,D,I,d,g,x,y,z,h,l;if(!a.data("sticky_kit")){a.data("sticky_kit",!0);I=A.height();g=a.parent();null!=k&&(g=g.closest(k));if(!g.length)throw"failed to find stick parent";
v=m=!1;(h=null!=n?n&&a.closest(n):c("<div />"))&&h.css("position",a.css("position"));x=function(){var d,f,e;if(!G&&(I=A.height(),d=parseInt(g.css("border-top-width"),10),f=parseInt(g.css("padding-top"),10),b=parseInt(g.css("padding-bottom"),10),q=g.offset().top+d+f,C=g.height(),m&&(v=m=!1,null==n&&(a.insertAfter(h),h.detach()),a.css({position:"",top:"",width:"",bottom:""}).removeClass(t),e=!0),F=a.offset().top-(parseInt(a.css("margin-top"),10)||0)-p,u=a.outerHeight(!0),r=a.css("float"),h&&h.css({width:J(a),
height:u,display:a.css("display"),"vertical-align":a.css("vertical-align"),"float":r}),e))return l()};x();if(u!==C)return D=void 0,d=p,z=E,l=function(){var c,l,e,k;if(!G&&(e=!1,null!=z&&(--z,0>=z&&(z=E,x(),e=!0)),e||A.height()===I||x(),e=f.scrollTop(),null!=D&&(l=e-D),D=e,m?(w&&(k=e+u+d>C+q,v&&!k&&(v=!1,a.css({position:"fixed",bottom:"",top:d}).trigger("sticky_kit:unbottom"))),e<F&&(m=!1,d=p,null==n&&("left"!==r&&"right"!==r||a.insertAfter(h),h.detach()),c={position:"",width:"",top:""},a.css(c).removeClass(t).trigger("sticky_kit:unstick")),
B&&(c=f.height(),u+p>c&&!v&&(d-=l,d=Math.max(c-u,d),d=Math.min(p,d),m&&a.css({top:d+"px"})))):e>F&&(m=!0,c={position:"fixed",top:d},c.width="border-box"===a.css("box-sizing")?a.outerWidth()+"px":a.width()+"px",a.css(c).addClass(t),null==n&&(a.after(h),"left"!==r&&"right"!==r||h.append(a)),a.trigger("sticky_kit:stick")),m&&w&&(null==k&&(k=e+u+d>C+q),!v&&k)))return v=!0,"static"===g.css("position")&&g.css({position:"relative"}),a.css({position:"absolute",bottom:b,top:"auto"}).trigger("sticky_kit:bottom")},
y=function(){x();return l()},H=function(){G=!0;f.off("touchmove",l);f.off("scroll",l);f.off("resize",y);c(document.body).off("sticky_kit:recalc",y);a.off("sticky_kit:detach",H);a.removeData("sticky_kit");a.css({position:"",bottom:"",top:"",width:""});g.position("position","");if(m)return null==n&&("left"!==r&&"right"!==r||a.insertAfter(h),h.remove()),a.removeClass(t)},f.on("touchmove",l),f.on("scroll",l),f.on("resize",y),c(document.body).on("sticky_kit:recalc",y),a.on("sticky_kit:detach",H),setTimeout(l,
0)}};q=0;for(L=this.length;q<L;q++)b=this[q],K(c(b));return this}}).call(this);

/* Chosen v1.8.7 | (c) 2011-2018 by Harvest | MIT License, https://github.com/harvesthq/chosen/blob/master/LICENSE.md */

(function(){var t,e,s,i,n=function(t,e){return function(){return t.apply(e,arguments)}},r=function(t,e){function s(){this.constructor=t}for(var i in e)o.call(e,i)&&(t[i]=e[i]);return s.prototype=e.prototype,t.prototype=new s,t.__super__=e.prototype,t},o={}.hasOwnProperty;(i=function(){function t(){this.options_index=0,this.parsed=[]}return t.prototype.add_node=function(t){return"OPTGROUP"===t.nodeName.toUpperCase()?this.add_group(t):this.add_option(t)},t.prototype.add_group=function(t){var e,s,i,n,r,o;for(e=this.parsed.length,this.parsed.push({array_index:e,group:!0,label:t.label,title:t.title?t.title:void 0,children:0,disabled:t.disabled,classes:t.className}),o=[],s=0,i=(r=t.childNodes).length;s<i;s++)n=r[s],o.push(this.add_option(n,e,t.disabled));return o},t.prototype.add_option=function(t,e,s){if("OPTION"===t.nodeName.toUpperCase())return""!==t.text?(null!=e&&(this.parsed[e].children+=1),this.parsed.push({array_index:this.parsed.length,options_index:this.options_index,value:t.value,text:t.text,html:t.innerHTML,title:t.title?t.title:void 0,selected:t.selected,disabled:!0===s?s:t.disabled,group_array_index:e,group_label:null!=e?this.parsed[e].label:null,classes:t.className,style:t.style.cssText})):this.parsed.push({array_index:this.parsed.length,options_index:this.options_index,empty:!0}),this.options_index+=1},t}()).select_to_array=function(t){var e,s,n,r,o;for(r=new i,s=0,n=(o=t.childNodes).length;s<n;s++)e=o[s],r.add_node(e);return r.parsed},e=function(){function t(e,s){this.form_field=e,this.options=null!=s?s:{},this.label_click_handler=n(this.label_click_handler,this),t.browser_is_supported()&&(this.is_multiple=this.form_field.multiple,this.set_default_text(),this.set_default_values(),this.setup(),this.set_up_html(),this.register_observers(),this.on_ready())}return t.prototype.set_default_values=function(){return this.click_test_action=function(t){return function(e){return t.test_active_click(e)}}(this),this.activate_action=function(t){return function(e){return t.activate_field(e)}}(this),this.active_field=!1,this.mouse_on_container=!1,this.results_showing=!1,this.result_highlighted=null,this.is_rtl=this.options.rtl||/\bchosen-rtl\b/.test(this.form_field.className),this.allow_single_deselect=null!=this.options.allow_single_deselect&&null!=this.form_field.options[0]&&""===this.form_field.options[0].text&&this.options.allow_single_deselect,this.disable_search_threshold=this.options.disable_search_threshold||0,this.disable_search=this.options.disable_search||!1,this.enable_split_word_search=null==this.options.enable_split_word_search||this.options.enable_split_word_search,this.group_search=null==this.options.group_search||this.options.group_search,this.search_contains=this.options.search_contains||!1,this.single_backstroke_delete=null==this.options.single_backstroke_delete||this.options.single_backstroke_delete,this.max_selected_options=this.options.max_selected_options||Infinity,this.inherit_select_classes=this.options.inherit_select_classes||!1,this.display_selected_options=null==this.options.display_selected_options||this.options.display_selected_options,this.display_disabled_options=null==this.options.display_disabled_options||this.options.display_disabled_options,this.include_group_label_in_selected=this.options.include_group_label_in_selected||!1,this.max_shown_results=this.options.max_shown_results||Number.POSITIVE_INFINITY,this.case_sensitive_search=this.options.case_sensitive_search||!1,this.hide_results_on_select=null==this.options.hide_results_on_select||this.options.hide_results_on_select},t.prototype.set_default_text=function(){return this.form_field.getAttribute("data-placeholder")?this.default_text=this.form_field.getAttribute("data-placeholder"):this.is_multiple?this.default_text=this.options.placeholder_text_multiple||this.options.placeholder_text||t.default_multiple_text:this.default_text=this.options.placeholder_text_single||this.options.placeholder_text||t.default_single_text,this.default_text=this.escape_html(this.default_text),this.results_none_found=this.form_field.getAttribute("data-no_results_text")||this.options.no_results_text||t.default_no_result_text},t.prototype.choice_label=function(t){return this.include_group_label_in_selected&&null!=t.group_label?"<b class='group-name'>"+this.escape_html(t.group_label)+"</b>"+t.html:t.html},t.prototype.mouse_enter=function(){return this.mouse_on_container=!0},t.prototype.mouse_leave=function(){return this.mouse_on_container=!1},t.prototype.input_focus=function(t){if(this.is_multiple){if(!this.active_field)return setTimeout(function(t){return function(){return t.container_mousedown()}}(this),50)}else if(!this.active_field)return this.activate_field()},t.prototype.input_blur=function(t){if(!this.mouse_on_container)return this.active_field=!1,setTimeout(function(t){return function(){return t.blur_test()}}(this),100)},t.prototype.label_click_handler=function(t){return this.is_multiple?this.container_mousedown(t):this.activate_field()},t.prototype.results_option_build=function(t){var e,s,i,n,r,o,h;for(e="",h=0,n=0,r=(o=this.results_data).length;n<r&&(s=o[n],i="",""!==(i=s.group?this.result_add_group(s):this.result_add_option(s))&&(h++,e+=i),(null!=t?t.first:void 0)&&(s.selected&&this.is_multiple?this.choice_build(s):s.selected&&!this.is_multiple&&this.single_set_selected_text(this.choice_label(s))),!(h>=this.max_shown_results));n++);return e},t.prototype.result_add_option=function(t){var e,s;return t.search_match&&this.include_option_in_results(t)?(e=[],t.disabled||t.selected&&this.is_multiple||e.push("active-result"),!t.disabled||t.selected&&this.is_multiple||e.push("disabled-result"),t.selected&&e.push("result-selected"),null!=t.group_array_index&&e.push("group-option"),""!==t.classes&&e.push(t.classes),s=document.createElement("li"),s.className=e.join(" "),t.style&&(s.style.cssText=t.style),s.setAttribute("data-option-array-index",t.array_index),s.innerHTML=t.highlighted_html||t.html,t.title&&(s.title=t.title),this.outerHTML(s)):""},t.prototype.result_add_group=function(t){var e,s;return(t.search_match||t.group_match)&&t.active_options>0?((e=[]).push("group-result"),t.classes&&e.push(t.classes),s=document.createElement("li"),s.className=e.join(" "),s.innerHTML=t.highlighted_html||this.escape_html(t.label),t.title&&(s.title=t.title),this.outerHTML(s)):""},t.prototype.results_update_field=function(){if(this.set_default_text(),this.is_multiple||this.results_reset_cleanup(),this.result_clear_highlight(),this.results_build(),this.results_showing)return this.winnow_results()},t.prototype.reset_single_select_options=function(){var t,e,s,i,n;for(n=[],t=0,e=(s=this.results_data).length;t<e;t++)(i=s[t]).selected?n.push(i.selected=!1):n.push(void 0);return n},t.prototype.results_toggle=function(){return this.results_showing?this.results_hide():this.results_show()},t.prototype.results_search=function(t){return this.results_showing?this.winnow_results():this.results_show()},t.prototype.winnow_results=function(t){var e,s,i,n,r,o,h,l,c,_,a,u,d,p,f;for(this.no_results_clear(),_=0,e=(h=this.get_search_text()).replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&"),c=this.get_search_regex(e),i=0,n=(l=this.results_data).length;i<n;i++)(r=l[i]).search_match=!1,a=null,u=null,r.highlighted_html="",this.include_option_in_results(r)&&(r.group&&(r.group_match=!1,r.active_options=0),null!=r.group_array_index&&this.results_data[r.group_array_index]&&(0===(a=this.results_data[r.group_array_index]).active_options&&a.search_match&&(_+=1),a.active_options+=1),f=r.group?r.label:r.text,r.group&&!this.group_search||(u=this.search_string_match(f,c),r.search_match=null!=u,r.search_match&&!r.group&&(_+=1),r.search_match?(h.length&&(d=u.index,o=f.slice(0,d),s=f.slice(d,d+h.length),p=f.slice(d+h.length),r.highlighted_html=this.escape_html(o)+"<em>"+this.escape_html(s)+"</em>"+this.escape_html(p)),null!=a&&(a.group_match=!0)):null!=r.group_array_index&&this.results_data[r.group_array_index].search_match&&(r.search_match=!0)));return this.result_clear_highlight(),_<1&&h.length?(this.update_results_content(""),this.no_results(h)):(this.update_results_content(this.results_option_build()),(null!=t?t.skip_highlight:void 0)?void 0:this.winnow_results_set_highlight())},t.prototype.get_search_regex=function(t){var e,s;return s=this.search_contains?t:"(^|\\s|\\b)"+t+"[^\\s]*",this.enable_split_word_search||this.search_contains||(s="^"+s),e=this.case_sensitive_search?"":"i",new RegExp(s,e)},t.prototype.search_string_match=function(t,e){var s;return s=e.exec(t),!this.search_contains&&(null!=s?s[1]:void 0)&&(s.index+=1),s},t.prototype.choices_count=function(){var t,e,s;if(null!=this.selected_option_count)return this.selected_option_count;for(this.selected_option_count=0,t=0,e=(s=this.form_field.options).length;t<e;t++)s[t].selected&&(this.selected_option_count+=1);return this.selected_option_count},t.prototype.choices_click=function(t){if(t.preventDefault(),this.activate_field(),!this.results_showing&&!this.is_disabled)return this.results_show()},t.prototype.keydown_checker=function(t){var e,s;switch(s=null!=(e=t.which)?e:t.keyCode,this.search_field_scale(),8!==s&&this.pending_backstroke&&this.clear_backstroke(),s){case 8:this.backstroke_length=this.get_search_field_value().length;break;case 9:this.results_showing&&!this.is_multiple&&this.result_select(t),this.mouse_on_container=!1;break;case 13:case 27:this.results_showing&&t.preventDefault();break;case 32:this.disable_search&&t.preventDefault();break;case 38:t.preventDefault(),this.keyup_arrow();break;case 40:t.preventDefault(),this.keydown_arrow()}},t.prototype.keyup_checker=function(t){var e,s;switch(s=null!=(e=t.which)?e:t.keyCode,this.search_field_scale(),s){case 8:this.is_multiple&&this.backstroke_length<1&&this.choices_count()>0?this.keydown_backstroke():this.pending_backstroke||(this.result_clear_highlight(),this.results_search());break;case 13:t.preventDefault(),this.results_showing&&this.result_select(t);break;case 27:this.results_showing&&this.results_hide();break;case 9:case 16:case 17:case 18:case 38:case 40:case 91:break;default:this.results_search()}},t.prototype.clipboard_event_checker=function(t){if(!this.is_disabled)return setTimeout(function(t){return function(){return t.results_search()}}(this),50)},t.prototype.container_width=function(){return null!=this.options.width?this.options.width:this.form_field.offsetWidth+"px"},t.prototype.include_option_in_results=function(t){return!(this.is_multiple&&!this.display_selected_options&&t.selected)&&(!(!this.display_disabled_options&&t.disabled)&&!t.empty)},t.prototype.search_results_touchstart=function(t){return this.touch_started=!0,this.search_results_mouseover(t)},t.prototype.search_results_touchmove=function(t){return this.touch_started=!1,this.search_results_mouseout(t)},t.prototype.search_results_touchend=function(t){if(this.touch_started)return this.search_results_mouseup(t)},t.prototype.outerHTML=function(t){var e;return t.outerHTML?t.outerHTML:((e=document.createElement("div")).appendChild(t),e.innerHTML)},t.prototype.get_single_html=function(){return'<a class="chosen-single chosen-default">\n  <span>'+this.default_text+'</span>\n  <div><b></b></div>\n</a>\n<div class="chosen-drop">\n  <div class="chosen-search">\n    <input class="chosen-search-input" type="text" autocomplete="off" />\n  </div>\n  <ul class="chosen-results"></ul>\n</div>'},t.prototype.get_multi_html=function(){return'<ul class="chosen-choices">\n  <li class="search-field">\n    <input class="chosen-search-input" type="text" autocomplete="off" value="'+this.default_text+'" />\n  </li>\n</ul>\n<div class="chosen-drop">\n  <ul class="chosen-results"></ul>\n</div>'},t.prototype.get_no_results_html=function(t){return'<li class="no-results">\n  '+this.results_none_found+" <span>"+this.escape_html(t)+"</span>\n</li>"},t.browser_is_supported=function(){return"Microsoft Internet Explorer"===window.navigator.appName?document.documentMode>=8:!(/iP(od|hone)/i.test(window.navigator.userAgent)||/IEMobile/i.test(window.navigator.userAgent)||/Windows Phone/i.test(window.navigator.userAgent)||/BlackBerry/i.test(window.navigator.userAgent)||/BB10/i.test(window.navigator.userAgent)||/Android.*Mobile/i.test(window.navigator.userAgent))},t.default_multiple_text="Select Some Options",t.default_single_text="Select an Option",t.default_no_result_text="No results match",t}(),(t=jQuery).fn.extend({chosen:function(i){return e.browser_is_supported()?this.each(function(e){var n,r;r=(n=t(this)).data("chosen"),"destroy"!==i?r instanceof s||n.data("chosen",new s(this,i)):r instanceof s&&r.destroy()}):this}}),s=function(s){function n(){return n.__super__.constructor.apply(this,arguments)}return r(n,e),n.prototype.setup=function(){return this.form_field_jq=t(this.form_field),this.current_selectedIndex=this.form_field.selectedIndex},n.prototype.set_up_html=function(){var e,s;return(e=["chosen-container"]).push("chosen-container-"+(this.is_multiple?"multi":"single")),this.inherit_select_classes&&this.form_field.className&&e.push(this.form_field.className),this.is_rtl&&e.push("chosen-rtl"),s={"class":e.join(" "),title:this.form_field.title},this.form_field.id.length&&(s.id=this.form_field.id.replace(/[^\w]/g,"_")+"_chosen"),this.container=t("<div />",s),this.container.width(this.container_width()),this.is_multiple?this.container.html(this.get_multi_html()):this.container.html(this.get_single_html()),this.form_field_jq.hide().after(this.container),this.dropdown=this.container.find("div.chosen-drop").first(),this.search_field=this.container.find("input").first(),this.search_results=this.container.find("ul.chosen-results").first(),this.search_field_scale(),this.search_no_results=this.container.find("li.no-results").first(),this.is_multiple?(this.search_choices=this.container.find("ul.chosen-choices").first(),this.search_container=this.container.find("li.search-field").first()):(this.search_container=this.container.find("div.chosen-search").first(),this.selected_item=this.container.find(".chosen-single").first()),this.results_build(),this.set_tab_index(),this.set_label_behavior()},n.prototype.on_ready=function(){return this.form_field_jq.trigger("chosen:ready",{chosen:this})},n.prototype.register_observers=function(){return this.container.on("touchstart.chosen",function(t){return function(e){t.container_mousedown(e)}}(this)),this.container.on("touchend.chosen",function(t){return function(e){t.container_mouseup(e)}}(this)),this.container.on("mousedown.chosen",function(t){return function(e){t.container_mousedown(e)}}(this)),this.container.on("mouseup.chosen",function(t){return function(e){t.container_mouseup(e)}}(this)),this.container.on("mouseenter.chosen",function(t){return function(e){t.mouse_enter(e)}}(this)),this.container.on("mouseleave.chosen",function(t){return function(e){t.mouse_leave(e)}}(this)),this.search_results.on("mouseup.chosen",function(t){return function(e){t.search_results_mouseup(e)}}(this)),this.search_results.on("mouseover.chosen",function(t){return function(e){t.search_results_mouseover(e)}}(this)),this.search_results.on("mouseout.chosen",function(t){return function(e){t.search_results_mouseout(e)}}(this)),this.search_results.on("mousewheel.chosen DOMMouseScroll.chosen",function(t){return function(e){t.search_results_mousewheel(e)}}(this)),this.search_results.on("touchstart.chosen",function(t){return function(e){t.search_results_touchstart(e)}}(this)),this.search_results.on("touchmove.chosen",function(t){return function(e){t.search_results_touchmove(e)}}(this)),this.search_results.on("touchend.chosen",function(t){return function(e){t.search_results_touchend(e)}}(this)),this.form_field_jq.on("chosen:updated.chosen",function(t){return function(e){t.results_update_field(e)}}(this)),this.form_field_jq.on("chosen:activate.chosen",function(t){return function(e){t.activate_field(e)}}(this)),this.form_field_jq.on("chosen:open.chosen",function(t){return function(e){t.container_mousedown(e)}}(this)),this.form_field_jq.on("chosen:close.chosen",function(t){return function(e){t.close_field(e)}}(this)),this.search_field.on("blur.chosen",function(t){return function(e){t.input_blur(e)}}(this)),this.search_field.on("keyup.chosen",function(t){return function(e){t.keyup_checker(e)}}(this)),this.search_field.on("keydown.chosen",function(t){return function(e){t.keydown_checker(e)}}(this)),this.search_field.on("focus.chosen",function(t){return function(e){t.input_focus(e)}}(this)),this.search_field.on("cut.chosen",function(t){return function(e){t.clipboard_event_checker(e)}}(this)),this.search_field.on("paste.chosen",function(t){return function(e){t.clipboard_event_checker(e)}}(this)),this.is_multiple?this.search_choices.on("click.chosen",function(t){return function(e){t.choices_click(e)}}(this)):this.container.on("click.chosen",function(t){t.preventDefault()})},n.prototype.destroy=function(){return t(this.container[0].ownerDocument).off("click.chosen",this.click_test_action),this.form_field_label.length>0&&this.form_field_label.off("click.chosen"),this.search_field[0].tabIndex&&(this.form_field_jq[0].tabIndex=this.search_field[0].tabIndex),this.container.remove(),this.form_field_jq.removeData("chosen"),this.form_field_jq.show()},n.prototype.search_field_disabled=function(){return this.is_disabled=this.form_field.disabled||this.form_field_jq.parents("fieldset").is(":disabled"),this.container.toggleClass("chosen-disabled",this.is_disabled),this.search_field[0].disabled=this.is_disabled,this.is_multiple||this.selected_item.off("focus.chosen",this.activate_field),this.is_disabled?this.close_field():this.is_multiple?void 0:this.selected_item.on("focus.chosen",this.activate_field)},n.prototype.container_mousedown=function(e){var s;if(!this.is_disabled)return!e||"mousedown"!==(s=e.type)&&"touchstart"!==s||this.results_showing||e.preventDefault(),null!=e&&t(e.target).hasClass("search-choice-close")?void 0:(this.active_field?this.is_multiple||!e||t(e.target)[0]!==this.selected_item[0]&&!t(e.target).parents("a.chosen-single").length||(e.preventDefault(),this.results_toggle()):(this.is_multiple&&this.search_field.val(""),t(this.container[0].ownerDocument).on("click.chosen",this.click_test_action),this.results_show()),this.activate_field())},n.prototype.container_mouseup=function(t){if("ABBR"===t.target.nodeName&&!this.is_disabled)return this.results_reset(t)},n.prototype.search_results_mousewheel=function(t){var e;if(t.originalEvent&&(e=t.originalEvent.deltaY||-t.originalEvent.wheelDelta||t.originalEvent.detail),null!=e)return t.preventDefault(),"DOMMouseScroll"===t.type&&(e*=40),this.search_results.scrollTop(e+this.search_results.scrollTop())},n.prototype.blur_test=function(t){if(!this.active_field&&this.container.hasClass("chosen-container-active"))return this.close_field()},n.prototype.close_field=function(){return t(this.container[0].ownerDocument).off("click.chosen",this.click_test_action),this.active_field=!1,this.results_hide(),this.container.removeClass("chosen-container-active"),this.clear_backstroke(),this.show_search_field_default(),this.search_field_scale(),this.search_field.blur()},n.prototype.activate_field=function(){if(!this.is_disabled)return this.container.addClass("chosen-container-active"),this.active_field=!0,this.search_field.val(this.search_field.val()),this.search_field.focus()},n.prototype.test_active_click=function(e){var s;return(s=t(e.target).closest(".chosen-container")).length&&this.container[0]===s[0]?this.active_field=!0:this.close_field()},n.prototype.results_build=function(){return this.parsing=!0,this.selected_option_count=null,this.results_data=i.select_to_array(this.form_field),this.is_multiple?this.search_choices.find("li.search-choice").remove():(this.single_set_selected_text(),this.disable_search||this.form_field.options.length<=this.disable_search_threshold?(this.search_field[0].readOnly=!0,this.container.addClass("chosen-container-single-nosearch")):(this.search_field[0].readOnly=!1,this.container.removeClass("chosen-container-single-nosearch"))),this.update_results_content(this.results_option_build({first:!0})),this.search_field_disabled(),this.show_search_field_default(),this.search_field_scale(),this.parsing=!1},n.prototype.result_do_highlight=function(t){var e,s,i,n,r;if(t.length){if(this.result_clear_highlight(),this.result_highlight=t,this.result_highlight.addClass("highlighted"),i=parseInt(this.search_results.css("maxHeight"),10),r=this.search_results.scrollTop(),n=i+r,s=this.result_highlight.position().top+this.search_results.scrollTop(),(e=s+this.result_highlight.outerHeight())>=n)return this.search_results.scrollTop(e-i>0?e-i:0);if(s<r)return this.search_results.scrollTop(s)}},n.prototype.result_clear_highlight=function(){return this.result_highlight&&this.result_highlight.removeClass("highlighted"),this.result_highlight=null},n.prototype.results_show=function(){return this.is_multiple&&this.max_selected_options<=this.choices_count()?(this.form_field_jq.trigger("chosen:maxselected",{chosen:this}),!1):(this.container.addClass("chosen-with-drop"),this.results_showing=!0,this.search_field.focus(),this.search_field.val(this.get_search_field_value()),this.winnow_results(),this.form_field_jq.trigger("chosen:showing_dropdown",{chosen:this}))},n.prototype.update_results_content=function(t){return this.search_results.html(t)},n.prototype.results_hide=function(){return this.results_showing&&(this.result_clear_highlight(),this.container.removeClass("chosen-with-drop"),this.form_field_jq.trigger("chosen:hiding_dropdown",{chosen:this})),this.results_showing=!1},n.prototype.set_tab_index=function(t){var e;if(this.form_field.tabIndex)return e=this.form_field.tabIndex,this.form_field.tabIndex=-1,this.search_field[0].tabIndex=e},n.prototype.set_label_behavior=function(){if(this.form_field_label=this.form_field_jq.parents("label"),!this.form_field_label.length&&this.form_field.id.length&&(this.form_field_label=t("label[for='"+this.form_field.id+"']")),this.form_field_label.length>0)return this.form_field_label.on("click.chosen",this.label_click_handler)},n.prototype.show_search_field_default=function(){return this.is_multiple&&this.choices_count()<1&&!this.active_field?(this.search_field.val(this.default_text),this.search_field.addClass("default")):(this.search_field.val(""),this.search_field.removeClass("default"))},n.prototype.search_results_mouseup=function(e){var s;if((s=t(e.target).hasClass("active-result")?t(e.target):t(e.target).parents(".active-result").first()).length)return this.result_highlight=s,this.result_select(e),this.search_field.focus()},n.prototype.search_results_mouseover=function(e){var s;if(s=t(e.target).hasClass("active-result")?t(e.target):t(e.target).parents(".active-result").first())return this.result_do_highlight(s)},n.prototype.search_results_mouseout=function(e){if(t(e.target).hasClass("active-result")||t(e.target).parents(".active-result").first())return this.result_clear_highlight()},n.prototype.choice_build=function(e){var s,i;return s=t("<li />",{"class":"search-choice"}).html("<span>"+this.choice_label(e)+"</span>"),e.disabled?s.addClass("search-choice-disabled"):((i=t("<a />",{"class":"search-choice-close","data-option-array-index":e.array_index})).on("click.chosen",function(t){return function(e){return t.choice_destroy_link_click(e)}}(this)),s.append(i)),this.search_container.before(s)},n.prototype.choice_destroy_link_click=function(e){if(e.preventDefault(),e.stopPropagation(),!this.is_disabled)return this.choice_destroy(t(e.target))},n.prototype.choice_destroy=function(t){if(this.result_deselect(t[0].getAttribute("data-option-array-index")))return this.active_field?this.search_field.focus():this.show_search_field_default(),this.is_multiple&&this.choices_count()>0&&this.get_search_field_value().length<1&&this.results_hide(),t.parents("li").first().remove(),this.search_field_scale()},n.prototype.results_reset=function(){if(this.reset_single_select_options(),this.form_field.options[0].selected=!0,this.single_set_selected_text(),this.show_search_field_default(),this.results_reset_cleanup(),this.trigger_form_field_change(),this.active_field)return this.results_hide()},n.prototype.results_reset_cleanup=function(){return this.current_selectedIndex=this.form_field.selectedIndex,this.selected_item.find("abbr").remove()},n.prototype.result_select=function(t){var e,s;if(this.result_highlight)return e=this.result_highlight,this.result_clear_highlight(),this.is_multiple&&this.max_selected_options<=this.choices_count()?(this.form_field_jq.trigger("chosen:maxselected",{chosen:this}),!1):(this.is_multiple?e.removeClass("active-result"):this.reset_single_select_options(),e.addClass("result-selected"),s=this.results_data[e[0].getAttribute("data-option-array-index")],s.selected=!0,this.form_field.options[s.options_index].selected=!0,this.selected_option_count=null,this.is_multiple?this.choice_build(s):this.single_set_selected_text(this.choice_label(s)),this.is_multiple&&(!this.hide_results_on_select||t.metaKey||t.ctrlKey)?t.metaKey||t.ctrlKey?this.winnow_results({skip_highlight:!0}):(this.search_field.val(""),this.winnow_results()):(this.results_hide(),this.show_search_field_default()),(this.is_multiple||this.form_field.selectedIndex!==this.current_selectedIndex)&&this.trigger_form_field_change({selected:this.form_field.options[s.options_index].value}),this.current_selectedIndex=this.form_field.selectedIndex,t.preventDefault(),this.search_field_scale())},n.prototype.single_set_selected_text=function(t){return null==t&&(t=this.default_text),t===this.default_text?this.selected_item.addClass("chosen-default"):(this.single_deselect_control_build(),this.selected_item.removeClass("chosen-default")),this.selected_item.find("span").html(t)},n.prototype.result_deselect=function(t){var e;return e=this.results_data[t],!this.form_field.options[e.options_index].disabled&&(e.selected=!1,this.form_field.options[e.options_index].selected=!1,this.selected_option_count=null,this.result_clear_highlight(),this.results_showing&&this.winnow_results(),this.trigger_form_field_change({deselected:this.form_field.options[e.options_index].value}),this.search_field_scale(),!0)},n.prototype.single_deselect_control_build=function(){if(this.allow_single_deselect)return this.selected_item.find("abbr").length||this.selected_item.find("span").first().after('<abbr class="search-choice-close"></abbr>'),this.selected_item.addClass("chosen-single-with-deselect")},n.prototype.get_search_field_value=function(){return this.search_field.val()},n.prototype.get_search_text=function(){return t.trim(this.get_search_field_value())},n.prototype.escape_html=function(e){return t("<div/>").text(e).html()},n.prototype.winnow_results_set_highlight=function(){var t,e;if(e=this.is_multiple?[]:this.search_results.find(".result-selected.active-result"),null!=(t=e.length?e.first():this.search_results.find(".active-result").first()))return this.result_do_highlight(t)},n.prototype.no_results=function(t){var e;return e=this.get_no_results_html(t),this.search_results.append(e),this.form_field_jq.trigger("chosen:no_results",{chosen:this})},n.prototype.no_results_clear=function(){return this.search_results.find(".no-results").remove()},n.prototype.keydown_arrow=function(){var t;return this.results_showing&&this.result_highlight?(t=this.result_highlight.nextAll("li.active-result").first())?this.result_do_highlight(t):void 0:this.results_show()},n.prototype.keyup_arrow=function(){var t;return this.results_showing||this.is_multiple?this.result_highlight?(t=this.result_highlight.prevAll("li.active-result")).length?this.result_do_highlight(t.first()):(this.choices_count()>0&&this.results_hide(),this.result_clear_highlight()):void 0:this.results_show()},n.prototype.keydown_backstroke=function(){var t;return this.pending_backstroke?(this.choice_destroy(this.pending_backstroke.find("a").first()),this.clear_backstroke()):(t=this.search_container.siblings("li.search-choice").last()).length&&!t.hasClass("search-choice-disabled")?(this.pending_backstroke=t,this.single_backstroke_delete?this.keydown_backstroke():this.pending_backstroke.addClass("search-choice-focus")):void 0},n.prototype.clear_backstroke=function(){return this.pending_backstroke&&this.pending_backstroke.removeClass("search-choice-focus"),this.pending_backstroke=null},n.prototype.search_field_scale=function(){var e,s,i,n,r,o,h;if(this.is_multiple){for(r={position:"absolute",left:"-1000px",top:"-1000px",display:"none",whiteSpace:"pre"},s=0,i=(o=["fontSize","fontStyle","fontWeight","fontFamily","lineHeight","textTransform","letterSpacing"]).length;s<i;s++)r[n=o[s]]=this.search_field.css(n);return(e=t("<div />").css(r)).text(this.get_search_field_value()),t("body").append(e),h=e.width()+25,e.remove(),this.container.is(":visible")&&(h=Math.min(this.container.outerWidth()-10,h)),this.search_field.width(h)}},n.prototype.trigger_form_field_change=function(t){return this.form_field_jq.trigger("input",t),this.form_field_jq.trigger("change",t)},n}()}).call(this);
;(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['jquery'], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory(require('jquery'));
  } else {
    root.jquery_dotdotdot_js = factory(root.jQuery);
  }
}(this, function(jQuery) {
/*
 *	jQuery dotdotdot 3.2.3
 *	@requires jQuery 1.7.0 or later
 *
 *	dotdotdot.frebsite.nl
 *
 *	Copyright (c) Fred Heusschen
 *	www.frebsite.nl
 *
 *	License: CC-BY-NC-4.0
 *	http://creativecommons.org/licenses/by-nc/4.0/
 */
!function(a){"use strict";var d,t,n,s,o="dotdotdot",e="3.2.3";a[o]&&a[o].version>e||(a[o]=function(t,e){this.$dot=t,this.api=["getInstance","truncate","restore","destroy","watch","unwatch"],this.opts=e;var i=this.$dot.data(o);return i&&i.destroy(),this.init(),this.truncate(),this.opts.watch&&this.watch(),this},a[o].version=e,a[o].uniqueId=0,a[o].defaults={ellipsis:"… ",callback:function(t){},truncate:"word",tolerance:0,keep:null,watch:"window",height:null},a[o].prototype={init:function(){this.watchTimeout=null,this.watchInterval=null,this.uniqueId=a[o].uniqueId++,this.originalStyle=this.$dot.attr("style")||"",this.originalContent=this._getOriginalContent(),"break-word"!==this.$dot.css("word-wrap")&&this.$dot.css("word-wrap","break-word"),"nowrap"===this.$dot.css("white-space")&&this.$dot.css("white-space","normal"),null===this.opts.height&&(this.opts.height=this._getMaxHeight()),"string"==typeof this.opts.ellipsis&&(this.opts.ellipsis=document.createTextNode(this.opts.ellipsis))},getInstance:function(){return this},truncate:function(){this.$inner=this.$dot.wrapInner("<div />").children().css({display:"block",height:"auto",width:"auto",border:"none",padding:0,margin:0}),this.$inner.empty().append(this.originalContent.clone(!0)),this.maxHeight=this._getMaxHeight();var t=!1;return this._fits()||(t=!0,this._truncateToNode(this.$inner[0])),this.$dot[t?"addClass":"removeClass"](d.truncated),this.$inner.replaceWith(this.$inner.contents()),this.$inner=null,this.opts.callback.call(this.$dot[0],t),t},restore:function(){this.unwatch(),this.$dot.empty().append(this.originalContent).attr("style",this.originalStyle).removeClass(d.truncated)},destroy:function(){this.restore(),this.$dot.data(o,null)},watch:function(){var e=this;this.unwatch();var i={};"window"==this.opts.watch?s.on(n.resize+e.uniqueId,function(t){e.watchTimeout&&clearTimeout(e.watchTimeout),e.watchTimeout=setTimeout(function(){i=e._watchSizes(i,s,"width","height")},100)}):this.watchInterval=setInterval(function(){i=e._watchSizes(i,e.$dot,"innerWidth","innerHeight")},500)},unwatch:function(){s.off(n.resize+this.uniqueId),this.watchInterval&&clearInterval(this.watchInterval),this.watchTimeout&&clearTimeout(this.watchTimeout)},_api:function(){var i=this,n={};return a.each(this.api,function(t){var e=this;n[e]=function(){var t=i[e].apply(i,arguments);return void 0===t?n:t}}),n},_truncateToNode:function(t){var i=[],n=[];if(a(t).contents().each(function(){var t=a(this);if(!t.hasClass(d.keep)){var e=document.createComment("");t.replaceWith(e),n.push(this),i.push(e)}}),n.length){for(var e=0;e<n.length;e++){a(i[e]).replaceWith(n[e]),a(n[e]).append(this.opts.ellipsis);var s=this._fits();if(a(this.opts.ellipsis,n[e]).remove(),!s){if("node"==this.opts.truncate&&1<e)return void a(n[e-2]).remove();break}}for(var o=e;o<i.length;o++)a(i[o]).remove();var r=n[Math.max(0,Math.min(e,n.length-1))];if(1==r.nodeType){var h=a("<"+r.nodeName+" />");h.append(this.opts.ellipsis),a(r).replaceWith(h),this._fits()?h.replaceWith(r):(h.remove(),r=n[Math.max(0,e-1)])}1==r.nodeType?this._truncateToNode(r):this._truncateToWord(r)}},_truncateToWord:function(t){for(var e=t,i=this,n=this.__getTextContent(e),s=-1!==n.indexOf(" ")?" ":"　",o=n.split(s),r="",h=o.length;0<=h;h--)if(r=o.slice(0,h).join(s),i.__setTextContent(e,i._addEllipsis(r)),i._fits()){"letter"==i.opts.truncate&&(i.__setTextContent(e,o.slice(0,h+1).join(s)),i._truncateToLetter(e));break}},_truncateToLetter:function(t){for(var e=this,i=this.__getTextContent(t).split(""),n="",s=i.length;0<=s&&(!(n=i.slice(0,s).join("")).length||(e.__setTextContent(t,e._addEllipsis(n)),!e._fits()));s--);},_fits:function(){return this.$inner.innerHeight()<=this.maxHeight+this.opts.tolerance},_addEllipsis:function(t){for(var e=[" ","　",",",";",".","!","?"];-1<a.inArray(t.slice(-1),e);)t=t.slice(0,-1);return t+=this.__getTextContent(this.opts.ellipsis)},_getOriginalContent:function(){var i=this;return this.$dot.find("script, style").addClass(d.keep),this.opts.keep&&this.$dot.find(this.opts.keep).addClass(d.keep),this.$dot.find("*").not("."+d.keep).add(this.$dot).contents().each(function(){var t=this,e=a(this);if(3==t.nodeType){if(""==a.trim(i.__getTextContent(t))){if(e.parent().is("table, thead, tbody, tfoot, tr, dl, ul, ol, video"))return void e.remove();if(e.prev().is("div, p, table, td, td, dt, dd, li"))return void e.remove();if(e.next().is("div, p, table, td, td, dt, dd, li"))return void e.remove();if(!e.prev().length)return void e.remove();if(!e.next().length)return void e.remove()}}else 8==t.nodeType&&e.remove()}),this.$dot.contents()},_getMaxHeight:function(){if("number"==typeof this.opts.height)return this.opts.height;for(var t=["maxHeight","height"],e=0,i=0;i<t.length;i++)if("px"==(e=window.getComputedStyle(this.$dot[0])[t[i]]).slice(-2)){e=parseFloat(e);break}t=[];switch(this.$dot.css("boxSizing")){case"border-box":t.push("borderTopWidth"),t.push("borderBottomWidth");case"padding-box":t.push("paddingTop"),t.push("paddingBottom")}for(i=0;i<t.length;i++){var n=window.getComputedStyle(this.$dot[0])[t[i]];"px"==n.slice(-2)&&(e-=parseFloat(n))}return Math.max(e,0)},_watchSizes:function(t,e,i,n){if(this.$dot.is(":visible")){var s={width:e[i](),height:e[n]()};return t.width==s.width&&t.height==s.height||this.truncate(),s}return t},__getTextContent:function(t){for(var e=["nodeValue","textContent","innerText"],i=0;i<e.length;i++)if("string"==typeof t[e[i]])return t[e[i]];return""},__setTextContent:function(t,e){for(var i=["nodeValue","textContent","innerText"],n=0;n<i.length;n++)t[i[n]]=e}},a.fn[o]=function(t){return i(),t=a.extend(!0,{},a[o].defaults,t),this.each(function(){a(this).data(o,new a[o](a(this),t)._api())})});function i(){s=a(window),d={},t={},n={},a.each([d,t,n],function(t,n){n.add=function(t){for(var e=0,i=(t=t.split(" ")).length;e<i;e++)n[t[e]]=n.ddd(t[e])}}),d.ddd=function(t){return"ddd-"+t},d.add("truncated keep"),t.ddd=function(t){return"ddd-"+t},n.ddd=function(t){return t+".ddd"},n.add("resize"),i=function(){}}}(jQuery);
return true;
}));

/*
 * jQuery throttle / debounce - v1.1 - 3/7/2010
 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
(function (b, c) { var $ = b.jQuery || b.Cowboy || (b.Cowboy = {}), a; $.throttle = a = function (e, f, j, i) { var h, d = 0; if (typeof f !== "boolean") { i = j; j = f; f = c } function g() { var o = this, m = +new Date() - d, n = arguments; function l() { d = +new Date(); j.apply(o, n) } function k() { h = c } if (i && !h) { l() } h && clearTimeout(h); if (i === c && m > e) { l() } else { if (f !== true) { h = setTimeout(i ? k : l, i === c ? e - m : e) } } } if ($.guid) { g.guid = j.guid = j.guid || $.guid++ } return g }; $.debounce = function (d, e, f) { return f === c ? a(d, e, false) : a(d, f, e !== false) } })(this);
/*
/!\/!\/!\
Must be empty in _base/ theme
/!\/!\/!\
Go in each themes to override specific constant
*/

/**
 * @var {object} domReadyRegistry
 * @description Register of Functions Starting at DOM Ready
 */
var domReadyRegistry = {};

/**
 * @var {number} _duration=500
 * @description Default duration of JS animations
 */
// Basic Timing of JS Animations
var _duration = 250;


// BackstopJS
var bBackstopJS = false; // /!\ do not change this value
// it will be change to `true` when you launch BackstopJS reference and test
// when the value is set to `true` by the gulp-task,
// some js functions (with random state for example) are forces to specific state to avoid BackstopJS test failed.
// otherwise pages screen shot will be every time different and tests will always fail.

// classes Array for random display of gradients
var randomClassGradient = [];

if (bBackstopJS) {
  randomClassGradient.push('c-1-c-2');
  // force one specific value if backstop is launched
}
else {
  var iNbRainbowColor = iNbRainbowColor ? iNbRainbowColor : 7;
  for (var i = 1; i <= iNbRainbowColor; i++) {
    for (var j = 1; j <= iNbRainbowColor; j++) {
      if (i !== j) {
        randomClassGradient.push('c-' + i + '-c-' + j);
      }
    }
  }
}

// Tweakpoint
var tweakpoint = 1050;

(function ($) {
  if (bBackstopJS) {
    console.warn('If you see this warning, "backstop:prepare" has been launched last\n' +
      'If it\'s not expected, you need to relaunch "gulp scripts"');
    // force state
    $('html').addClass('backstop-is-running');

    // hide youtube iframe to avoid error on backstop test
    $('.wysiwyg iframe[src*=youtube], .layer-media iframe[src*=youtube]').each(function () {
      var $iframe = $(this);
      var $imgBackstop = $('<img>');
      $imgBackstop.attr({
        class: 'iframe-backstop',
        width: $iframe.attr('width'),
        height: $iframe.attr('height'),
        src: 'https://via.placeholder.com/' + $iframe.attr('width') + 'x' + $iframe.attr('height') + '.png?text=BackstopJS+Iframe+Replacement'
      });

      $iframe.hide().after($imgBackstop);
    });
  }
})(jQuery);

// Script to handle screen-touchable-capable

var historyCheck = false;
if (typeof Cookies.get('is-touchable') !== 'undefined' && Cookies.get('is-touchable') === 'true') {
  historyCheck = true;
}

Modernizr.addTest({
  touchable: historyCheck
});

window.addEventListener('touchstart', function () {

  Cookies.set('is-touchable', 'true', {path: '/'});
});

var animatedScrollTo;

(function ($) {

  /**
   * @function animatedScrollTo
   *
   * @description Animate the vertical scroll of the browser
   *
   * @param {(string|object|number)} param - Target CSS rule | jQuery object | Scroll value to reach
   * @param {function} callback - Callback
   * @return false
   */

  animatedScrollTo = function (param, callback) {

    var top;

    if (typeof param === 'string' || typeof param === 'object') {
      var target = $(param).eq(0);
      if (target.length) {
        top = target.offset().top;
      }
    }
    else if (typeof param === 'number') {
      top = param;
    }

    if (typeof top === 'number') {
      var params = {
        duration: (typeof _duration === 'number') ? _duration : 500,
        easing: (typeof jQuery.easing.easeInOutQuad === 'function') ? 'easeInOutQuad' : 'linear'
      };
      if (typeof callback === 'function') {
        params.complete = callback;
      }

      $('html, body').stop(true).animate({
        scrollTop: top
      }, params);
    }
    return false;
  };

})(jQuery);

var cfgManager;

(function ($) {

  /**
   * @function cfgManager
   * @description Managing configuration options
   *
   * @return {object}
   */

  cfgManager = function (defaults, cfg) {

    var output = {};

    var clonedDefaults = cloneObject(defaults);
    output = $.extend(clonedDefaults, cfg);

    // Save screen width
    var viewportWidth = getViewportWidth();

    if (typeof output.responsive === 'object') {
      $.each(output.responsive, function (breakpoint, inheritCfg) {
        var intBreakpoint = parseInt(breakpoint);
        // If the breakpoint is a number.
        // And if the width of the browser is less than the breakpoint declared
        if (!isNaN(intBreakpoint) && viewportWidth >= intBreakpoint) {
          output = $.extend(output, inheritCfg);
        }
      });
    }

    return output;
  };

})(jQuery);

var classifyBy;

(function ($) {

  /**
   * @function classifyBy
   * @description Sort an object array by a given key
   *
   * @param {array.<object>} datas - Array of objects to sort
   * @param {function} key - Name of the key for sorting
   *
   * @return {object.<array>} - Object with as many "key" as found. Each "key" is an array with objects from "datas" corresponding to the key found
   */

  classifyBy = function (datas, key) {

    var output = {};

    // We search for unique categories
    $.each(datas, function (i, data) {

      // We search for the key, and it must be in the form of a string
      if (typeof data[key] === 'string' && typeof output[data[key]] === 'undefined') {
        output[data[key]] = [];
      }
    });

    // We categorize the data
    $.each(datas, function (i, data) {

      if (typeof data[key] === 'string') {
        output[data[key]].push(data);
      }
    });
    return output;

  };

})(jQuery);

var cloneObject;

(function ($) {

  /**
   * @function cloneObject
   * @description Clone an object
   *
   * @param {object} datas - Object to be cloned
   *
   * @return {object} - Cloned object
   */

  cloneObject = function (datas) {

    var output = {};
    $.each(datas, function (key, data) {
      output[key] = data;
    });

    return output;

  };

})(jQuery);


/* global MobileDetect */
(function (window, Modernizr) {
  'use strict';
  var UA = navigator.userAgent;
  var ua = UA.toLowerCase();
  var md = new MobileDetect(UA);
  var grade = md.mobileGrade();

  Modernizr.addTest({
    mobile: !!md.mobile(),
    phone: !!md.phone(),
    tablet: !!md.tablet(),
    desktop: !md.tablet() && !md.phone(),
    ios: md.is('iOS'),
    android: md.is('AndroidOS'),
    chrome: ua.indexOf('chrome') > -1,
    // chrome: md.is('Chrome'),
    firefox: (md.is('Firefox') && md.version('Firefox') >= 12) || (md.version('Firefox') >= 4.0 && !md.mobile()),
    safari: ua.indexOf('safari') > -1 && ua.indexOf('chrome') === -1,
    ie: !!window.MSInputMethodContext && !!document.documentMode,
    edge: /Edge/.test(UA),
    opera: (md.version('Opera') >= 10 && !md.mobile()) || (md.is('Opera') && md.version('Opera Mobi') > 11 && md.is('AndroidOS')),
    mobilegradea: grade === 'A'
  });
  window.mobileDetect = md;
})(window, Modernizr);

(function ($) {

  var clientsideValidationSelectBlur = function () {

    var $elt = $(this);

    // If we use the "custom-select" script
    var $custom = $elt.parents('.custom-select');

    if ($custom.length) {
      if ($elt.hasClass('error')) {
        $custom.addClass('error');
      }
      else {
        $custom.removeClass('error');
      }
    }

  };

  // Define a Drupal behaviour with a custom name
  if (typeof Drupal !== 'undefined') {
    Drupal.behaviors.checkForm = {
      attach: function (context) {

        if (typeof Drupal.clientsideValidation === 'function') {

          Drupal.clientsideValidation.prototype.checkForm = function (message, formElt) {

            var parent = formElt.parents('.form-item:first');
            if (!parent.length) {
              parent = formElt.parent();
            }

            message.addClass('error-msg');
            message.addClass('type-' + formElt.attr('type'));

            parent.css('position', 'relative');

            $('.error-msg', parent).remove();
            var customSelect = $('.custom-select', parent);
            customSelect.addClass('error');

            if (formElt.is('select') && customSelect.length) {
              formElt.unbind('blur', clientsideValidationSelectBlur);
              formElt.bind('blur', clientsideValidationSelectBlur);
            }

            parent.append(message);
          };
        }
      }
    };
  }

})(jQuery);

(function ($) {

  var passwordStrength = function (context, settings) {

    // Drupal environment (context is the portion of the DOM concerned by the load page or ajax)
    if (typeof context !== 'undefined') {
      context = $(context);
    }

    // Development environment (context and settings are undefined)
    else {
      context = $(document);
    }

    var lowest = {
      r: 213,
      g: 32,
      b: 39
    };

    var highest = {
      r: 144,
      g: 184,
      b: 62
    };

    $('.password-strength', context).each(function () {
      var $target = $(this);
      if (!$target.data('init-password-strength')) {
        $target.data('init-password-strength', true);

        var $indicator = $('.password-indicator .indicator', $target);

        var $input = $target.nextAll('input.password-field');
        $input.keyup(function () {
          var ratio = $indicator.widthPercentage();
          var color = mixRgbColors(lowest, highest, ratio);
          $indicator.css('background-color', 'rgb(' + color.r + ', ' + color.g + ', ' + color.b + ')');
        });
      }
    });

  };

  // Drupal environment
  if (typeof Drupal !== 'undefined') {
    Drupal.behaviors.passwordStrength = {
      attach: passwordStrength
    };
  }
  // Development environment
  else {
    $(document).ready(function () {
      passwordStrength();
    });
  }

})(jQuery);

var getDatasFromHtml;

(function ($) {

  /**
   * @typedef {object} getDatasFromHtml_options_advanced - Advanced HTML parsing options configuration
   *
   * @property {object} rule - CSS rule of the targeted element
   * @property {object} cfg - Advanced configuration
   * @property {string} cfg.attribute - Targeted HTML attribute
   * @property {boolean} cfg.html=false - Return HTML content instead of text_node
   * @property {boolean} cfg.int=false - Ask to return the attribute under a typing number
   * @property {boolean} cfg.json=false - Ask to parse the jSON format with an attribute
   */

  /**
   * @typedef {object} getDatasFromHtml_options - HTML parsing options
   *
   * @property {(string|getDatasFromHtml_options_advanced)} - CSS rule of the targeted element | Advanced configuration
   */

  /**
   * @function getDatasFromHtml
   * @description Function to browse an element list in the HTML DOM, and return a jSON list with the parsed data
   *
   * @param {jQuery} $targets - jQuery items to browse
   * @param {array.<getDatasFromHtml_options>} cfg - Table Objects describing data to be parsed
   *
   * @return {array} - Returns an object array containing, for each DOM element found, the associated searched data
   */

  getDatasFromHtml = function ($targets, cfg) {

    // Output data model
    var output = [];

    // Default configuration
    var defaults = {
      html: false,
      int: false,
      json: false
    };

    // Clone an object
    var cloneObject = function (datas) {

      var output = {};
      $.each(datas, function (key, data) {
        output[key] = data;
      });

      return output;

    };

    // We go through the list
    $targets.each(function () {
      // Item de liste
      var $item = $(this);

      // We create a jSON to store the data
      var entry = {
        $elt: $item
      };

      // We go through the configuration
      $.each(cfg, function (key, unit) {

        // According to the information that is sought, different treatment is applied
        switch (typeof unit) {

          // If it's an object. Advanced configuration
          case 'object':

            // We check that the 2 pre-required keys for the complex configuration are present
            if (typeof unit.rule === 'string' && typeof unit.cfg === 'object') {

              // We're recovering the target
              var $target;
              if (unit.rule === ':self') {
                $target = $item;
              }
              else {
                $target = $(unit.rule + ':first', $item);
              }

              // We're checking to see if we've found the target.
              if ($target.length) {

                var output;

                // Clone the default configuration
                var options = cloneObject(defaults);
                options = $.extend(options, unit.cfg);

                // We check if it is an HTML attribute that we target or not
                if (typeof options.attribute === 'string') {

                  // We get the attribute
                  output = $target.attr(options.attribute);

                }
                // Otherwise, it is that we are looking for the content of an element of the HTML DOM
                else {

                  // If you are looking for content in HTML format
                  if (typeof options.html === 'boolean' && options.html) {

                    // We get the HTML
                    output = $target.html();

                  }
                  else {

                    // We get the HTML
                    output = $.trim($target.text());

                  }

                }

                // We're looking for a floating
                if (typeof options.int === 'boolean' && options.int) {

                  // We parse a float
                  output = parseFloat(output);

                }

                // We're looking for a json
                else if (typeof options.json === 'boolean' && options.json) {

                  // We parse a float
                  output = $.parseJSON(output);

                }

                // The content is added
                entry[key] = output;
              }
              else {
                entry[key] = null;
              }

            }

            break;

          // string: Simple access. CSS rule (from the list item), to retrieve the DOM text
          default:

            // We're recovering the target
            var $targetElt = $(unit + ':first', $item);

            // If an element has been found, the HTML content is added
            if ($targetElt.length) {
              entry[key] = $.trim($targetElt.text());
            }
            // Otherwise, we return an empty
            else {
              entry[key] = null;
            }

            break;
        }
      });

      // We add to OUTPUT
      output.push(entry);
    });

    // OUTPUT
    return output;
  };

})(jQuery);

var getViewportWidth;

(function ($) {

  /**
   * @function getViewportWidth
   * @description Connaître la largeur de la fenêtre du navigateur
   *
   * @return {number}
   */

  getViewportWidth = function () {

    // Checking the screen width
    var viewportWidth;

    // For most browsers
    if (typeof window.outerWidth !== 'undefined') {
      viewportWidth = window.outerWidth;
    }

    // For IE8 and the same type, the responsive mode is bypassed
    else {
      viewportWidth = -Number.NEGATIVE_INFINITY;
    }

    // For iOs window.outerWidth returns 0
    if (viewportWidth === 0) {

      // If you're in a portrait
      if (typeof window.orientation !== 'undefined') {
        if (window.orientation === 0 || window.orientation === 180) {
          viewportWidth = screen.width;
        }
        else if (window.orientation === 90 || window.orientation === -90) {
          if (screen.availWidth > screen.width) {
            viewportWidth = screen.availWidth;
          }
          else {
            viewportWidth = $(window).width();
          }
        }
      }
    }

    return viewportWidth;
  };

})(jQuery);

/*
 * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
 *
 * Uses the built in easing capabilities added In jQuery 1.1
 * to offer multiple easing options
 *
 * TERMS OF USE - jQuery Easing
 *
 * Open source under the BSD License.
 *
 * Copyright Â© 2008 George McGinley Smith
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * Neither the name of the author nor the names of contributors may be used to endorse
 * or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

// t: current time, b: begInnIng value, c: change In value, d: duration
jQuery.easing.jswing = jQuery.easing.swing;

jQuery.extend(jQuery.easing,
  {
    def: 'easeOutQuad',
    swing: function (x, t, b, c, d) {
      // alert(jQuery.easing.default);
      return jQuery.easing[jQuery.easing.def](x, t, b, c, d);
    },
    easeInQuad: function (x, t, b, c, d) {
      return c * (t /= d) * t + b;
    },
    easeOutQuad: function (x, t, b, c, d) {
      return -c * (t /= d) * (t - 2) + b;
    },
    easeInOutQuad: function (x, t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t + b;
      }
      return -c / 2 * ((--t) * (t - 2) - 1) + b;
    },
    easeInCubic: function (x, t, b, c, d) {
      return c * (t /= d) * t * t + b;
    },
    easeOutCubic: function (x, t, b, c, d) {
      return c * ((t = t / d - 1) * t * t + 1) + b;
    },
    easeInOutCubic: function (x, t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t * t + b;
      }
      return c / 2 * ((t -= 2) * t * t + 2) + b;
    },
    easeInQuart: function (x, t, b, c, d) {
      return c * (t /= d) * t * t * t + b;
    },
    easeOutQuart: function (x, t, b, c, d) {
      return -c * ((t = t / d - 1) * t * t * t - 1) + b;
    },
    easeInOutQuart: function (x, t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t * t * t + b;
      }
      return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
    },
    easeInQuint: function (x, t, b, c, d) {
      return c * (t /= d) * t * t * t * t + b;
    },
    easeOutQuint: function (x, t, b, c, d) {
      return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
    },
    easeInOutQuint: function (x, t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t * t * t * t + b;
      }
      return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
    },
    easeInSine: function (x, t, b, c, d) {
      return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
    },
    easeOutSine: function (x, t, b, c, d) {
      return c * Math.sin(t / d * (Math.PI / 2)) + b;
    },
    easeInOutSine: function (x, t, b, c, d) {
      return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
    },
    easeInExpo: function (x, t, b, c, d) {
      return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
    },
    easeOutExpo: function (x, t, b, c, d) {
      return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
    },
    easeInOutExpo: function (x, t, b, c, d) {
      if (t === 0) {
        return b;
      }
      if (t === d) {
        return b + c;
      }
      if ((t /= d / 2) < 1) {
        return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
      }
      return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
    },
    easeInCirc: function (x, t, b, c, d) {
      return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
    },
    easeOutCirc: function (x, t, b, c, d) {
      return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
    },
    easeInOutCirc: function (x, t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
      }
      return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
    },
    easeInElastic: function (x, t, b, c, d) {
      var s = 1.70158;
      var p = 0;
      var a = c;
      if (t === 0) {
        return b;
      }
      if ((t /= d) === 1) {
        return b + c;
      }
      if (!p) {
        p = d * 0.3;
      }
      if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
      }
      else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
      return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
    },
    easeOutElastic: function (x, t, b, c, d) {
      var s = 1.70158;
      var p = 0;
      var a = c;
      if (t === 0) {
        return b;
      }
      if ((t /= d) === 1) {
        return b + c;
      }
      if (!p) {
        p = d * 0.3;
      }
      if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
      }
      else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
      return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
    },
    easeInOutElastic: function (x, t, b, c, d) {
      var s = 1.70158;
      var p = 0;
      var a = c;
      if (t === 0) {
        return b;
      }
      if ((t /= d / 2) === 2) {
        return b + c;
      }
      if (!p) {
        p = d * (0.3 * 1.5);
      }
      if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
      }
      else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
      if (t < 1) {
        return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
      }
      return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
    },
    easeInBack: function (x, t, b, c, d, s) {
      if (typeof s === 'undefined') {
        s = 1.70158;
      }
      return c * (t /= d) * t * ((s + 1) * t - s) + b;
    },
    easeOutBack: function (x, t, b, c, d, s) {
      if (typeof s === 'undefined') {
        s = 1.70158;
      }
      return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    },
    easeInOutBack: function (x, t, b, c, d, s) {
      if (typeof s === 'undefined') {
        s = 1.70158;
      }
      if ((t /= d / 2) < 1) {
        return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
      }
      return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
    },
    easeInBounce: function (x, t, b, c, d) {
      return c - jQuery.easing.easeOutBounce(x, d - t, 0, c, d) + b;
    },
    easeOutBounce: function (x, t, b, c, d) {
      if ((t /= d) < (1 / 2.75)) {
        return c * (7.5625 * t * t) + b;
      }
      else if (t < (2 / 2.75)) {
        return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
      }
      else if (t < (2.5 / 2.75)) {
        return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
      }
      else {
        return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
      }
    },
    easeInOutBounce: function (x, t, b, c, d) {
      if (t < d / 2) {
        return jQuery.easing.easeInBounce(x, t * 2, 0, c, d) * 0.5 + b;
      }
      return jQuery.easing.easeOutBounce(x, t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
    }
  });

/*
 *
 * TERMS OF USE - EASING EQUATIONS
 *
 * Open source under the BSD License.
 *
 * Copyright Â© 2001 Robert Penner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * Neither the name of the author nor the names of contributors may be used to endorse
 * or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

var localSettings;

(function ($) {
  /*eslint-disable*/
  localSettings = {
    top: Drupal.t("Top"),
    all: Drupal.t("All"),
    clear_all: Drupal.t("Clear all"),
    submit: Drupal.t("Submit"),
    add_attachment: Drupal.t("+ Add an attachment"),
    replace_attachment: Drupal.t("+ Replace attachment"),
    what_are_you_looking_for: Drupal.t("What are you looking for?"),
    type_keyword: Drupal.t("Type keyword")
  };
  /*eslint-enabled*/
  // /!\ Don't forget to update also localSettingsStatic in _base/bin/html/includes/_head.html
  // (localSettingsStatic needs to be set for BVN subtheme)

  // override localSettings with localSettingsStatic if existing
  if (typeof localSettingsStatic !== 'undefined') {
    localSettings = $.extend({}, localSettingsStatic);
  }

})(jQuery);

/**
 * @typedef {object} mixRgbColors_color - Format of the expected color object
 *
 * @property {string} r - Red
 * @property {string} g - Green
 * @property {string} b - Blue
 */

/**
 * @function mixRgbColors
 *
 * @description Mix 2 colours
 *
 * @param {mixRgbColors_color} color1 - Color 1
 * @param {mixRgbColors_color} color2 - Color 2
 * @param {number} weight - Mixture weight
 * @return false
 */

var mixRgbColors = function (color1, color2, weight) {

  return {
    r: Math.round(color1.r + (color2.r - color1.r) * (weight / 100)),
    g: Math.round(color1.g + (color2.g - color1.g) * (weight / 100)),
    b: Math.round(color1.b + (color2.b - color1.b) * (weight / 100))
  };
};

(function ($) {

  /**
   * @function objectFit
   * @description Hack for IE
   */

  var objectFit = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'js-imgCover';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);
      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        if (!Modernizr.objectfit) {
          var $img = $('img', $target);
          $target.css({
            'background-image': 'url(' + $img.attr('src') + ')',
            'background-size': 'cover',
            'background-position': 'center'
          });
          $img.css('opacity', 0);
        }
      }
    });
  };

  Drupal.behaviors.objectFit = {
    attach: objectFit
  };

})(jQuery);

var Preloader;

(function ($) {

  Preloader = function (cfg) {

    this.init = function () {
      cfg.init(this);
    };

    this.start = function () {
      // Start loading images
      var total = cfg.list.length;
      this.load(cfg, 0, total);
    };

    this.load = function (cfg, id, total) {

      // Creating an IMG jQuery tag
      var src = cfg.relPath + cfg.list[id];
      var img = $('<img src="' + src + '" alt="" />');
      // Saving the context
      var obj = this;

      // Function to be executed at the end of the loading of each image
      var loaded = function () {
        id++;
        // Calculation of the percentage
        var percent = Math.ceil((id / total) * 100);
        // Calling the function for each loaded image
        cfg.update(percent, img, cfg);
        // If there are images left to load, we preload them
        if (id < total) {
          obj.load(cfg, id, total);
        }
      };

      // For all browsers
      function imgObserver() {
        if (img[0].complete) {
          clearInterval(imgObserverIntv);
          loaded();
        }
      }

      var imgObserverIntv = setInterval(imgObserver, 100);
    };
  };

})(jQuery);



(function ($) {

  /**
   * @function animatedScrollTo
   *
   * @description Animate the vertical scroll of the browser
   *
   * @param {(string|object|number)} param - Target CSS rule | jQuery object |
   *   Scroll value to reach
   * @param {function} callback - Callback
   * @return false
   */

  var scrollToHash = function (param, callback) {

    $('body').on('click', '.js-scroll-to-hash', function (event) {
      event.stopPropagation();
      event.preventDefault();
      var $target = $($(this).attr('href'));

      if ($target.length) {
        var topPos = $target.eq(0).offset().top - 156;

        animatedScrollTo(topPos);
      }
    });
  };

  scrollToHash();

})(jQuery);

// JS Add target _blank

(function ($) {

  /**
   * @function targetBlank
   * @description force target blank on external link
   */

  var targetBlank = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var $targets = $('a[href^=http]:not([target])', context);
    $targets.each(function () {
      var $target = $(this);

      // Skip exceptions.
      if (
        $target.hasClass('js-no-auto-target-blank') ||
        $target.closest('.js-no-auto-target-blank-inside').length > 0
      ) {
        return true;
      }
      var domain = document.domain.replace('www.', '');
      var href = $target.attr('href');
      // ignore https://, http:// and www. of the href
      var hrefTest = href.replace('http://', '').replace('https://', '').replace('www.', '');
      if (hrefTest.indexOf(domain) !== 0) { // if domain is not the same has target
        $target.attr({target: '_blank'});
      }
    });

    var $targetsPdf = $('a[href$=".pdf"]:not([target])', context);
    $targetsPdf.each(function () {
      var $target = $(this);
      $target.attr({target: '_blank'});
    });
  };

  Drupal.behaviors.targetBlank = {
    attach: targetBlank
  };

})(jQuery);


var transitionEvent;

(function ($) {

  /**
   * @function whichTransitionEvent
   *
   * @description Get the good transition end name
   *
   * @return 'transitionEventName'|false
   */

  // Function from David Walsh: http://davidwalsh.name/css-animation-callback
  function whichTransitionEvent() {
    var t;
    var el = document.createElement('fakeelement');

    var transitions = {
      transition: 'transitionend',
      OTransition: 'oTransitionEnd',
      MozTransition: 'transitionend',
      WebkitTransition: 'webkitTransitionEnd'
    };

    for (t in transitions) {
      if (typeof el.style[t] !== 'undefined') {
        return transitions[t];
      }
    }

    return false; // explicit for ie8 (  ._.)
  }

  transitionEvent = whichTransitionEvent();

})(jQuery);

(function ($) {

  $.fn.extend({

    /**
     * @function external:"jQuery.fn".widthPercentage
     * @description Calculate a width as a percentage
     *
     * @return {number} percentage value with respect to parent
     */

    widthPercentage: function () {

      // Number of digits after the decimal point
      var round = 5;

      var parent = this.parent();

      return Math.round((this.width() * 100) / parent.width() * Math.pow(10, round)) / Math.pow(10, round);
    }
  });

})(jQuery);

var grayscale = function () {
  var e = {
    colorProps: ["color", "backgroundColor", "borderBottomColor", "borderTopColor", "borderLeftColor", "borderRightColor", "backgroundImage"],
    externalImageHandler: {
      init: function (e, t) {
        if (e.nodeName.toLowerCase() === "img") {
        }
        else {
          r(e).backgroundImageSRC = t;
          e.style.backgroundImage = ""
        }
      }, reset: function (e) {
        if (e.nodeName.toLowerCase() === "img") {
        }
        else {
          e.style.backgroundImage = "url(" + (r(e).backgroundImageSRC || "") + ")"
        }
      }
    }
  }, t = function () {
    try {
      window.console.log.apply(console, arguments)
    }
    catch (e) {
    }
  }, n = function (e) {
    return (new RegExp("https?://(?!" + window.location.hostname + ")")).test(e)
  }, r = function () {
    var e = [0], t = "data" + +(new Date);
    return function (n) {
      var r = n[t], i = e.length;
      if (!r) {
        r = n[t] = i;
        e[r] = {}
      }
      return e[r]
    }
  }(), i = function (e, t, n) {
    var s = document.createElement("canvas"), u = s.getContext("2d"),
      a = e.naturalHeight || e.offsetHeight || e.height,
      f = e.naturalWidth || e.offsetWidth || e.width, l;
    s.height = a;
    s.width = f;
    u.drawImage(e, 0, 0);
    try {
      l = u.getImageData(0, 0, f, a)
    }
    catch (c) {
    }
    if (t) {
      i.preparing = true;
      var h = 0;
      (function () {
        if (!i.preparing) {
          return
        }
        if (h === a) {
          u.putImageData(l, 0, 0, 0, 0, f, a);
          n ? r(n).BGdataURL = s.toDataURL() : r(e).dataURL = s.toDataURL()
        }
        for (var t = 0; t < f; t++) {
          var c = (h * f + t) * 4;
          l.data[c] = l.data[c + 1] = l.data[c + 2] = o(l.data[c], l.data[c + 1], l.data[c + 2])
        }
        h++;
        setTimeout(arguments.callee, 0)
      })();
      return
    }
    else {
      i.preparing = false
    }
    for (var h = 0; h < a; h++) {
      for (var p = 0; p < f; p++) {
        var d = (h * f + p) * 4;
        l.data[d] = l.data[d + 1] = l.data[d + 2] = o(l.data[d], l.data[d + 1], l.data[d + 2])
      }
    }
    u.putImageData(l, 0, 0, 0, 0, f, a);
    return s
  }, s = function (e, t) {
    var n = document.defaultView && document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(e, null)[t] : e.currentStyle[t];
    if (n && /^#[A-F0-9]/i.test(n)) {
      var r = n.match(/[A-F0-9]{2}/ig);
      n = "rgb(" + parseInt(r[0], 16) + "," + parseInt(r[1], 16) + "," + parseInt(r[2], 16) + ")"
    }
    return n
  }, o = function (e, t, n) {
    return parseInt(.2125 * e + .7154 * t + .0721 * n, 10)
  }, u = function (e) {
    var t = Array.prototype.slice.call(e.getElementsByTagName("*"));
    t.unshift(e);
    return t
  };
  var a = function (t) {
    if (t && t[0] && t.length && t[0].nodeName) {
      var f = Array.prototype.slice.call(t), l = -1, c = f.length;
      while (++l < c) {
        a.call(this, f[l])
      }
      return
    }
    t = t || document.documentElement;
    if (!document.createElement("canvas").getContext) {
      t.style.filter = "progid:DXImageTransform.Microsoft.BasicImage(grayscale=1)";
      t.style.zoom = 1;
      return
    }
    var h = u(t), p = -1, d = h.length;
    while (++p < d) {
      var v = h[p];
      if (v.nodeName.toLowerCase() === "img") {
        var m = v.getAttribute("src");
        if (!m) {
          continue
        }
        if (n(m)) {
          e.externalImageHandler.init(v, m)
        }
        else {
          r(v).realSRC = m;
          try {
            v.src = r(v).dataURL || i(v).toDataURL()
          }
          catch (g) {
            e.externalImageHandler.init(v, m)
          }
        }
      }
      else {
        for (var y = 0, b = e.colorProps.length; y < b; y++) {
          var w = e.colorProps[y], E = s(v, w);
          if (!E) {
            continue
          }
          if (v.style[w]) {
            r(v)[w] = E
          }
          if (E.substring(0, 4) === "rgb(") {
            var S = o.apply(null, E.match(/\d+/g));
            v.style[w] = E = "rgb(" + S + "," + S + "," + S + ")";
            continue
          }
          if (E.indexOf("url(") > -1) {
            var x = /\(['"]?(.+?)['"]?\)/, T = E.match(x)[1];
            if (n(T)) {
              e.externalImageHandler.init(v, T);
              r(v).externalBG = true;
              continue
            }
            try {
              var N = r(v).BGdataURL || function () {
                var e = document.createElement("img");
                e.src = T;
                return i(e).toDataURL()
              }();
              v.style[w] = E.replace(x, function (e, t) {
                return "(" + N + ")"
              })
            }
            catch (g) {
              e.externalImageHandler.init(v, T)
            }
          }
        }
      }
    }
  };
  a.reset = function (t) {
    if (t && t[0] && t.length && t[0].nodeName) {
      var i = Array.prototype.slice.call(t), s = -1, o = i.length;
      while (++s < o) {
        a.reset.call(this, i[s])
      }
      return
    }
    t = t || document.documentElement;
    if (!document.createElement("canvas").getContext) {
      t.style.filter = "progid:DXImageTransform.Microsoft.BasicImage(grayscale=0)";
      return
    }
    var f = u(t), l = -1, c = f.length;
    while (++l < c) {
      var h = f[l];
      if (h.nodeName.toLowerCase() === "img") {
        var p = h.getAttribute("src");
        if (n(p)) {
          e.externalImageHandler.reset(h, p)
        }
        h.src = r(h).realSRC || p
      }
      else {
        for (var d = 0, v = e.colorProps.length; d < v; d++) {
          if (r(h).externalBG) {
            e.externalImageHandler.reset(h)
          }
          var m = e.colorProps[d];
          h.style[m] = r(h)[m] || ""
        }
      }
    }
  };
  a.prepare = function (e) {
    if (e && e[0] && e.length && e[0].nodeName) {
      var t = Array.prototype.slice.call(e), o = -1, f = t.length;
      while (++o < f) {
        a.prepare.call(null, t[o])
      }
      return
    }
    e = e || document.documentElement;
    if (!document.createElement("canvas").getContext) {
      return
    }
    var l = u(e), c = -1, h = l.length;
    while (++c < h) {
      var p = l[c];
      if (r(p).skip) {
        return
      }
      if (p.nodeName.toLowerCase() === "img") {
        if (p.getAttribute("src") && !n(p.src)) {
          i(p, true)
        }
      }
      else {
        var d = s(p, "backgroundImage");
        if (d.indexOf("url(") > -1) {
          var v = /\(['"]?(.+?)['"]?\)/, m = d.match(v)[1];
          if (!n(m)) {
            var g = document.createElement("img");
            g.src = m;
            i(g, true, p)
          }
        }
      }
    }
  };
  return a
};

/*
 * jQuery Stick Table Headers - v2.0.0
 * https://github.com/jpchip/stickytable
 *
 * Wrapped version of sticky table headers code here:
 * http://tympanus.net/codrops/2014/01/09/sticky-table-headers-columns/
 * http://tympanus.net/Tutorials/StickyTableHeaders/
 *
 * CSS located in jquery-stickytable.css
 *
 * Depends:
 * jQuery
 * jQuery throttle / debounce - v1.1 - 3/7/2010
 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
 *
 */
(function ($, window, document, undefined) {
	'use strict';

	var pluginName = 'stickyTable',
	defaults = {
		deltaTop: 0,
		copyTableClass: true, //copies table classes to sticky tables
		copyEvents: false, //copy events on headers and cols to sticky tables
		overflowy: false //if true limits height of table to height of parent element
	};

	function StickyTable(element, options) {
		this.element = element;
		this._defaults = defaults;
		this._name = pluginName;

		this.options = $.extend({}, defaults, options);

		this._init();
	}

	StickyTable.prototype._init = function () {
		var $w = $(window),
			$t = $(this.element),
			classList = [],
			$thead,
			$col,
			$stickyHead,
			$stickyCol,
			$stickyInsct,
			$stickyWrap,
			setWidths,
			repositionStickyHead,
			repositionStickyCol,
			calcAllowance;

		if (!$(this.element).is("table")) {
			$.error('Target element must be a table');
		}

		//don't run this function again on same element!
		if ($(this.element).hasClass("sticky-enabled")) {
			return;
		}

		$t.data({options: this.options});
		if ($t.find('thead').length > 0 && $t.find('th').length > 0) {
			// Clone <thead>
			$thead = $t.find('thead').clone(this.options.copyEvents);
			$col = $t.find('thead, tbody').clone(this.options.copyEvents);

			// Add class, remove margins, reset width and wrap table
			$t.css({
				margin: 0,
				width: '100%'
			}).wrap('<div class="sticky-wrap" />');

			if (this.options.overflowy) {
				$t.parent().addClass('overflow-y');
			}

			if ($t.attr('class')) {
				classList = $t.attr('class').split(/\s+/);
			}

			$t.addClass('sticky-enabled');

			// Create new sticky table head (basic)
			$t.after('<table class="sticky-thead" />');

			// If <tbody> contains <th>, then we create sticky column and intersect (advanced)
			if ($t.find('tbody th').length > 0) {
				$t.after('<table class="sticky-col" /><table class="sticky-intersect" />');
			}

			// Create shorthand for things
			$stickyHead = $t.siblings('.sticky-thead');
			$stickyCol = $t.siblings('.sticky-col');
			$stickyInsct = $t.siblings('.sticky-intersect');
			$stickyWrap = $t.parent('.sticky-wrap');


			if (this.options.copyTableClass) {
				$.each(classList, function (index, item) {
					$stickyHead.addClass(item);
					$stickyCol.addClass(item);
					$stickyInsct.addClass(item);
				});
			}

			$stickyHead.append($thead);

			$stickyCol.append($col)
				.find('thead th:gt(0)').remove()
				.end()
				.find('tbody td').remove();

			$stickyInsct.html('<thead><tr><th>' + $t.find('thead th:first-child').html() + '</th></tr></thead>');
			$stickyInsct.find('th').height($t.find('thead th:first-child').outerHeight());

			// remote checkbox/radio

			$stickyWrap.find('input[type=checkbox], input[type=radio]').each(function () {
				var $input = $(this);
				var id = $input.attr('id');
				var name = $input.attr('name');
				var suffix = $input.closest('.sticky-thead').length ? '-thead' :
					($input.closest('.sticky-col').length ? '-col' :
							($input.closest('.sticky-intersect').length ? '-intersect' : '')
					);
				$input.attr('id', id + suffix);
				$input.attr('name', name + suffix);
				$input.next('label').attr('for', id + suffix);
				$input.attr('data-sticky-table-input-id', id);

				$input.on('change', function () {
					var checked =  $(this).is(':checked');
					var $inputs = $('[data-sticky-table-input-id=' + $input.data('sticky-table-input-id') + ']').not($(this));
					$inputs.each(function () {
						$(this).prop('checked', checked);
						if(checked) {
							$(this).attr('checked', 'checked');
						}
						else {
							$(this).removeAttr('checkec');
						}
					})
				});
			});

			setWidths = function () {
				$t.find('thead th').each(function (i) {
					$stickyHead.find('th').eq(i).width($(this).outerWidth());
				})
					.end()
					.find('tr').each(function (i) {
						$stickyCol.find('tr').eq(i).height($(this).outerHeight());
					});

				// Set width of sticky table head
				$stickyHead.width($t.outerWidth());

				// Set width of sticky table col
				$stickyCol.find('th').add($stickyInsct.find('th')).width($t.find('thead th').outerWidth());
			};

			repositionStickyHead = function () {
				// Return value of calculated allowance
				var allowance = calcAllowance();
                var deltaTopindex =  $t.data('options').deltaTop;

				// Check if wrapper parent is overflowing along the y-axis
				if ($t.outerHeight() > $stickyWrap.outerHeight()) {
					// If it is overflowing (advanced layout)
					// Position sticky header based on wrapper scrollTop()
					if ($stickyWrap.scrollTop() + deltaTopindex > 0 ) {
						// When top of wrapping parent is out of view
						$stickyHead.add($stickyInsct).css({
							opacity: 1,
							top: $stickyWrap.scrollTop() + deltaTopindex
						});
					} else {
						// When top of wrapping parent is in view
						$stickyHead.add($stickyInsct).css({
							opacity: 0,
							top: 0
						});
					}
				} else {
					// If it is not overflowing (basic layout)
					// Position sticky header based on viewport scrollTop
					if ($w.scrollTop() + deltaTopindex > $t.offset().top && $w.scrollTop() + deltaTopindex < $t.offset().top + $t.outerHeight() - allowance) {
						// When top of viewport is in the table itself
						$stickyHead.add($stickyInsct).css({
							opacity: 1,
							top: $w.scrollTop() - $t.offset().top + deltaTopindex
						});
					} else {
						// When top of viewport is above or below table
						$stickyHead.add($stickyInsct).css({
							opacity: 0,
							top: 0
						});
					}
				}
			};

			repositionStickyCol = function () {
				if ($stickyWrap.scrollLeft() > 0) {
					// When left of wrapping parent is out of view
					$stickyCol.add($stickyInsct).css({
						opacity: 1,
						left: $stickyWrap.scrollLeft()
					});
				} else {
					// When left of wrapping parent is in view
					$stickyCol.css({
						opacity: 0
					})
						.add($stickyInsct).css({
							left: 0
						});
				}
			};

			calcAllowance = function () {
				var a = 0;
				// Calculate allowance
				$t.find('tbody tr:lt(3)').each(function () {
					a += $t.outerHeight();
				});

				// Set fail safe limit (last three row might be too tall)
				// Set arbitrary limit at 0.25 of viewport height, or you can use an arbitrary pixel value
				if (a > $w.outerHeight() * 0.25) {
					a = $w.outerHeight() * 0.25;
				}

				// Add the height of sticky header
				a += $stickyHead.outerHeight();
				return a;
			};

			setWidths();

			$t.parent('.sticky-wrap').scroll(function () {
				repositionStickyHead();
				repositionStickyCol();
			});

			$w.load(setWidths)
				.resize($.debounce(250, function () {
					setWidths();
					repositionStickyHead();
					repositionStickyCol();
				}))
				.scroll(repositionStickyHead);
		}
	};

	StickyTable.prototype.destroy = function () {
		var $t = $(this.element),
			$stickyHead = $t.siblings('.sticky-thead'),
			$stickyCol = $t.siblings('.sticky-col'),
			$stickyInsct = $t.siblings('.sticky-intersect');

		this.options = $.extend({}, defaults);

		if ($t.hasClass('sticky-enabled')) {
			$stickyHead.remove();
			$stickyCol.remove();
			$stickyInsct.remove();

			$t.unwrap();
			$t.removeClass('sticky-enabled');
			//todo: clear events...
		}
		$.removeData(this.element, 'plugin_' + this._name);
	};

	$.fn[pluginName] = function (options) {
		return this.each(function () {
			var instance = $.data(this, 'plugin_' + pluginName);
			if (instance) {
				if (typeof options === 'string' || options instanceof String) {
					if (instance[options] !== undefined && $.isFunction(instance[options])) {
						if (options.indexOf('_') !== -1) {
							$.error('Method ' + options + ' is private!');
						} else {
							instance[options](Array.prototype.slice.call(arguments, 1));
						}
					} else {
						$.error('Method ' + options + ' does not exist.');
					}
				}
			} else if (typeof options === 'object' || !options) {
				$.data(this, 'plugin_' + pluginName, new StickyTable(this, options));
			} else {
				$.error('Plugin must be initialised before using method: ' + options);
			}
		});
	};

}(jQuery, window, document));

/*
	scrollorama - The jQuery plugin for doing cool scrolly stuff
	by John Polacek (@johnpolacek)

	Dual licensed under MIT and GPL.
*/


(function ($) {
  $.scrollorama = function (options) {

    var scrollorama = {};
    var blocks = [];
    var browserPrefix = '';
    var ieVersion = '';
    var onBlockChange = function () {
      // Do some thing
    };
    var ticking = false;
    var requestAnimFrame = window.requestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      function (callback) {
        window.setTimeout(callback, 1000 / 60);
      };
    var defaults = {offset: 0, enablePin: true};

    scrollorama.settings = $.extend({}, defaults, options);
    scrollorama.blockIndex = 0;

    if (typeof options.blocks === 'undefined') {
      alert('ERROR: Must assign blocks class selector to scrollorama plugin');
    }

    // PRIVATE FUNCTIONS
    function init() {
      var i;
      var block;
      var marginTop = false;
      if (typeof scrollorama.settings.blocks === 'string') {
        scrollorama.settings.blocks = $(scrollorama.settings.blocks);
      }

      // set browser prefix (using getBrowser based on jQuery’s $.browser)
      var browser = getBrowser();
      if (browser.mozilla) {
        browserPrefix = '-moz-';
      }
      if (browser.webkit) {
        browserPrefix = '-webkit-';
      }
      if (browser.opera) {
        browserPrefix = '-o-';
      }
      if (browser.msie) {
        browserPrefix = '-ms-';
        ieVersion = parseInt(browser.version, 10);
      }

      // create blocks array to contain animation props
      $('body').css('position', 'relative');
      for (i = 0; i < scrollorama.settings.blocks.length; i++) {
        block = scrollorama.settings.blocks.eq(i);
        marginTop = block.css('margin-top');
        blocks.push({
          block: block,
          top: block.offset().top - (typeof marginTop !== 'boolean' ? parseInt(marginTop, 10) : 0),
          pin: 0,
          animations: []
        });
      }

      // convert block elements to absolute position
      if (scrollorama.settings.enablePin.toString() === 'true') {
        for (i = 0; i < blocks.length; i++) {
          blocks[i].block
            .css('position', 'absolute')
            .css('top', blocks[i].top);
        }
      }

      // create scroll-wrap div only once
      if ($('#scroll-wrap').length === 0) {
        $('body').prepend('<div id="scroll-wrap"></div>');
      }

      ticking = false;
      $(window).on('scroll.scrollorama', onScroll);
    }

    function onScroll() {
      requestTick();
    }

    function requestTick() {
      if (!ticking) {
        requestAnimFrame(function () {
          onScrollorama();
          update();
        });
      }
      ticking = true;
    }

    function update() {
      // reset the tick so we can
      // capture the next onScroll
      ticking = false;
    }

    function onScrollorama() {
      var scrollTop = $(window).scrollTop();
      var currBlockIndex = getCurrBlockIndex(scrollTop);
      var i;
      var j;
      var anim;
      var startAnimPos;
      var endAnimPos;
      var animPercent;
      var animVal;

      // update all animations
      for (i = 0; i < blocks.length; i++) {

        // go through the animations for each block
        if (blocks[i].animations.length) {
          for (j = 0; j < blocks[i].animations.length; j++) {
            anim = blocks[i].animations[j];

            // if above current block, settings should be at start value
            if (i > currBlockIndex) {
              if (currBlockIndex !== i - 1 && anim.baseline !== 'bottom') {
                setProperty(anim, anim.startVal);
              }
              if (blocks[i].pin) {
                blocks[i].block
                  .css('position', 'absolute')
                  .css('top', blocks[i].top);
              }
            }

            // if below current block, settings should be at end value
            // unless on an element that gets animated when it hits the bottom
            // of the viewport
            else if (i < currBlockIndex) {
              setProperty(anim, anim.endVal);
              if (blocks[i].pin) {
                blocks[i].block
                  .css('position', 'absolute')
                  .css('top', (blocks[i].top + blocks[i].pin));
              }
            }

            // otherwise, set values per scroll position
            if (i === currBlockIndex || (currBlockIndex === i - 1 && anim.baseline === 'bottom')) {
              // if block gets pinned, set position fixed
              if (blocks[i].pin && currBlockIndex === i) {
                blocks[i].block
                  .css('position', 'fixed')
                  .css('top', 0);
              }

              // set start and end animation positions
              startAnimPos = blocks[i].top + anim.delay;
              if (anim.baseline === 'bottom') {
                startAnimPos -= $(window).height();
              }
              endAnimPos = startAnimPos + anim.duration;

              // if scroll is before start of animation, set to start value
              if (scrollTop < startAnimPos) {
                setProperty(anim, anim.startVal);
              }

              // if scroll is after end of animation, set to end value
              else if (scrollTop > endAnimPos) {
                setProperty(anim, anim.endVal);
                if (blocks[i].pin) {
                  blocks[i].block
                    .css('position', 'absolute')
                    .css('top', (blocks[i].top + blocks[i].pin));
                }
              }

              // otherwise, set value based on scroll
              else {
                // calculate percent to animate
                animPercent = (scrollTop - startAnimPos) / anim.duration;
                // account for easing if there is any
                if (anim.easing && $.isFunction($.easing[anim.easing])) {
                  animPercent = $.easing[anim.easing](animPercent, animPercent * 1000, 0, 1, 1000);
                }
                // then multiply the percent by the value range and calculate
                // the new value
                animVal = anim.startVal + (animPercent * (anim.endVal - anim.startVal));
                setProperty(anim, animVal);
              }
            }
          }
        }
      }

      // update blockIndex and trigger event if changed
      if (scrollorama.blockIndex !== currBlockIndex) {
        scrollorama.blockIndex = currBlockIndex;
        onBlockChange();
      }
    }

    function getCurrBlockIndex(scrollTop) {
      var currBlockIndex = 0;
      var i;
      for (i = 0; i < blocks.length; i++) {
        // check if block is in view
        if (blocks[i].top <= scrollTop - scrollorama.settings.offset) {
          currBlockIndex = i;
        }
      }
      return currBlockIndex;
    }

    function setProperty(anim, val) {
      var target = anim.element;
      var prop = anim.property;
      var scaleCSS;
      var currentPosition;
      if (prop === 'rotate' || prop === 'zoom' || prop === 'scale') {
        if (prop === 'rotate') {
          target.css(browserPrefix + 'transform', 'rotate(' + val + 'deg)');
        }
        else if (prop === 'zoom' || prop === 'scale') {
          scaleCSS = 'scale(' + val + ')';
          if (browserPrefix !== '-ms-') {
            target.css(browserPrefix + 'transform', scaleCSS);
          }
          else {
            if (jQuery().scale) {
              $(target.selector).scale(val);
            }
            target.css('zoom', val);
          }
        }
      }
      else if (prop === 'background-position-x' || prop === 'background-position-y') {
        currentPosition = target.css('background-position').split(' ');
        if (prop === 'background-position-x') {
          target.css('background-position', val + 'px ' + currentPosition[1]);
        }
        if (prop === 'background-position-y') {
          target.css('background-position', currentPosition[0] + ' ' + val + 'px');
        }
      }
      else if (prop === 'text-shadow') {
        target.css(prop, '0px 0px ' + val + 'px #ffffff');
      }
      else {
        if (anim.suffix) {
          target.css(prop, val + anim.suffix);
        }
        else {
          target.css(prop, val);
        }
      }
    }


    // PUBLIC FUNCTIONS
    scrollorama.animate = function (target) {
      var targetIndex;
      var targetBlock;
      var anim;
      var offset;
      var suffix;
      var i;
      var j;

      /*
       target    = animation target
       arguments  = array of animation parameters
       anim    = object that contains all animation params (created from arguments)
       offset    = positioning helper for pinning animation
       parameters: delay    = amount of scrolling (in pixels) before
       animation starts duration  = amount of scrolling (in pixels) over which the animation occurs
       property  = css property being animated
       start    = start value of the property end      = end value of the property
       pin      = pin block during animation duration (applies to all animations within block)
       baseline  = top (default, when block reaches top of viewport) or bottom (when block first comies into view)
       easing    = just like jquery's easing functions
       */

      // if string, convert to DOM object
      if (typeof target === 'string') {
        target = $(target);
      }

      // find block of target
      for (i = 0; i < blocks.length; i++) {
        if (blocks[i].block.has(target).length) {
          targetBlock = blocks[i];
          targetIndex = i;
        }
      }

      // add each animation to the blocks animations array from function
      // arguments
      for (i = 1; i < arguments.length; i++) {

        anim = arguments[i];

        // for top/left/right/bottom, set relative positioning if static
        if (anim.property === 'top' || anim.property === 'left' || anim.property === 'bottom' || anim.property === 'right') {
          if (target.css('position') === 'static') {
            target.css('position', 'relative');
          }
          // set anim.start, anim.end defaults
          var cssValue = parseInt(target.css(anim.property), 10);
          if (typeof anim.start === 'undefined') {
            anim.start = isNaN(cssValue) ? 0 : cssValue;
          }
          else if (typeof anim.end === 'undefined') {
            anim.end = isNaN(cssValue) ? 0 : cssValue;
          }
        }

        // set anim.start/anim.end defaults for rotate, zoom/scale,
        // letter-spacing
        if (anim.property === 'rotate') {
          if (typeof anim.start === 'undefined') {
            anim.start = 0;
          }
          if (typeof anim.end === 'undefined') {
            anim.end = 0;
          }
        }
        else if (anim.property === 'zoom' || anim.property === 'scale') {
          if (typeof anim.start === 'undefined') {
            anim.start = 1;
          }
          if (typeof anim.end === 'undefined') {
            anim.end = 1;
          }
        }
        else if (anim.property === 'letter-spacing' && target.css(anim.property)) {
          if (typeof anim.start === 'undefined') {
            anim.start = 1;
          }
          if (typeof anim.end === 'undefined') {
            anim.end = 1;
          }
        }

        // convert background-position property for use on IE8 and lower
        if (ieVersion && ieVersion < 9 && (anim.property === 'background-position-x' || anim.property === 'background-position-y')) {
          if (anim.property === 'background-position-x') {
            anim.property = 'backgroundPositionX';
          }
          else {
            anim.property = 'backgroundPositionY';
          }
        }

        if (typeof anim.baseline === 'undefined') {
          if (anim.pin || targetBlock.pin || targetIndex === 0) {
            anim.baseline = 'top';
          }
          else {
            anim.baseline = 'bottom';
          }
        }

        if (typeof anim.delay === 'undefined') {
          anim.delay = 0;
        }

        var startVal;
        if (typeof anim.start === 'undefined') {
          // if undefined, use current css value
          startVal = parseInt(target.css(anim.property), 10);
        }
        else if (typeof anim.start === 'function') {
          startVal = anim.start();
        }
        else {
          startVal = anim.start;
        }
        var endVal;
        if (typeof anim.end === 'undefined') {
          // if undefined, use current css value
          endVal = parseInt(target.css(anim.property), 10);
        }
        else if (typeof anim.end === 'function') {
          endVal = anim.end();
        }
        else {
          endVal = anim.end;
        }
        suffix = startVal.toString().match(/\D+$/) || endVal.toString().match(/\D+$/);
        if (suffix) {
          suffix = suffix[0];
          startVal = parseInt(startVal, 10);  // remove the unit so
                                              // calculations work correctly
          endVal = parseInt(endVal, 10);
        }

        targetBlock.animations.push({
          element: target,
          delay: anim.delay,
          duration: anim.duration,
          property: anim.property,
          startVal: startVal,
          endVal: endVal,
          suffix: suffix,
          baseline: typeof anim.baseline !== 'undefined' ? anim.baseline : 'bottom',
          easing: anim.easing
        });

        if (anim.pin) {
          if (targetBlock.pin < anim.duration + anim.delay) {
            offset = anim.duration + anim.delay - targetBlock.pin;
            targetBlock.pin += offset;

            // adjust positions of blocks below target block
            for (j = targetIndex + 1; j < blocks.length; j++) {
              blocks[j].top += offset;
              blocks[j].block.css('top', blocks[j].top);
            }
          }
        }
      }

      onScrollorama();

      return scrollorama;
    };

    // function for passing blockChange event callback
    scrollorama.onBlockChange = function (f) {
      onBlockChange = f;
    };

    // function for getting an array of scrollpoints
    // (top of each animation block and animation element scroll start point)
    scrollorama.getScrollpoints = function () {
      var scrollpoints = [];
      var i;
      var j;
      var anim;
      for (i = 0; i < blocks.length; i++) {
        scrollpoints.push(blocks[i].top);
        // go through the animations for each block
        if (blocks[i].animations.length && blocks[i].pin > 0) {
          for (j = 0; j < blocks[i].animations.length; j++) {
            anim = blocks[i].animations[j];
            scrollpoints.push(blocks[i].top + anim.delay + anim.duration);
          }
        }
      }
      // make sure scrollpoints are in numeric order
      scrollpoints.sort(function (a, b) {
        return a - b;
      });
      return scrollpoints;
    };

    // Remove scrollorama
    scrollorama.destroy = function () {
      // Remove animations
      for (var i = 0; i < blocks.length; i++) {
        // Remove CSS rules
        blocks[i].block.css({
          top: '',
          position: ''
        });

        // Remove scrolloroma-specific attributes
        delete blocks[i].animations;
        delete blocks[i].top;
        delete blocks[i].pin;
      }

      // Unbind the window scroll event
      $(window).off('scroll.scrollorama');
      $('#scroll-wrap').remove();

      // Remove the scrolloroma object
      // delete scrollorama;
    };

    init();

    return scrollorama;
  };

  // Easing functions from jQuery UI
  $.extend($.easing, {
    def: 'easeOutQuad',
    swing: function (x, t, b, c, d) {
      return $.easing[$.easing.def](x, t, b, c, d);
    },
    easeInQuad: function (x, t, b, c, d) {
      return c * (t /= d) * t + b;
    },
    easeOutQuad: function (x, t, b, c, d) {
      return -c * (t /= d) * (t - 2) + b;
    },
    easeInOutQuad: function (x, t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t + b;
      }
      return -c / 2 * ((--t) * (t - 2) - 1) + b;
    },
    easeInCubic: function (x, t, b, c, d) {
      return c * (t /= d) * t * t + b;
    },
    easeOutCubic: function (x, t, b, c, d) {
      return c * ((t = t / d - 1) * t * t + 1) + b;
    },
    easeInOutCubic: function (x, t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t * t + b;
      }
      return c / 2 * ((t -= 2) * t * t + 2) + b;
    },
    easeInQuart: function (x, t, b, c, d) {
      return c * (t /= d) * t * t * t + b;
    },
    easeOutQuart: function (x, t, b, c, d) {
      return -c * ((t = t / d - 1) * t * t * t - 1) + b;
    },
    easeInOutQuart: function (x, t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t * t * t + b;
      }
      return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
    },
    easeInQuint: function (x, t, b, c, d) {
      return c * (t /= d) * t * t * t * t + b;
    },
    easeOutQuint: function (x, t, b, c, d) {
      return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
    },
    easeInOutQuint: function (x, t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t * t * t * t + b;
      }
      return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
    },
    easeInSine: function (x, t, b, c, d) {
      return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
    },
    easeOutSine: function (x, t, b, c, d) {
      return c * Math.sin(t / d * (Math.PI / 2)) + b;
    },
    easeInOutSine: function (x, t, b, c, d) {
      return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
    },
    easeInExpo: function (x, t, b, c, d) {
      return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
    },
    easeOutExpo: function (x, t, b, c, d) {
      return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
    },
    easeInOutExpo: function (x, t, b, c, d) {
      if (t === 0) {
        return b;
      }
      if (t === d) {
        return b + c;
      }
      if ((t /= d / 2) < 1) {
        return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
      }
      return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
    },
    easeInCirc: function (x, t, b, c, d) {
      return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
    },
    easeOutCirc: function (x, t, b, c, d) {
      return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
    },
    easeInOutCirc: function (x, t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
      }
      return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
    },
    easeInElastic: function (x, t, b, c, d) {
      var s = 1.70158;
      var p = 0;
      var a = c;
      if (t === 0) {
        return b;
      }
      if ((t /= d) === 1) {
        return b + c;
      }
      if (!p) {
        p = d * 0.3;
      }
      if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
      }
      else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
      return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
    },
    easeOutElastic: function (x, t, b, c, d) {
      var s = 1.70158;
      var p = 0;
      var a = c;
      if (t === 0) {
        return b;
      }
      if ((t /= d) === 1) {
        return b + c;
      }
      if (!p) {
        p = d * 0.3;
      }
      if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
      }
      else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
      return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
    },
    easeInOutElastic: function (x, t, b, c, d) {
      var s = 1.70158;
      var p = 0;
      var a = c;
      if (t === 0) {
        return b;
      }
      if ((t /= d / 2) === 2) {
        return b + c;
      }
      if (!p) {
        p = d * (0.3 * 1.5);
      }
      if (a < Math.abs(c)) {
        a = c;
        s = p / 4;
      }
      else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
      if (t < 1) {
        return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
      }
      return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
    },
    easeInBack: function (x, t, b, c, d, s) {
      if (typeof s === 'undefined') {
        s = 1.70158;
      }
      return c * (t /= d) * t * ((s + 1) * t - s) + b;
    },
    easeOutBack: function (x, t, b, c, d, s) {
      if (typeof s === 'undefined') {
        s = 1.70158;
      }
      return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    },
    easeInOutBack: function (x, t, b, c, d, s) {
      if (typeof s === 'undefined') {
        s = 1.70158;
      }
      if ((t /= d / 2) < 1) {
        return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
      }
      return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
    },
    easeInBounce: function (x, t, b, c, d) {
      return c - $.easing.easeOutBounce(x, d - t, 0, c, d) + b;
    },
    easeOutBounce: function (x, t, b, c, d) {
      if ((t /= d) < (1 / 2.75)) {
        return c * (7.5625 * t * t) + b;
      }
      else if (t < (2 / 2.75)) {
        return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
      }
      else if (t < (2.5 / 2.75)) {
        return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
      }
      else {
        return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
      }
    },
    easeInOutBounce: function (x, t, b, c, d) {
      if (t < d / 2) {
        return $.easing.easeInBounce(x, t * 2, 0, c, d) * 0.5 + b;
      }
      return $.easing.easeOutBounce(x, t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
    }
  });

})(jQuery);

/* !
 * Modified from: jQuery Migrate - v1.1.0 - 2013-01-31
 * https://github.com/jquery/jquery-migrate
 * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors; Licensed MIT
 */
function getBrowser() {
  var matched = uaMatch(navigator.userAgent);
  var browser = {};
  if (matched.browser) {
    browser[matched.browser] = true;
    browser.version = matched.version;
  }
  // Chrome is Webkit, but Webkit is also Safari.
  if (browser.chrome) {
    browser.webkit = true;
  }
  else if (browser.webkit) {
    browser.safari = true;
  }
  return browser;
}

function uaMatch(ua) {
  ua = ua.toLowerCase();

  var match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
    /(webkit)[ \/]([\w.]+)/.exec(ua) ||
    /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
    /(msie) ([\w.]+)/.exec(ua) ||
    ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
    [];

  return {
    browser: match[1] || '',
    version: match[2] || '0'
  };
}

/**
 * textFit v2.3.1
 * Previously known as jQuery.textFit
 * 11/2014 by STRML (strml.github.com)
 * MIT License
 *
 * To use: textFit(document.getElementById('target-div'), options);
 *
 * Will make the *text* content inside a container scale to fit the container
 * The container is required to have a set width and height
 * Uses binary search to fit text with minimal layout calls.
 * Version 2.0 does not use jQuery.
 */
/* global define:true, document:true, window:true, HTMLElement:true */

(function (root, factory) {
  'use strict';

  // UMD shim
  if (typeof define === 'function' && define.amd) {
    // AMD
    define([], factory);
  }
  // else if (typeof exports === 'object') {
  //   // Node/CommonJS
  //   module.exports = factory();
  // }
  else {
    // Browser
    root.textFit = factory();
  }
}(this, function () {
  'use strict';

  var defaultSettings = {
    alignVert: false, // if true, textFit will align vertically using css tables
    alignHoriz: false, // if true, textFit will set text-align: center
    multiLine: true, // if true, textFit will not set white-space: no-wrap
    detectMultiLine: true, // disable to turn off automatic multi-line sensing
    minFontSize: 20,
    maxFontSize: 60,
    reProcess: true, // if true, textFit will re-process already-fit nodes. Set to 'false' for better performance
    widthOnly: true, // if true, textFit will fit text to element width, regardless of text height
    alignVertWithFlexbox: false, // if true, textFit will use flexbox for vertical alignment
    staticWidth: 0 // width passed from the markup
  };

  return function textFit(els, options) {

    if (!options) {
      options = {};
    }

    // Extend options.
    var settings = {};
    for (var key in defaultSettings) {
      if (options.hasOwnProperty(key)) {
        settings[key] = options[key];
      }
      else {
        settings[key] = defaultSettings[key];
      }
    }

    // Convert jQuery objects into arrays
    if (typeof els.toArray === 'function') {
      els = els.toArray();
    }

    // Support passing a single el
    var elType = Object.prototype.toString.call(els);
    if (elType !== '[object Array]' && elType !== '[object NodeList]' &&
      elType !== '[object HTMLCollection]') {
      els = [els];
    }

    // Process each el we've passed.
    for (var i = 0; i < els.length; i++) {
      processItem(els[i], settings);
    }
  };

  function processItem(el, settings) {
    if (!isElement(el) || (!settings.reProcess && el.getAttribute('textFitted'))) {
      return false;
    }

    // Set textFitted attribute so we know this was processed.
    if (!settings.reProcess) {
      el.setAttribute('textFitted', 1);
    }

    var innerSpan;
    var originalHeight;
    var originalHTML;
    var originalWidth;
    var low;
    var mid;
    var high;

    // Get element data.
    originalHTML = el.innerHTML;
    originalWidth = innerWidth(el) || settings.staticWidth;
    originalHeight = innerHeight(el);

    // console.log(originalWidth, settings.staticWidth);
    // Don't process if we can't find box dimensions
    if (!originalWidth || (!settings.widthOnly && !originalHeight)) {
      if (!settings.widthOnly) {
        throw new Error('Set a static height and width on the target element ' + el.outerHTML +
          ' before using textFit!');
      }
      else {
        throw new Error('Set a static width on the target element ' + el.outerHTML +
          ' before using textFit!');
      }
    }

    // Add textFitted span inside this container.
    if (originalHTML.indexOf('textFitted') === -1) {
      innerSpan = document.createElement('div');
      innerSpan.className = 'textFitted';
      // Inline block ensure it takes on the size of its contents, even if they are enclosed
      // in other tags like <p>
      innerSpan.style['display'] = 'inline-block';
      innerSpan.innerHTML = originalHTML;
      el.innerHTML = '';
      el.appendChild(innerSpan);
    }
    else {
      // Reprocessing.
      innerSpan = el.querySelector('div.textFitted');
      // Remove vertical align if we're reprocessing.
      if (hasClass(innerSpan, 'textFitAlignVert')) {
        innerSpan.className = innerSpan.className.replace('textFitAlignVert', '');
        innerSpan.style['height'] = '';
        el.className.replace('textFitAlignVertFlex', '');
      }
    }

    // Prepare & set alignment
    if (settings.alignHoriz) {
      el.style['text-align'] = 'center';
      innerSpan.style['text-align'] = 'center';
    }

    // Check if this string is multiple lines
    // Not guaranteed to always work if you use wonky line-heights
    var multiLine = settings.multiLine;
    if (settings.detectMultiLine && !multiLine &&
      innerSpan.scrollHeight >= parseInt(window.getComputedStyle(innerSpan)['font-size'], 10) * 2) {
      multiLine = true;
    }

    // If we're not treating this as a multiline string, don't let it wrap.
    if (!multiLine) {
      el.style['white-space'] = 'nowrap';
    }

    low = settings.minFontSize;
    high = settings.maxFontSize;

    // Binary search for highest best fit
    if (innerSpan.scrollWidth - 1 > originalWidth) {
      var size = low;
      while (low <= high) {
        mid = (high + low) >> 1;
        innerSpan.style.fontSize = mid + 'px';
        if (innerSpan.scrollWidth <= originalWidth && (settings.widthOnly || innerSpan.scrollHeight <= originalHeight)) {
          size = mid;
          low = mid + 1;
        }
        else {
          high = mid - 1;
        }
        // await injection point
      }
      // found, updating font if differs:
      if (innerSpan.style.fontSize !== size + 'px') {
        innerSpan.style.fontSize = size + 'px';
      }
    }

    // Our height is finalized. If we are aligning vertically, set that up.
    if (settings.alignVert) {
      addStyleSheet();
      var height = innerSpan.scrollHeight;
      if (window.getComputedStyle(el)['position'] === 'static') {
        el.style['position'] = 'relative';
      }
      if (!hasClass(innerSpan, 'textFitAlignVert')) {
        innerSpan.className = innerSpan.className + ' textFitAlignVert';
      }
      innerSpan.style['height'] = height + 'px';
      if (settings.alignVertWithFlexbox && !hasClass(el, 'textFitAlignVertFlex')) {
        el.className = el.className + ' textFitAlignVertFlex';
      }
    }
  }

  // Calculate height without padding.
  function innerHeight(el) {
    var style = window.getComputedStyle(el, null);
    return el.clientHeight -
      parseInt(style.getPropertyValue('padding-top'), 10) -
      parseInt(style.getPropertyValue('padding-bottom'), 10);
  }

  // Calculate width without padding.
  function innerWidth(el) {
    var style = window.getComputedStyle(el, null);
    return el.clientWidth -
      parseInt(style.getPropertyValue('padding-left'), 10) -
      parseInt(style.getPropertyValue('padding-right'), 10);
  }

  // Returns true if it is a DOM element
  function isElement(o) {
    return (
      typeof HTMLElement === 'object' ? o instanceof HTMLElement : // DOM2
        o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string'
    );
  }

  function hasClass(element, cls) {
    return (' ' + element.className + ' ').indexOf(' ' + cls + ' ') > -1;
  }

  // Better than a stylesheet dependency
  function addStyleSheet() {
    if (document.getElementById('textFitStyleSheet')) {
      return;
    }
    var style = [
      '.textFitAlignVert{',
      'position: absolute;',
      'top: 0; right: 0; bottom: 0; left: 0;',
      'margin: auto;',
      'display: flex;',
      'justify-content: center;',
      'flex-direction: column;',
      '}',
      '.textFitAlignVertFlex{',
      'display: flex;',
      '}',
      '.textFitAlignVertFlex .textFitAlignVert{',
      'position: static;',
      '}'].join('');

    var css = document.createElement('style');
    css.type = 'text/css';
    css.id = 'textFitStyleSheet';
    css.innerHTML = style;
    document.body.appendChild(css);
  }
}));

(function ($) {

  var backToTop = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var $body = $('body', context);

    if (!$body.data('init-body')) {
      $body.data('init-body', true);

      if (!$body.hasClass('path-frontpage')) {
        var cssClass = 'back-to-top';
        var $target = $('<span />', {class: cssClass});
        $target.text(localSettings.top);
        $body.append($target);
        var $window = $(window);
        var $document = $(document);

        $window.scroll(function () {

          if ($window.scrollTop() > Math.round($document.height() / 4) && $window.height() < $document.height()) {
            $target.fadeIn('fast');
          }
          else {
            $target.fadeOut('fast');
          }
        });

        $target.click(function (elt) {
          elt.preventDefault();
          $('html, body').animate({
            scrollTop: 0
          }, _duration);
        });
      }
    }
  };

  Drupal.behaviors.backToTop = {
    attach: backToTop
  };

})(jQuery);

// Resize charts

(function ($) {

  var chartPanel = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'chart-panel';
    var $targets = $('.' + cssClass, context);
    var $window = $(window);

    $window.resize(function () {

      $targets.each(function () {
        var $target = $(this);
        var id = $target.attr('_echarts_instance_');
        window.echarts.getInstanceById(id).resize();
      });
    });

    $targets.each(function () {
      var $target = $(this);
      var done = false;

      var scrollToChart = function () {
        var winHeight = $(window).height();
        var windowPos = $(window).scrollTop();
        var targetPos = $target.offset().top;

        if (windowPos + (winHeight) > (targetPos + $target.height() / 2) && done === false) {
          done = true;
          $target.css('opacity', 1);
        }
      };

      scrollToChart();
      $(window).scroll(function () {
        scrollToChart();
      });
    });
  };

  Drupal.behaviors.chartPanel = {
    attach: chartPanel
  };

})(jQuery);

// Dropdown links

(function ($) {

  var dropdownLinks = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'dropdown-links';
    var $targets = $('.' + cssClass, context);
    var $item = $('.' + cssClass + '--list li a', $targets);

    $targets.each(function () {
      var $target = $(this);
      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var $siteHeader = $target.parents('.site-header');
        var $trigger = $('.' + cssClass + '--current', $target);
        var $menu = $('.' + cssClass + '--dropdown', $target);

        if ($trigger.length && $menu.length && $siteHeader.length) {

          $target.data({
            $trigger: $trigger,
            $menu: $menu
          });

          $trigger.data({
            $target: $target,
            $menu: $menu
          });

          // Manage menu
          $target.addClass('collapsed');
          $trigger.on('click', function () {
            $(this).data('$menu').slideToggle(400);
            $(this).data('$target').toggleClass('collapsed');
            var $target = $(this).data('$target');
            var $siblingOpened = $target.siblings('.' + cssClass).not('.collapsed');
            if ($siblingOpened.length) {
              $siblingOpened.data('$menu').slideUp(400);
              $siblingOpened.addClass('collapsed');
            }
            // $(this).data('$target').siblings('.' + cssClass + ':not(.collapsed)');
          });
        }
      }
    });

    $('body').on('click', function (event) {

      if (!$(event.target).closest('.' + cssClass).length) {
        var $siblingOpened = $('.' + cssClass).not('.collapsed');
        if ($siblingOpened.length) {
          $siblingOpened.data('$menu').slideUp(400);
          $siblingOpened.addClass('collapsed');
        }
      }
    });

    $item.on('click', function () {
      var $siblingOpened = $('.' + cssClass).not('.collapsed');
      $siblingOpened.data('$menu').slideUp(400);
      $siblingOpened.addClass('collapsed');
    });
  };

  Drupal.behaviors.dropdownLinks = {
    attach: dropdownLinks
  };

})(jQuery);

// Fit the word and adjust the font for mobile device
// It will work only for device <= 640

(function ($) {

  var fitTheText = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'js-fit-the-text';
    var $targets = $('.' + cssClass, context);


    var fitTextForMobile = function () {
      $targets.each(function () {
        var $target = $(this);
        var $rep = $target.find('.textFitted');

        if ($rep.length) {
          var $repInnerHTML = $rep.html();
          $rep.replaceWith($repInnerHTML);
        }

        if (getViewportWidth() <= 640) {
          var setStaticWidth = 0;

          //don't execute if found 'js-letters-effect' as parent class
          var checkTheClass = 'js-letters-effect';
          if ($target.parents('.' + checkTheClass).length) {
            return;
          }

          //make 'js-letters-effect' child of 'js-fit-the-text' if found togeather
          if ($target.hasClass(checkTheClass)) {
            $target.removeClass(checkTheClass);
            $target.wrapInner('<div class=' + checkTheClass + '></div>')
          }

          //handling the Home page intro carousel
          if(($target.closest('.page-intro--list').length) && ($target.closest('li').css('display') == 'none')) {
            setStaticWidth = $(window).width() - 60;
          }
    
          textFit($target, {staticWidth : setStaticWidth});
        }
      });
    };

    fitTextForMobile()
    $(window).on('resize', fitTextForMobile);
  };

  Drupal.behaviors.fitTheText = {
    attach: fitTheText
  };

})(jQuery);

// random display of gradients

(function ($) {

  var tagHighlighted = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'tag-highlighted';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);

      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        $target.addClass(randomClassGradient[Math.floor(Math.random() * randomClassGradient.length)]);
      }
    });
  };

  Drupal.behaviors.tagHighlighted = {
    attach: tagHighlighted
  };

})(jQuery);

// random display of gradients

(function ($) {

  var tagStd = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'tag-std';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);

      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        $target.addClass(randomClassGradient[Math.floor(Math.random() * randomClassGradient.length)]);
      }
    });
  };

  Drupal.behaviors.tagStd = {
    attach: tagStd
  };

})(jQuery);

// Creation submenu & sticky nav for content filters component

(function ($) {

  var contentFiltersDropdown = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'content-filters';
    var $targets = $('.' + cssClass + '.js-dropdown', context);
    var $window = $(window);

    $targets.each(function () {
      var $target = $(this);
      if (!$target.data('init-' + cssClass + 'dropdown')) {
        $target.data('init-' + cssClass + 'dropdown', true);

        // Tweakpoint large
        var tweakpointLarge = 1400;

        // Get filter by month select
        var $tagsWrapper = $('.form-radios', $target);
        var $tagAll = $('[id^=edit-tag-all]', $tagsWrapper);
        var $tags = $('input[type=radio]:not([id^=edit-tag-all])', $tagsWrapper);

        // Function to reorder tags by primary or secondary
        $tags.sort(function (a, b) {
          var $a = $(a);
          var $b = $(b);
          var className = 'is-secondary';

          if ($a.hasClass(className) && !($b.hasClass(className))) {
            return 1;
          }
          // b comes first since it has class but a doesn't
          else if (!$a.hasClass(className) && ($b.hasClass(className))) {
            return -1;
          }
          // Both have same class -- sory by next criterion
          else {
            return 0;
          }
        });

        if ($tags.length) {

          // Display only the three first value
          $('.form-item:not(:nth-child(-n+4))', $tagsWrapper).hide();
          $('.form-item:nth-child(-n+4) input[type=radio]', $tagsWrapper).addClass('highlight-tag');

          // Move link Front Page according viewportWidth
          var $frontPageLink = $('[id^=edit-front-page]', $target);
          if ($frontPageLink.length) {

            var $formItemTagAll = $('<div />', {
              class: 'form-item first-item'
            });
            $formItemTagAll.append($frontPageLink);

            var moveFrontPageLink = function () {

              if (getViewportWidth() > tweakpointLarge) {
                $tagsWrapper.prepend($formItemTagAll);
              }
              else {
                $tagsWrapper.before($formItemTagAll);
              }
            };

            moveFrontPageLink();
            $window.resize(moveFrontPageLink);
          }

          // Container for selected tag
          var $selectedTags = $('<div />', {
            class: 'form-item alternate selected-tags'
          });
          $tagsWrapper.append($selectedTags);

          // Create dropDownLayer (red side pannel)
          var dropDownTags = $target.dropDownLayer({
            cssClass: cssClass,
            target: $('body'),
            options: $tags
          });

          // Create trigger for dropDownLayer
          var $triggerDropDown = $('<div />', {
            class: 'form-item form-type-select'
          });
          var $triggerDropDownLabel = $('<label />');
          $triggerDropDownLabel.text(Drupal.t('All tags'));
          $triggerDropDown.append($triggerDropDownLabel);
          $triggerDropDown.css('cursor', 'pointer');
          $triggerDropDown.on('click', dropDownTags.open);
          $tagAll.parent('.form-item').hide().after($triggerDropDown);

          // Function to update selected tags extract and dropdown
          var updateTags = function (value) {

            // Check if it's already displayed
            var $radioChecked = $('.form-radios input[type=radio][value=' + value + ']', $target);
            var text = $radioChecked.next('label').text();
            var isAlreadyDisplay = $radioChecked.hasClass('highlight-tag');
            if (!isAlreadyDisplay) {

              // Create tag
              var $tagLabel = $('<label />', {
                class: 'is-active'
              });
              $tagLabel.text(text);

              // If it's primary we add a class to differenciate it
              var isPrimary = $radioChecked.hasClass('is-primary');
              if (!isPrimary) {
                $tagLabel.addClass('is-secondary');
              }

              // Add tag to DOM
              $selectedTags.append($tagLabel);
            }

            // Update drop down
            dropDownTags.updateReferer(value);
          };

          // Update dropdown layer with selected option
          var defaultValue = $('input[type=radio]:checked', $tagsWrapper).attr('value');
          if (defaultValue !== 'undefined') {
            updateTags(defaultValue);
          }

          // Update filter bar on change
          $tags.on('change', function () {
            var $tag = $(this);
            var value = $tag.val();

            // Clear radios and summary of selected tags
            $selectedTags.empty();

            // Update dropDowntags and selected tags
            updateTags(value);
          });

          // Clear on "All" click option
          $tagAll.on('click', function () {
            dropDownTags.clear();
            $tagAll.siblings('input[type=radio]:checked').prop('checked', 'false');
          });
        }
      }
    });
  };

  Drupal.behaviors.contentFiltersDropdown = {
    attach: contentFiltersDropdown
  };

})(jQuery);


// Accordion & tabs for Archive Download Block

(function ($) {

  var contentFiltersTabs = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'content-filters-tabs';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);

      if ($target.data('init-' + cssClass)) {
        return true; // continue
      }
      $target.data('init-' + cssClass, true);

      var $contentFiltersTabs = $('.' + cssClass + '--list', $target);

      var $tabsWrapper = $('<div>', {
        class: cssClass + '--nav--wrapper'
      });
      $target.prepend($tabsWrapper);
      var $tabsContainer = $('<div>', {
        class: 'container'
      });
      var $tabsContainerContent = $('<div>', {
        class: 'container--content'
      });
      $tabsWrapper.append($tabsContainer);
      $tabsContainer.append($tabsContainerContent);
      $tabsContainerContent.append($('.' + cssClass + '--label', $target).clone());
      var cfg = {
        group: '> section',
        trigger: '.' + cssClass + '--trigger',
        section: '.' + cssClass + '--content',
        startOpened: '',
        scrollTo: true,
        responsive: {
          640: {
            tabsClass: cssClass + '--nav',
            tabs: function ($tabs) {
              $('> li', $tabs).each(function (i) {
                var $li = $(this);
                var span = $('<span />', {
                  class: cssClass + '--trigger'
                });
                $li.wrapInner(span);
              });
              $tabsContainerContent.append($tabs);
            },
            duration: 0,
            scrollTo: false
          }
        }
      };
      $contentFiltersTabs.rsAccordion(cfg);
    });
  };

  Drupal.behaviors.contentFiltersTabs = {
    attach: contentFiltersTabs
  };

})(jQuery);

// Creation submenu & sticky nav for content filters component

(function ($) {

  var contentFilters = function (context, settings) {

    var cssClass = 'content-filters';
    var $targets = $('.' + cssClass, document);

    $targets.each(function () {
      var $target = $(this);
      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var $window = $(window);
        var $body = $('body', document);
        var $searchField = $('.form-autocomplete', $target);

        if ($searchField.length) {
          var $submitContainer = $('<div />', {
            'class': cssClass + '--submit'
          });
          var $submit = $('<input />', {
            'type': 'button'
          });
          $submit.click(function () {
            $('.js-form-submit', $target).click();
          });
          $searchField.wrap($submitContainer);
          $searchField.after($submit);
        }

        if (($body.hasClass('path-newsroom') || $body.hasClass('path-magazine') || $body.hasClass('path-training')) && !$target.hasClass('filters')) {
          var tweakpoint = 1050;
          var tweakpointLarge = 1200;
          var tweakpointXLarge = 1400;
          var $container = $('.' + cssClass + '--container', $target).eq(0);
          var done = false;

          var stickySystem = function () {
            var $header = $('.site-heading');
            var $content = $target.closest('.view-newsroom, .view-magazine, .view-training');
            var $position = $content.offset().top;
            var $scrollPosition = $window.scrollTop();
            var headerHeight = $header.height();
            $target.removeAttr('style');

            if ($body.hasClass('user-logged-in')) {
              headerHeight += parseInt($body.css('padding-top'));
            }

            if ($scrollPosition < $position - headerHeight) {
              $target.addClass('js-transition');
              $target.removeClass('js-fixed');
              $target.removeClass('js-collapsed');
              done = false;
            }
            else {
              $target.addClass('js-fixed');
              $target.removeClass('js-transition');

              if (done === false) {
                $target.addClass('js-collapsed');
                done = true;
              }

              if (getViewportWidth() > tweakpoint) {
                $target.css('top', headerHeight);
              }
            }
          };

          stickySystem();
          $window.scroll(stickySystem);
          $window.resize(stickySystem);

          var filterSystem = function () {

            // Reset
            $('.' + cssClass + '--fake-select').remove();

            if (getViewportWidth() < ($target.hasClass('alternate') ? tweakpointLarge : tweakpointXLarge)) {
              var $radio = $('input[type=radio]', $container);
              var $containerSelect = $('<div />', {
                class: cssClass + '--fake-select'
              });
              var nameSelect = 'fakeSelect';
              var $select = $('<select />', {
                'id': nameSelect
              });
              var $label = $('<label />', {
                'for': nameSelect
              }).text(Drupal.t('Filter by category'));

              $radio.each(function () {
                var $input = $(this);
                var $label = $input.siblings('label');
                var $option = $('<option />', {
                  'value': $input.val()
                });
                $option.text($label.text());

                if ($input.is(':checked')) {
                  $option.prop('selected', true);
                }
                $select.append($option);
              });

              $select.change(function () {
                var value = $select.val();
                var $input = $('input[value=' + value + ']');
                $input.prop('checked', true);
                $('.js-form-submit', $target).click();
              });

              $containerSelect.append(
                $label
              ).append(
                $select
              );

              $container.prepend($containerSelect);
            }

            if (Modernizr.android === true || Modernizr.ios === true) {
              $('select[multiple]', $target).removeClass('has-chosen').chosen('destroy');
            }
          };

          filterSystem();
          $window.resize(filterSystem);

          var groupFilters = function () {
            var $label = $('.' + cssClass + '--group--label', $target);

            if (getViewportWidth() < tweakpoint && $label.length === 0) {

              var $groupLabel = $('<div />', {
                class: cssClass + '--group--label'
              }).text(Drupal.t('Filters'));
              var $groupFilters = $('<div />', {
                class: cssClass + '--group--filters'
              });

              $groupLabel.click(function () {
                $target.toggleClass('js-collapsed');
              });
              $target.wrapInner($groupFilters);
              $target.prepend($groupLabel);
            }

            if (getViewportWidth() > tweakpoint && $label.length === 1) {
              $label.remove();
              $container.unwrap('.' + cssClass + '--group--filters');
              $target.removeClass('js-collapsed');
            }
          };

          groupFilters();
          $window.resize(groupFilters);
        }
      }
    });
  };

  Drupal.behaviors.contentFilters = {
    attach: contentFilters
  };

})(jQuery);


// Accordion & tabs for Archive Download Block

(function ($) {

  var displayToggleView = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'display-toggle-view';
    var $targets = $('.' + cssClass, context);
    if (!localStorage.getItem('BV-display-toggle-view')) {
      localStorage.setItem('BV-display-toggle-view', 'view-grid');
    }
    var viewState = localStorage.getItem('BV-display-toggle-view');

    var changeView = function (viewState) {
      localStorage.setItem('BV-display-toggle-view', viewState);
      $('.js-has-toggle-view', context).removeClass('view-grid view-list').addClass(viewState);
    };

    $targets.each(function (index) {
      var $target = $(this);

      if (!$target.data('init-' + cssClass) &&
        $target.closest('.list-results--header') &&
        $('.js-has-toggle-view', context).length) {
        $target.data('init-' + cssClass, true);
        $('input', $target).each(function () {
          if ($(this).val() === localStorage.getItem('BV-display-toggle-view')) {
            $(this).attr('checked', 'checked').siblings('input').removeAttr('checked');
          }
          $(this).on('change', function () {
            changeView($(this).val());
          });
        });

        changeView(viewState);
      }
    });
  };

  Drupal.behaviors.displayToggleView = {
    attach: displayToggleView
  };

})(jQuery);

// Accordion & tabs for Archive Download Block

(function ($) {

  var historyDates = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'history-dates';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);
      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var $list = $('ul:first', $target);
        var $li = $('> li', $list);

        var datas = getDatasFromHtml($li, {
          content: {
            rule: ':self',
            cfg: {
              html: true
            }
          },
          data: {
            rule: ':self',
            cfg: {
              attribute: 'data-date'
            }
          }
        });

        var $array = classifyBy(datas, 'data');
        var $createdlist = $('<ul />', {
          class: cssClass + '--list'
        });

        $.each($array, function (date, html) {
          var $createdLi = $('<li />');
          var $createdContainer = $('<div />', {
            class: cssClass + '--content'
          });

          $.each(html, function (i, html) {
            $createdContainer.append(html.content);
          });

          var $createdDate = $('<span />', {
            class: cssClass + '--trigger'
          }).text(date);

          $createdLi.append($createdDate).append($createdContainer);
          $createdlist.prepend($createdLi);
          $list.after($createdlist);
        });

        $list.remove();

        var cfg = {
          group: '> li',
          trigger: '.' + cssClass + '--trigger',
          section: '.' + cssClass + '--content',
          startOpened: ':first',
          scrollTo: true,
          responsive: {
            640: {
              tabsClass: cssClass + '--tabs',
              tabs: function (tabs) {
                $('> li', tabs).each(function (i) {
                  var $li = $(this);
                  var span = $('<span />', {
                    class: cssClass + '--trigger'
                  });
                  $li.wrapInner(span);
                });
                $createdlist.before(tabs);
              },
              duration: 0,
              scrollTo: false,
              atLeastOne: true
            }
          }
        };
        $createdlist.rsAccordion(cfg);
      }
    });
  };

  Drupal.behaviors.historyDates = {
    attach: historyDates
  };

})(jQuery);

// self scrolling

(function ($) {

  var hotNews = function (context, settings) {

    if (typeof context === 'undefined') {
     context = document;
    }

    var cssClass = 'hot-news';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);
      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var $text = $('.' + cssClass + '--text', $target);
        var $parent = $target.parent();

        var $span = $('<span />', {
          'data-text': $text.text()
        });

        if ($('span', $text)) {
          $text.wrapInner($span);
        }

        var marquee = function () {
          $text.removeClass('marquee');

          if ($parent.width() < $target.innerWidth() && $('.sticky', context).length === 0) {
            $text.addClass('marquee');
          }
        };

        marquee();
        $(window).resize(marquee);
      }
    });
  };

  Drupal.behaviors.hotNews = {
    attach: hotNews
  };

})(jQuery);

// Animate scroll to #

(function ($) {

  var itemsAnchor = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'items-anchor';
    var cssClassActive = 'active';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {

      var $target = $(this);
      if ($target.data('init-' + cssClass)) {
        return true; // continue;
      }
      $target.data('init-' + cssClass, true);

      $target.stick_in_parent({
        offset_top: 65
      });

      $target.find('a').on('click', function (e) {
        e.preventDefault();
        var anchor = $(this).attr('href');
        var scrollTo = null;

        $target.find('a').removeClass(cssClassActive);
        $(this).addClass(cssClassActive);

        scrollTo = $(anchor).offset().top - 156;

        animatedScrollTo(scrollTo);
      });
    });
  };

  Drupal.behaviors.itemsAnchor = {
    attach: itemsAnchor
  };

})(jQuery);

// Creation of the main menu (accordion system, ...)

(function ($) {

  var mainMenu = function (context, settings) {

    var cssClass = 'main-menu';
    var $targets = $('.' + cssClass, document);

    $targets.each(function () {
      var $target = $(this);
      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var $list = $('> ul', $target);
        var $close = $('<span />', {class: cssClass + '--close'});
        $close.click(function () {
          var $trigger = $('> span, > a', $(this).closest('li'));
          $trigger.click();
          return false;
        });

        $list.dropMenu({
          contexes: [{
            group: '> li',
            trigger: '> span, > a',
            section: '.' + cssClass + '--section'
          }],
          enabledClass: 'main-menu--enabled',
          overlayClass: 'main-menu--overlay',
          onBeforeExpand: function (id, _self) {
            var $sibling = $target.siblings('.' + cssClass);
            _self.removeAttr('style');
            $target.addClass('js-open');
            $sibling.addClass('js-collapsed');
            $('.expanded .' + cssClass + '--close', $sibling).click();
            _self.$sections[id].append($close.hide());

            var $illustration = $('.' + cssClass + '--illustration', _self.$sections[id]);
            $illustration.removeClass('show');
          },
          onAfterExpand: function (id, _self) {
            var $sibling = $target.siblings('.' + cssClass);
            $target.addClass('js-open');
            $sibling.addClass('js-collapsed');
            $('.expanded .' + cssClass + '--close', $sibling).click();
            $close.fadeIn();

            var $illustration = $('.' + cssClass + '--illustration', _self.$sections[id]);
            $illustration.addClass('show');
          },
          onAfterCollapse: function () {
            $target.removeClass('js-open');
            $('.' + cssClass).removeClass('js-collapsed');
          }
        });
      }
    });
  };

  Drupal.behaviors.mainMenu = {
    attach: mainMenu
  };

})(jQuery);

// Greybox for Home Page

(function ($) {

  var modalHp = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'modal-hp';
    var $targets = $('.' + cssClass, context);
    var $body = $('body');

    var gb = new Greybox({
      cssClass: 'modalhp',
      onBeforeOpen: function () {
        $body.addClass('prevent-scroll');
        $('.greybox').css('z-index', 200);
      },
      onAfterOpen: function () {
        $('.greybox--overlay').off('click');
      },
      onBeforeClose: function () {
        $body.removeClass('prevent-scroll');
      }
    });

    $targets.each(function () {
      var $target = $(this);

      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var $targetContent = $('.' + cssClass + '--content', $target);
        var targetTitle = $('.' + cssClass + '--title', $targetContent).text();
        var targetDesc = $('.' + cssClass + '--desc', $targetContent).html();
        var $targetText = $('<div />');

        var displayGb = function () {
          if (typeof targetTitle === 'string') {
            gb.setTitle(targetTitle);
          }
          gb.html($targetText.append(targetDesc));
          return false;
        };
        $(window).on('load', displayGb);
      }
    });
  };

  Drupal.behaviors.modalHp = {
    attach: modalHp
  };

})(jQuery);

// Search Tool
/* global tweakpoint */

(function ($) {

  var searchTool = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'search-tool';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);
      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);
        var $body = $('body', context);

        var $icon = $('<span />', {
          class: cssClass + '--icon'
        });
        var $close = $('<span />', {
          class: cssClass + '--close'
        });
        var $content = $('<div />', {
          class: cssClass + '--content'
        });

        var $form = $('form', $target);
        var $textField = $('input[type=text]', $target);
        $textField.attr('placeholder', localSettings.what_are_you_looking_for);

        $content.html($form.detach());
        $target.prepend($content);
        $target.prepend($icon).append($close);
        $target.css('visibility', 'visible');
        $icon.click(function () {

          if (!$target.hasClass('expanded')) {
            $target.addClass('expanded');
            $content.removeAttr('style');
            $body.addClass('prevent-scroll');
            $textField.val('');

            if ($(window).width() > tweakpoint) {
              $body.removeClass('prevent-scroll');
              var $siteLogo = $('.site-logo', context);
              var cssWidth = $close.offset().left;
              var cssRight = $body.width() - $close.offset().left;

              if ($siteLogo.length) {
                cssWidth -= $siteLogo.width();
              }
              $content.css({
                width: cssWidth,
                right: cssRight
              });
            }
            $textField.focus();
          }
        });

        var hideSearch = function () {
          $content.css('width', 0);
          $target.removeClass('expanded');
          setTimeout(function () {
            $body.removeClass('prevent-scroll');
          }, 250);
        };

        $close.click(hideSearch);

        var width = $(window).width();
        $(window).resize(function () {
          if ($(window).width() !== width) {
            width = $(window).width();
            hideSearch();
          }
        });
      }
    });
  };

  Drupal.behaviors.searchTool = {
    attach: searchTool
  };

})(jQuery);

// Language Switcher

(function ($) {

  var siteLang = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'site-lang';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);
      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);
        $target.css('visibility', 'visible');

        var $initialListWidth = $target.outerWidth();
        $initialListWidth += 24; // include padding to the future flex-basis rule

        // Add flex-basis to the target to adapt container to the largest option width
        if ($initialListWidth > 78) {
          $target.css('flex-basis', $initialListWidth + 'px');
        }

        if(!Modernizr.mobile && !Modernizr.phone && !Modernizr.tablet) {
          $target.addClass('is-custom');
        }

        var $list = $('ul.links', $target);
        var $li = $('li', $list);

        var $dl = $('<dl />');
        var $dt = $('<dt />', {
          class: 'site-lang--current'
        });
        var $dd = $('<dd />', {
          class: 'site-lang--list'
        });
        var $select = $('<select />');

        $('a', $li).each(function () {
          var $link = $(this);
          var lang = $link.attr('hreflang');
          var href = $link.attr('href');
          var $option = $('<option />', {
            value: href
          }).text(lang);

          if ($link.hasClass('is-active')) {
            $dt.text(lang);
            $option.attr('selected', 'selected');
          }

          $select.prepend($option);
        });

        $select.change(function () {
          location.href = this.options[this.selectedIndex].value;
        });

        $dt.click(function () {
          $dd.slideToggle();
          $target.toggleClass('expanded');
          $('.' + cssClass + '--overlay', context).remove();

          var $overlay = $('<div />', {
            class: cssClass + '--overlay'
          });
          $overlay.click(function () {
            var $this = $(this);
            $this.remove();
            $dt.click();
          });

          if ($target.hasClass('expanded')) {
            $target.after(
              $overlay
            );
          }
        });

        $dl.append(
          $dd.html(
            $list.removeAttr('class').detach()
          )
        ).append(
          $dt
        );

        $target.append(
          $dl
        ).append(
          $select
        );
      }
    });
  };

  Drupal.behaviors.siteLang = {
    attach: siteLang
  };

})(jQuery);

// Select Links to portals

(function ($) {

  var sitePortals = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'site-portals';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);
      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);
        $target.css('visibility', 'visible');
        var $title = $('h2', $target).remove();
        var $list = $('ul', $target);

        var $span = $('<span />').text($title.text());
        var $dl = $('<dl />');
        var $dt = $('<dt />', {
          class: cssClass + '--current'
        }).html($span);
        var $dd = $('<dd />', {
          class: cssClass + '--list'
        });

        $('body').on('click', '.' + cssClass + ' dt', function () {
          var $dt = $(this);
          var $target = $dt.closest('.' + cssClass);
          $dt.siblings('dd').slideToggle(400, function () {
            var $dd = $(this);
            var $dt = $dd.siblings('dt');
            if ($dd.closest('.burger-menu--scrollable').length) {
              var deltaTop = $dt.offset().top - $dd.closest('.burger-menu--scrollable').children().eq(0).offset().top;
              $dd.closest('.burger-menu--scrollable').animate({scrollTop: deltaTop}, 500);
            }
          });
          $target.toggleClass('expanded');
          $('.' + cssClass + '--overlay', context).remove();

          if ($dt.closest('.heading-highlights--tools').length) {
            var $overlay = $('<div />', {
              class: cssClass + '--overlay'
            });

            $overlay.click(function () {
              var $this = $(this);
              $this.remove();
              $dt.click();
            });

            if ($target.hasClass('expanded')) {
              $target.append(
                $overlay
              );
            }
          }
        });

        $dl.append(
          $dd.html(
            $list.removeAttr('class').detach()
          )
        ).append(
          $dt
        );

        $target.append(
          $dl
        );
      }
    });
  };

  Drupal.behaviors.sitePortals = {
    attach: sitePortals
  };

})(jQuery);

// Select Links to portals

(function ($) {

  var socialShare = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'social-share';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);
      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var $printItem = $('<li />', {
          class: cssClass + '--item print'
        });
        var $printLink = $('<a />').text(Drupal.t('Print'));
        $printLink.on('click', function (e) {
          e.preventDefault();
          window.print();
        });
        $printItem.append($printLink);
        $target.append($printItem);
      }
    });
  };

  Drupal.behaviors.socialShare = {
    attach: socialShare
  };

})(jQuery);

// Rollover behavior for submenu & accordion system
/* global animCursor */
(function ($) {

  var subMenu = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'sub-menu';
    var $targets = $('.' + cssClass + ' > .menu', context);

    $targets.each(function () {
      var $target = $(this);

      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        // Tracker on rollover
        animCursor($target, 'a');

        // Check if accordions is enabled to activate it and place links in columns
        var $accordionsEnabled = $target.closest($('.accordions-enabled', context));
        if ($accordionsEnabled.length) {

          // Tracker element for rollover
          var $tracker = $('.tracker', $target);

          // Element for building future accordion
          var $menu = $('ul.menu', $target);
          var $menuItem = $menu.closest('.menu-item');
          var isAlternateMenu = $menuItem.parents('.menu-item').hasClass('alternate');
          var $trigger = $('<span />', {
            class: 'sub-menu--trigger'
          });

          // Prefix for accordion
          var cssGroup = '> li.menu-item';
          var cssTrigger = '.' + cssClass + '--trigger';
          var cssSection = 'ul.menu';

          // Place trigger for accordion and hide linked content
          if (isAlternateMenu) {
            $menu = $('.menu-item > ul.menu, .menu-item > .menu-dropdown > ul.menu', $menuItem);
            $menuItem = $menu.closest('.menu-level-2 > .menu-item');

            cssGroup = '> li.menu-item ul.menu > li.menu-item';
          }

          $('> a , > span', $menuItem).after($trigger);
          $menu.addClass('accordions-enabled--hide-item'); // Hide content by default

          // Items of menu to move inside column
          var $lis = $('> li.menu-item', $target);
          var maxLiPerColumn = Math.ceil($lis.length / 2);

          var cssPrefixAccordion = 'accordions-enabled--col';

          // Create columns and dispatch li
          if ($lis.length) {

            var $col1 = $('<div />', {
              class: cssPrefixAccordion
            });
            $col1.html($lis.slice(0, maxLiPerColumn).detach());
            $target.append($col1);

            var $col2 = $('<div />', {
              class: cssPrefixAccordion
            });
            $col2.html($lis.slice(maxLiPerColumn).detach());
            $target.append($col2);
          }

          // Options to launch accordion
          var cfg = {
            group: cssGroup,
            trigger: cssTrigger,
            section: cssSection,
            scrollTo: false,
            onAfterExpand: function () {
              $tracker.css('opacity', 0);
            },
            onBeforeCollapse: function () {
              $tracker.css('opacity', 0);
            }
          };
          $target.find('.' + cssPrefixAccordion).rsAccordion(cfg);
        }
      }
    });
  };

  Drupal.behaviors.subMenu = {
    attach: subMenu
  };

})(jQuery);

// Close message system

(function ($) {

  var systemMessage = function () {

    var cssClass = 'messages';

    $('body').on('click', '.' + cssClass + ' button[class*=close]', function (e) {
      $(this).closest('.' + cssClass).slideUp();
    });
  };
  systemMessage();

})(jQuery);

// Rollover behavior for Table Of Content
/* global animCursor */
(function ($) {

  var tableOfContent = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'table-of-content';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);

      if ($target.data('init-' + cssClass)) {
        return true; // continue
      }
      $target.data('init-' + cssClass, true);

      animCursor($target, '[class*="toc-h"]');
    });
  };

  Drupal.behaviors.tableOfContent = {
    attach: tableOfContent
  };

})(jQuery);


// Greybox for teaser gallery

(function ($) {

  var teaserGallery = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'teaser-gallery';
    var $targets = $('.' + cssClass, context);
    var $viewportWidth = getViewportWidth();
    var $body = $('body');

    var gb = new Greybox({
      onBeforeOpen: function () {
        $body.addClass('prevent-scroll');
      },
      onBeforeClose: function () {
        $body.removeClass('prevent-scroll');
      }
    });

    $targets.each(function () {
      var $target = $(this);

      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var $targetContent = $('.' + cssClass + '--content', $target);
        var targetTitle = $('.' + cssClass + '--name', $targetContent).text();
        var targetJob = $('.' + cssClass + '--job', $targetContent).text();
        var targetEmail = $('.' + cssClass + '--email', $targetContent).html();
        var targetPhone = $('.' + cssClass + '--phone', $targetContent).html();
        var targetCellphone = $('.' + cssClass + '--cellphone', $targetContent).html();
        var targetBio = $('.' + cssClass + '--bio', $targetContent).html();
        var $targetText = $('<div />');
        if (typeof targetJob === 'string') {
          $targetText.append('<p class="greybox--sub-title">' + targetJob + '</p>');
        }
        if (typeof targetEmail === 'string') {
          $targetText.append('<div class="wysiwyg"><p>' + targetEmail + '</p></div>');
        }
        if (typeof targetPhone === 'string') {
          $targetText.append('<p>' + targetPhone + '</p>');
        }
        if (typeof targetCellphone === 'string') {
          $targetText.append('<p>' + targetCellphone + '</p>');
        }
        if (typeof targetBio === 'string') {
          $targetText.append('<div class="wysiwyg marger-top">' + targetBio + '</div>');
        }

        var displayGb = function () {
          if (typeof targetTitle === 'string') {
            gb.setTitle(targetTitle);
          }
          gb.html($targetText);
          return false;
        };

        $target.on('click', displayGb);
      }
    });
  };

  Drupal.behaviors.teaserGallery = {
    attach: teaserGallery
  };

})(jQuery);

// Greybox for teaser gallery

(function ($) {

  var teaserGalleryGrayscale = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'teaser-gallery';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);

      if (!$target.data('init-' + cssClass + '-grayscale')) {
        $target.data('init-' + cssClass + '-grayscale', true);

        // Target img of teaser-gallery
        var $pictures = $('.' + cssClass + '--picture img', $target);

          // IE 10 only CSS properties
        var ie10Styles = ['msTouchAction', 'msWrapFlow'];

        var ie11Styles = ['msTextCombineHorizontal'];

        var d = document;
        var b = d.body;
        var s = b.style;
        var browser = null;
        var property;

        // Tests IE10 properties
        for (var i = 0; i < ie10Styles.length; i++) {
          property = ie10Styles[i];
          if (s[property] !== undefined) {
            browser = "ie10";
          }
        }

        // Tests IE11 properties
        for (var i = 0; i < ie11Styles.length; i++) {
          property = ie11Styles[i];
          if (s[property] !== undefined) {
            browser = "ie11";
          }
        }

        //Grayscale images only on browsers IE10+ since they removed support for CSS grayscale filter
        if(browser === "ie10" || browser === "ie11" ){

          //If the browser supports Filters, then we assume that it is Microsoft Edge
          if (Modernizr.cssfilters){
            $('body').addClass('edge'); // Adds Microsoft Edge class to the body
          }
          else {
            $('body').addClass('ie11'); // Fixes margin issue on IE10 and IE11 after canvas function on images
            $pictures.each(function() {
              var el = $(this);
              el.wrap("<div class='img_wrapper'>").clone().addClass('img_grayscale ieImage').insertBefore(el).queue(function(){
                var el = $(this);
                el.dequeue();
              });
              this.src = grayscaleIe(this.src);
            });

            // Custom grayscale function for IE10 and IE11
            function grayscaleIe(src){
              var canvas = document.createElement('canvas');
              var ctx = canvas.getContext('2d');
              var imgObj = new Image();
              imgObj.src = src;
              canvas.width = imgObj.width;
              canvas.height = imgObj.height;
              ctx.drawImage(imgObj, 0, 0);
              var imgPixels = ctx.getImageData(0, 0, canvas.width, canvas.height);
              for(var y = 0; y < imgPixels.height; y++){
                for(var x = 0; x < imgPixels.width; x++){
                  var i = (y * 4) * imgPixels.width + x * 4;
                  var avg = (imgPixels.data[i] + imgPixels.data[i + 1] + imgPixels.data[i + 2]) / 3;
                  imgPixels.data[i] = avg;
                  imgPixels.data[i + 1] = avg;
                  imgPixels.data[i + 2] = avg;
                }
              }
              ctx.putImageData(imgPixels, 0, 0, 0, 0, imgPixels.width, imgPixels.height);
              return canvas.toDataURL();
            }
          }
        }

        // If the browser does not support CSS filters filters, we are applying grayscale.js function
        // This part of Grayscale images applies to those browsers that do not support CSS filters
        if (!Modernizr.cssfilters) {
          var $images = $pictures, imageCount = $images.length, counter = 0;

          // One instead of on, because it need only fire once per image
          $images.one('load',function(){
            // increment counter every time an image finishes loading
            counter++;
            if (counter === imageCount) {
              // do stuff when all have loaded
              grayscale($pictures);
            }
          }).each(function () {
            if (this.complete) {
              // manually trigger load event in
              // event of a cache pull
              $(this).trigger('load');
            }
          });
        }
      }
    });
  };

  Drupal.behaviors.teaserGalleryGrayscale = {
    attach: teaserGalleryGrayscale
  };

})(jQuery);

// Greybox for teaser gallery

(function ($) {

  var teaserHighlightNews = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'teaser-highlight-news';
    var $targets = $('.' + cssClass + '.video', context);
    var $body = $('body');

    var gb = new Greybox({
      onBeforeOpen: function () {
        $body.addClass('prevent-scroll');
      },
      onBeforeClose: function () {
        $body.removeClass('prevent-scroll');
      }
    });

    $targets.each(function () {
      var $target = $(this);

      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var $targetVideo = $('.' + cssClass + '--picture', $target);
        var $targetVideoLink = $targetVideo.attr('data-youtube');

        if ($targetVideoLink !== ' ' && $targetVideoLink !== null) {

          $targetVideo.on('click', function (e) {

            // Disable link
            e.preventDefault();

            // Open gb youtube
            gb.youtube($targetVideoLink);
          });
        }
      }
    });
  };

  Drupal.behaviors.teaserHighlightNews = {
    attach: teaserHighlightNews
  };

})(jQuery);

// Animation for teaser keydata

(function ($) {

  var teaserKeyData = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'teaser-keydata';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);

      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        if($target.hasClass('has-animated-counter')) {
          animatedDigits($('.' + cssClass + '--highlight', $target), $target, _duration * 4);
        }
      }
    });
  };

  Drupal.behaviors.teaserKeyData = {
    attach: teaserKeyData
  };

})(jQuery);

// Animation for teaser keyfigure

(function ($) {

  var teaserKeyfigure = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'teaser-keyfigure';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);

      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        if($target.hasClass('has-animated-counter')) {
          animatedDigits($('.' + cssClass + '--data', $target), $target, _duration * 4);
        }
      }
    });
  };

  Drupal.behaviors.teaserKeyfigure = {
    attach: teaserKeyfigure
  };

})(jQuery);

// Animation for teaser keyfigure

(function ($) {

  var teaserListContacts = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'teaser-list-contacts';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);

      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var $chosenFields = $('.has-chosen', $target);

        if ($chosenFields.length > 0) {

          $chosenFields.chosen({
            no_results_text: 'No result corresponding to'
          });
        }
      }
    });
  };

  Drupal.behaviors.teaserListContacts = {
    attach: teaserListContacts
  };

})(jQuery);

// Slider Teaser Request

(function ($) {

  var sliderRequest = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'teaser-request-certificate';
    var cssClassSlider = cssClass + '--slider';
    var cssClassList = cssClassSlider + '--list';
    var cssClassSlide = cssClassSlider + '--slide';
    var cssClassPager = cssClassSlider + '--pager';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);

      if (!$target.data('init-' + cssClass) && $('.' + cssClassList, $target).length) {
        $target.data('init-' + cssClass, true);

        var $list = $('.' + cssClassList, $target);
        var $slides = $('.' + cssClassSlide, $target);
        var $pager = $('.' + cssClassPager, $target);
        var $counter = $('.' + cssClassPager + '--current', $target);
        var $total = $('.' + cssClassPager + '--total', $target);
        $total.html($slides.length);

        if ($slides.length > 1) {
          $list.responsiveSlider({
            adaptativeHeight: true,
            sliderRange: 1,
            loop: true,
            pager: function (_self, $prev, $next) {
              $pager.prepend($prev);
              $pager.append($next);
            },
            onBeforeSlide: function (datas) {
              $counter.html(datas.target.index + 1);
            }
          });
        }
        else {
          $pager.hide();
        }
      }
    });
  };

  Drupal.behaviors.sliderRequest = {
    attach: sliderRequest
  };

})(jQuery);

// Tooltip

(function ($) {
  var tooltip = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'tooltip--button';
    var $targets = $('.' + cssClass, context);

    if ($targets.length > 0) {

      var toogleTooltip = function () {

        var $tootlipAction = $(this).closest('.tooltip').find('.tooltip--action');
        var $tootlipActions = $('.tooltip--action');
        var bIsVisible = $tootlipAction.hasClass('is-visible');
        $tootlipActions.removeClass('is-visible');
        if (!bIsVisible) {
          $tootlipAction.addClass('is-visible');
        }

        if ($tootlipAction.hasClass('to-duplicate')) {

          $('a', $tootlipAction).each (function () {

            var $link = $(this);

            var valueToDuplicate = $link.text();
            var $btnDuplicate = $('<span />', {
              class: 'link-icons duplicate no-text'
            });
            $btnDuplicate.text(Drupal.t('Duplicate'));
            $link.after($btnDuplicate);
            $btnDuplicate.on('click', function () {

              var $tmpCopy = $('<textarea />').css({
                position: 'absolute',
                top: 0,
                transform: 'translate(-100%, -100%)'
              });
              $tootlipAction.append($tmpCopy);

              $tmpCopy.html(valueToDuplicate);
              $tmpCopy.select();
              document.execCommand('copy');
              $tmpCopy.remove();
            });
          });
        }
      };

      var stickyTooltipToogle = function () {

        var $stickyTooltip  = $('.sticky-thead .' + cssClass, context);
        if ($stickyTooltip.length > 0) {
          $stickyTooltip.on('click', toogleTooltip);

          $(window).off('scroll', stickyTooltipToogle);
        }
      };

      $targets.each(function () {
        var $target = $(this);
        if (typeof $target.data('init-' + cssClass) !== 'undefined') {
          return true; // continue
        }
        $target.data('init-' + cssClass, true);

        $target.on('click', toogleTooltip);

        if ($target.parents('.with-tooltip').parents('.stickytable').length > 0) {
          console.log('stickytable button', $target);

          $(window).on('scroll', stickyTooltipToogle);
        }
      });

      $(document).on('click', function (event) {
        if (!$(event.target).closest('.tooltip').length) {
          if ($('.tooltip--action').is(':visible')) {
            $('.tooltip--action').removeClass('is-visible');
          }
        }
      });
    }
  };

  Drupal.behaviors.tooltip = {
    attach: tooltip
  };
})(jQuery);

// Select Links to portals

(function ($) {

  var veristarLoginMenu = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'veristar-login-menu';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);
      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var $siteHeader = $target.parents('.site-header');
        var $trigger = $('.' + cssClass + '--title, > h2', $target);
        var $menu = $('.' + cssClass + '--list, > ul', $target);

        if ($trigger.length && $menu.length && $siteHeader.length) {

          // Add layer to manage click outside
          var $layer = $('<div />', {
            class: cssClass + '--layer'
          });
          $('body').append($layer);
          $layer.hide();

          // Manage menu
          $target.addClass('collapsed');
          $trigger.on('click', function () {
            $menu.slideToggle(400);
            $target.toggleClass('collapsed');
            $layer.toggle();
          });

          $layer.on('click', function () {
            $menu.slideUp(400);
            $target.addClass('collapsed');
            $layer.hide();
          });
        }
      }
    });
  };

  Drupal.behaviors.veristarLoginMenu = {
    attach: veristarLoginMenu
  };

})(jQuery);

// Custom input file & animated label

(function ($) {

  var form = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    // For animated label
    var $targets = $('form:not(.views-exposed-form):not([id^=views-exposed-form])', context);

    $targets.each(function () {
      var $target = $(this);

      var $files = $('input[type=file]:not(.form-drop-file)', $target);
      $files.each(function () {
        var $file = $(this);
        if ($file.data('init-form-file')) {
          return true; // continue
        }
        $file.data('init-form-file', true);
        var text = localSettings.add_attachment;
        var $fake_file = $('<div />', {
          class: 'form-file'
        });
        $fake_file.text(text);
        $fake_file.click(function () {
          $file.click();
        });

        $file.after($fake_file);
        $file.hide();
        $file.change(function () {
          var $this = $(this);
          var value = $this.val();
          var result = localSettings.replace_attachment + '<span>' + value.split('\\').pop() + '</span>';

          if (value === '') {
            result = text;
          }
          $fake_file.html(result);
        });
      });

      var $dropFiles = $('input[type=file].form-drop-file', $target);
      $dropFiles.each(function () {
        var $file = $(this);
        if ($file.data('init-form-drop-files')) {
          return true; // continue
        }
        $file.data('init-form-drop-files', true);
        var $dropZone = $file.closest('.form-drop-file-zone');
        var idDropZone = $file.attr('id');
        var $previews = $('<div>', {
          class: 'dropzone-previews',
          id: idDropZone + '--previews'
        });
        $dropZone.append($previews);
        var $inputsHidden = $('<div>', {
          id: idDropZone + '--inputs-hidden'
        });
        $dropZone.append($inputsHidden);
        var $button = $('.button-action', $dropZone);
        var options = $dropZone.data('dropzone-options');
        var url = $dropZone.data('dropzone-url');
        if ($dropZone.length) {
          $file.hide();
          $dropZone.dropzone($.extend({}, {
            previewsContainer: '#' + idDropZone + '--previews',
            hiddenInputContainer: '#' + idDropZone + '--inputs-hidden',
            addRemoveLinks: true,
            thumbnailWidth: 100,
            thumbnailHeight: 45
          },
            typeof options === 'string' ? JSON.parse(options) : {},
            typeof url === 'string' ? {url: url} : {}
          ));
          setTimeout(function () {
            $dropZone.addClass('dropzone');

            $button.on('click', function () {
              $dropZone.trigger('click');
            });
          }, 0);
        }
      });

      var $inputs = $('label:not(.visually-hidden) + input:not(:checkbox):not(:radio):not(:file):not(.not-animated-label), label:not(.visually-hidden) + .form-textarea-wrapper textarea, label:not(.visually-hidden) + select:not(.not-animated-label)', $target);
      $inputs.each(function () {
        var $input = $(this);
        if ($input.data('init-form-input')) {
          return true; // continue
        }
        $input.data('init-form-input', true);
        var $label = $input.prev();

        if ($label.length === 0) {
          $label = $input.parent().prev();
        }

        if (!$input.attr('placeholder') && $input[0].tagName !== 'SELECT') {
          $input.attr('placeholder', $label.text());
        }

        if ($label.hasClass('form-required')) {
          if ($input[0].tagName !== 'SELECT') {
            var $placeholder = $input.attr('placeholder') + '*';
            $input.attr('placeholder', $placeholder);
          }
          else {
            var $firstOption = $input.find('option').eq(0);
            if ($firstOption.html() !== '' && ($firstOption.attr('value') === '' || $firstOption.attr('value') === 0)) {
              $firstOption.html($firstOption.html() + '*');
            }
          }
        }

        var $field = $('<div />', {
          class: 'animated-label'
        });

        $input.wrap($field);
        $input.after($label.detach());

        var empty = function () {
          var value = $input.val();
          var $parent = $input.parent();
          $parent.removeClass('not-empty');

          if (value !== '' && value !== null) {
            $parent.addClass('not-empty');
          }
        };

        $input.on('focus', empty);
        $input.on('blur', empty);
        $input.on('change', empty);
      });
    });

    // Change default scroll to invalide field by adding header size
    var $targets2 = $('form', context);

    if ($targets2.length) {

      var $header = $('.site-header', context);
      var headerHeight;
      var actualScrollPosition;

      $targets2.each(function () {

        var $target = $(this);

        var scrollOnInvalidField = function () {

          var $invalidField = $target.find('input:invalid, textarea:invalid, select:invalid');

          if ($invalidField.length > 0) {
            var $input = $invalidField.first();

            // Element position in the page
            var eltScrollPosition = $input.parents('.form-item, .form-grid-1, .form-grid-2').offset().top;

            // Get actual header height
            headerHeight = $header.height();

            // Update position to scroll according header if is sticky
            eltScrollPosition -= 50;
            actualScrollPosition = window.scrollY;
            if ($header.hasClass('sticky')) {
              eltScrollPosition -= headerHeight;
              actualScrollPosition += headerHeight;
            }

            // Don't scroll if we already see the invalid file
            if (eltScrollPosition > actualScrollPosition && eltScrollPosition < actualScrollPosition + window.innerHeight) {
              $target[0].reportValidity();
              return false;
            }

            return animatedScrollTo(eltScrollPosition, function (e) {

              // And show error message
              $target[0].reportValidity();
            });
          }
        };
        $target.find('input[type=submit]').on('click', scrollOnInvalidField);
      });
    }
  };

  Drupal.behaviors.form = {
    attach: form
  };

})(jQuery);

(function ($) {

  var jsDataTable = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'js-data-table';
    var $targets = $('.' + cssClass, context);
    var pathname = window.location.pathname.split('/').slice(-1).pop().split('.')[0];

    $targets.each(function () {
      var $target = $(this);
      var $table = $('table', $target);
      var firstUse = true;

      $.fn.dataTable.ext.classes.sPaging = 'pager__items ';
      $.fn.dataTable.ext.classes.sPageButton = 'pager__item';
      $.fn.dataTable.ext.classes.sPageButtonActive = 'is-active';
      $.fn.dataTable.ext.classes.sInfo = 'list-results--results';
      $.fn.dataTable.ext.classes.sFilter = 'advanced-search-field alternate';

      var cfg = {
        dom: 'f<"padder-left padder-right" i><"wrapper"<"list-results--header" l<"list-results--items-to-display" B>><"dataTable--wrapper" t><"pager"p>>',
        lengthMenu: [10, 25, 50, 100],
        infoCallback: function (settings, start, end, max, total) {
          var text = Drupal.t('Number of results: ');
          var $wrapper = $('.wrapper', $target);
          $wrapper.hide();

          if (total === 0) {
            return text + 0;
          }
          else {
            $wrapper.show();
            return text + total;
          }
        },
        // fixedHeader: {
        //   headerOffset: $('.site-heading').height()
        // },
        order: [0, 'asc'],
        buttons: [
          {
            text: Drupal.t('Download PDF'),
            className: 'button-action small has-icon icon-download',
            extend: 'pdf',
            filename: function () {
              return 'Bureau-Veritas_' + pathname;
            },
            title: function () {
              return 'Bureau Veritas | ' + pathname.replace(/[-_]/g, ' ');
            },
            exportOptions: {
              modifier: {
                page: 'current'
              }
            },
            customize: function (doc) {
              doc.pageMargins = [20, 20, 20, 20];
              doc.styles = {
                tableHeader: {
                  color: 'black',
                  fillColor: 'white',
                  alignment: 'left',
                  bold: true
                },
                title: {
                  bold: true,
                  fontSize: 20,
                  alignment: 'center'
                }
              };
              // doc.content[1].table.widths = ['15%', '15%', '15%', '15%', '40%'];

              var $body = doc.content[1].table.body;
              $('tr', $table).each(function (index) {

                if (index % 2) {
                  $.each($body[index], function (i, td) {
                    td.fillColor = '#eaeaea';
                  });
                }
              });

              var objLayout = {};
              objLayout['hLineWidth'] = function () {
                return .25;
              };
              objLayout['vLineWidth'] = function () {
                return .25;
              };
              objLayout['hLineColor'] = function () {
                return '#eaeaea';
              };
              objLayout['vLineColor'] = function () {
                return '#eaeaea';
              };
              objLayout['paddingLeft'] = function () {
                return 10;
              };
              objLayout['paddingRight'] = function () {
                return 10;
              };
              objLayout['paddingTop'] = function () {
                return 10;
              };
              objLayout['paddingBottom'] = function () {
                return 10;
              };
              doc.content[1].layout = objLayout;
            }
          },
          {
            text: Drupal.t('Download XLSX'),
            className: 'button-action small has-icon icon-download',
            extend: 'excel',
            filename: function () {
              return 'Bureau-Veritas_' + pathname;
            },
            title: function () {
              return 'Bureau Veritas | ' + pathname;
            },
            exportOptions: {
              modifier: {
                page: 'current'
              }
            }
          },
          {
            text: Drupal.t('Reset'),
            className: 'button-action small',
            action: function (e, dt) {
              $(".content-filters").trigger("reset");
              dt.search('');
              dt.columns().search('');
              dt.page(0);
              dt.draw();
              $('.display-per-page--label').eq(0).trigger('click');
              var $filters = $('.filters');
              $('select option:selected', $filters).removeAttr('selected');
              $('.has-chosen', $filters).trigger('chosen:updated');
            }
          }
        ],
        initComplete: function () {
          var $banner = $('<form />', {class: 'content-filters filters columns'});
          var $content = $('<div />', {class: 'content-filters--container'});
          var $this = this;

          var $th = $('thead th', $table);
          var $sortDate = false;

          $th.each(function () {
            var $this = $(this);
            if ($this.attr('data-filter-name') === 'date_range') {
              $sortDate = true;
            }
          });

          if (typeof drupalSettings !== 'undefined' && drupalSettings.filter_unique_values !== null) {

            $.each(drupalSettings.filter_unique_values, function (index, value) {

              var $item = $('<div />', {class: 'form-item'});
              var $select = $('<select />', {class: 'has-chosen'});

              var $th = $('thead th', $table);
              $th.each(function () {
                var $target = $(this);
                if ($target.attr('data-filter-name') === index) {
                  $target.addClass(index);
                  $select.attr('data-name', index);
                  $select.attr('data-placeholder', $target.text());
                }
              });

              $select.attr('multiple', 'multiple');
              $item.append($select);
              $content.append($item);

              $.each(value, function (index, data) {
                var $option = $('<option />', {
                  value: data
                });
                $option.text(data);
                $select.append($option);
              });

              $select.change(function () {
                var $target = $(this);
                var className = '.' + $target.data('name');
                var regEx = $(this).find(':selected').map(function () {
                  return $(this).text();
                }).get().join('|');

                $this.api().columns(className).every(function () {
                  this.search(regEx, true, false).draw();
                });
              });
            });

            $banner.append($content);
          }

          if (typeof drupalSettings !== 'undefined' && drupalSettings.url_server_processing && $sortDate === true) {

            var $dates = $('<div />', {
              class: 'content-filters--container'
            });
            var $startDate = $('<input />', {
              class: 'startDate sortDates',
              type: 'text',
              id: 'startDate',
              placeholder: 'Select start date'
            });
            var $endDate = $('<input />', {
              class: 'endDate sortDates',
              type: 'text',
              id: 'endDate',
              placeholder: 'Select end date'
            });

            var $containerStartDate = $('<div />', {
              class: 'form-item'
            }).html($startDate);
            var $containerEndDate = $('<div />', {
              class: 'form-item'
            }).html($endDate);

            $dates.append($containerStartDate).append($containerEndDate);
            $banner.append($dates);

            var lang = $('html').attr('lang');
            $.datepicker.setDefaults($.datepicker.regional[lang]);

            $('.sortDates', $dates).datepicker({
              defaultDate: '+1w',
              showOtherMonths: true,
              selectOtherMonths: true,
              changeMonth: true,
              changeYear: true
            });

            $startDate.change(function () {
              $endDate.datepicker('option', 'minDate', this.value);
              addDate($(this).datepicker('getDate'), $endDate.datepicker('getDate'));
            });

            $endDate.change(function () {
              $startDate.datepicker('option', 'maxDate', this.value);
              addDate($startDate.datepicker('getDate'), $(this).datepicker('getDate'));
            });

            var addDate = function (from, to) {

              if (from !== null && to !== null) {
                $this.api().columns().search().draw();
              }
            };
          }

          if (typeof drupalSettings !== 'undefined' && (drupalSettings.filter_unique_values !== null || $sortDate === true)) {
            $table.closest('.container').before($banner);
            Drupal.behaviors.contentFilters.attach();
            Drupal.behaviors.chosenJs.attach();
          }

          var $searchContainer = $('<div />', {class: 'container text-center-from-mobile'});
          var $searchContent = $('<div />', {class: 'container--content'});
          $searchContainer.append(
            $searchContent.append($('.advanced-search-field'))
          );
          $table.closest('.container').before($searchContainer);

          var $displayPerPage = $('<div />', {class: 'display-per-page'});
          var $title = $('<span />', {class: 'display-per-page--title'});
          var $datatableLength = $('.dataTables_length');

          $title.text($('span', $datatableLength).text());
          $displayPerPage.prepend($title);
          $('select option', $datatableLength).each(function () {
            var $this = $(this);
            var value = $this.text();
            var $label = $('<span />', {class: 'display-per-page--label'});
            $label.text(value);

            $label.click(function () {
              $this.prop('selected', true);
              $this.parent().trigger('change');
              $label.addClass('active');
              $label.siblings().removeClass('active');
            });

            if ($this.filter(':selected').val() === value) {
              $label.addClass('active');
            }

            $displayPerPage.append($label);
          });
          $datatableLength.before($displayPerPage);
          $datatableLength.hide();
        },
        language: {
          lengthMenu: '<span>' + Drupal.t('Display per page') + '</span> _MENU_',
          infoFiltered: '',
          search: '_INPUT_',
          searchPlaceholder: Drupal.t('Search By Keyword'),
          paginate: {
            previous: '',
            next: ''
          },
          aria: {
            paginate: {
              previous: 'Previous',
              next: 'Next'
            }
          }
        },
        drawCallback: function () {
          $('tbody td', $table).each(function () {
            var $element = $(this);

            var truncate = function () {
              $('.js-truncate-wrapper', $element).contents().unwrap();
              $('.js-link', $element).remove();
              $('.js-dots', $element).remove();
              var $wrapper = $('<div />', {class: 'js-truncate-wrapper'});

              var $maxLines = 8;
              var lineHeight = parseInt($element.css('line-height')) / 16;
              var maxHeight = $maxLines * lineHeight + 'rem';

              $wrapper.css({
                position: 'relative',
                overflow: 'hidden',
                maxHeight: maxHeight
              });
              $element.wrapInner($wrapper);

              var height = Math.round($('.js-truncate-wrapper', $element).height());

              if (parseInt(maxHeight) * 16 <= height) {
                var $link = $('<span />', {
                  class: 'js-link'
                }).text(Drupal.t('See more'));
                var $dots = $('<span />', {
                  class: 'js-dots'
                }).text('(...)');
                $link.click(function () {
                  var $this = $(this);
                  $this.fadeOut(function () {
                    $this.parent().children(0).css('max-height', 'initial');
                    $this.remove();
                    $dots.remove();
                  });
                  return false;
                });
                $element.append($dots).append($link);
              }
            };

            truncate();
            $(window).resize(function () {
              truncate();
            });
          });

          var $searchContainer = $('.advanced-search-field').parent();
          var $header = $('.site-header', context);
          if (firstUse === false) {
            animatedScrollTo($searchContainer.offset().top - $header.height());
          }
          firstUse = false;
        }
      };

      if (typeof drupalSettings !== 'undefined' && drupalSettings.url_server_processing) {
        cfg['processing'] = true;
        cfg['serverSide'] = true;
        cfg['ajax'] = {
          url: drupalSettings.url_server_processing,
          data: function ( d ) {
            return $.extend( {}, d, {
              "column_name": {
                "start_date": $('.startDate').val(),
                "end_date": $('.endDate').val(),
              }
            });
          }
        };
      }

      $table.DataTable(cfg);
    });
  };

  Drupal.behaviors.jsDataTable = {
    attach: jsDataTable
  };

})(jQuery);

(function ($) {

  var openPopin = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'js-open-popin';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);

      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var $body = $('body');

        var targetClass = $target.data('target');
        var $title = $('.' + targetClass + '--title').html();

        var greyboxOption = {
          onBeforeOpen: function () {
            $body.addClass('prevent-scroll');
          },
          onBeforeClose: function () {
            $body.removeClass('prevent-scroll');
          },
          onAfterClose: function (self) {
            var $content = $('.' + targetClass + '--form', self.$content).detach();
            $('.' + targetClass).append($content);
          }
        };

        $target.on('click', function () {
          var gb = new Greybox(greyboxOption);
          var $content = $('.' + targetClass + '--form').detach();

          gb.setTitle($title);
          gb.setClass('title-center');
          gb.html($content);
          return false;
        });
      }
    });
  };

  Drupal.behaviors.openPopin = {
    attach: openPopin
  };

})(jQuery);


// Accordion system for software information

(function ($) {

  var layerAccordionInfo = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'layer-accordion-info';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);
      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var cfg = {
          group: '> li',
          trigger: '> .' + cssClass + '--trigger, > div > .' + cssClass + '--trigger',
          section: '> .' + cssClass + '--content, > div > .' + cssClass + '--content',
          onAfterExpand: function (id, _self) {
            var $trigger = $('.expanded', _self[id]);
            var triggerTop = $trigger.offset().top;
            var position = triggerTop;
            var $nav = $('.site-header', context);
            if ($nav.hasClass('sticky')) {
              position += -1 * $nav.height();
            }
            if ($trigger.closest('.stickytable').length) {
              position += -1 * $trigger.closest('.stickytable').children('thead').height();
            }
            animatedScrollTo(position);
          }
        };
        $target.rsAccordion(cfg);
      }
    });
  };

  Drupal.behaviors.layerAccordionInfo = {
    attach: layerAccordionInfo
  };

})(jQuery);

// Accordion system for software information

(function ($) {

  var layerContactOffer = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'layer-contact-offer';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);
      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        //Dropdown message
        var $triggerDropDown = $('.js-message', $target);
        var $targetDropdown = $('.' + cssClass + '--form, form', $target);

        if ($triggerDropDown.length && $targetDropdown.length) {
          $targetDropdown.hide();

          $triggerDropDown.on('click', function () {
            $targetDropdown.slideToggle('slow');
          });
        }

        // Add datepicker
        var publicHolidays = ['01-11-2018', '11-11-2018', '25-12-2018'];
        var lang = $('html').attr('lang');

        // example: french translation
        $.datepicker.regional[lang] = {
          monthNames: ['Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Aout', 'Septembre', 'Octobre', 'Novembre', 'Décembre'],
          dayNamesShort: ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'],
          dateFormat: 'dd-mm-yy'
        };
        $.datepicker.setDefaults($.datepicker.regional[lang]);

        var format = $.datepicker.regional[lang].dateFormat;
        $('#dates').datepicker({
          beforeShowDay: function(date) {
            var formatDate = $.datepicker.formatDate(format, date);
            var noWeekend = $.datepicker.noWeekends(date);
            if (noWeekend[0]) {
              return [$.inArray(formatDate, publicHolidays) === -1];
            }
            else {
              return noWeekend;
            }
          },
          appendText: '<span class="field-description">' + Drupal.t('date format to follow: ') + format + '</span>',
          dayNamesMin: $.datepicker.regional[lang].dayNamesShort,
          minDate: 0,
          showOtherMonths: true,
          selectOtherMonths: true
        });
      }
    });
  };

  Drupal.behaviors.layerContactOffer = {
    attach: layerContactOffer
  };

})(jQuery);

// Page Hat

(function ($) {

  var layerCover = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'layer-cover';
    var $targets = $('.' + cssClass, context);
    var $body = $('body', context);
    var isArticlePage = $body.hasClass('page-node-type-magazine') || $body.hasClass('page-node-type-training');
    var siteHeaderHeight = $('.site-heading').height();

    if (!isArticlePage) {

      $targets.each(function () {
        var $target = $(this);

        // Add scroll bottom
        var $scroll = $('.' + cssClass + '--scroll-bottom');
        if (!$scroll.length) {
          if (!($target.closest('.page-intro').length)) {
            $scroll = $('<span />', {
              class: cssClass + '--scroll-bottom'
            });
          }
          $target.append($scroll);
        }

        var $scrollTarget = $target.offset().top + $target.height();

        $scroll.click(function () {
          $('html,body').animate({
            scrollTop: $scrollTarget
          }, 'slow');
        });

        // Append height style if found page-intro
        if ($target.closest('.page-intro').length) {
          $target.closest('.page-intro').css({ height: 'calc(100vh - ' + siteHeaderHeight + 'px)' })
        }
      });
    }
  };

  Drupal.behaviors.layerCover = {
    attach: layerCover
  };

})(jQuery);

// Animation Scroll Presentation

(function ($) {

  var layerImagesGroup = function (context, options) {

    var vh = $(window).height();
    var vw = $(window).width();
    if (vw < 640) { // no paralax effect on mobile
      return false;
    }

    if (typeof context === 'undefined') {
      context = document;
    }
    // set animated-scroll-debug=true in the store locator to enabled debug mode

    var _self = this;

    _self.settings = {
      itemClass: 'layer-images-group',
      bAnimatedScrollDebug: false
    };


    _self.settings.itemTarget = '.' + _self.settings.itemClass;
    _self.settings.$item = $(_self.settings.itemTarget);

    if (!_self.settings.$item.length) {
      return false;
    }

    setTimeout(function () {

      var scrollerImagesGroug = [];
      _self.settings.$item.each(function (key, item) {

        // initialize the plugin, pass in the class selector for the sections of
        // content (blocks)
        scrollerImagesGroug[key] = $.scrollorama({
          enablePin: false, // avoid absolute position af container
          blocks: $(this)
        });

        if ($(this).hasClass('is-horizontal')) {
          // horizontal parallax
          if ($(this).find(_self.settings.itemTarget + '--picture.position-1').length) {
            scrollerImagesGroug[key]
              .animate($(this).find(_self.settings.itemTarget + '--picture.position-1'), {
                duration: vh / 2,
                delay: -1 * vh * 3 / 4,
                property: 'width',
                start: 0,
                end: '55%'
              });
          }
          if ($(this).find(_self.settings.itemTarget + '--picture.position-2').length) {
            scrollerImagesGroug[key]
              .animate($(this).find(_self.settings.itemTarget + '--picture.position-2'), {
                duration: vh * 2 / 3,
                delay: -vh / 2,
                property: 'right',
                start: -.7 * vw,
                end: 1.7 * vw
              });
          }
          if ($(this).find(_self.settings.itemTarget + '--picture.position-3').length) {
            scrollerImagesGroug[key]
              .animate($(this).find(_self.settings.itemTarget + '--picture.position-3'), {
                duration: 2 * vh,
                delay: -vh * 4 / 5,
                property: 'left',
                start: -.5 * vw,
                end: 1.7 * vw
              });
          }
          if ($(this).find(_self.settings.itemTarget + '--picture.position-4').length) {
            scrollerImagesGroug[key]
              .animate($(this).find(_self.settings.itemTarget + '--picture.position-4'), {
                duration: vh * 2 / 3,
                delay: -vh * 3 / 10,
                property: 'right',
                start: 1.1 * vw,
                end: -1 * vw
              });
          }
        }
        else {
          // default : vertical parallax
          if ($(this).find(_self.settings.itemTarget + '--picture.position-1').length) {
            scrollerImagesGroug[key]
              .animate($(this).find(_self.settings.itemTarget + '--picture.position-1'), {
                duration: 2 * vh,
                delay: -vh,
                property: 'top',
                start: 1.2 * vh,
                end: -1.2 * vh
              });
          }
          if ($(this).find(_self.settings.itemTarget + '--picture.position-2').length) {
            scrollerImagesGroug[key]
              .animate($(this).find(_self.settings.itemTarget + '--picture.position-2'), {
                duration: 2 * vh,
                delay: -vh,
                property: 'top',
                start: -.5 * vh,
                end: 1.7 * vh
              });
          }
          if ($(this).find(_self.settings.itemTarget + '--picture.position-3').length) {
            scrollerImagesGroug[key]
              .animate($(this).find(_self.settings.itemTarget + '--picture.position-3'), {
                duration: 2 * vh,
                delay: -vh,
                property: 'top',
                start: 1.8 * vh,
                end: -1.4 * vh
              });
          }
          if ($(this).find(_self.settings.itemTarget + '--picture.position-4').length) {
            scrollerImagesGroug[key]
              .animate($(this).find(_self.settings.itemTarget + '--picture.position-4'), {
                duration: 2 * vh,
                delay: -vh,
                property: 'top',
                start: -.2 * vh,
                end: .7 * vh
              });
          }
        }
      });
    }, 1000);
  };

  Drupal.behaviors.layerImagesGroup = {
    attach: layerImagesGroup
  };

})(jQuery);

// Animation Scroll Presentation

(function ($) {

  var layerPresentation = function (context, options) {

    var vh = $(window).height();
    var vw = $(window).width();
    if (vw < 640) { // no paralax effect on mobile
      return false;
    }

    if (typeof context === 'undefined') {
      context = document;
    }
    // set animated-scroll-debug=true in the store locator to enabled debug mode

    var _self = this;

    _self.settings = {
      itemClass: 'layer-presentation',
      bAnimatedScrollDebug: false,
    };


    _self.settings.itemTarget = '.' + _self.settings.itemClass;
    _self.settings.$item = $(_self.settings.itemTarget);

    if (!_self.settings.$item.length) {
      return false;
    }


    // initialize the plugin, pass in the class selector for the sections of
    // content (blocks)
    var scrollorama = $.scrollorama({
      enablePin: false, // avoid absolute position af container
      blocks: _self.settings.$item
    });

    // animate some examples
    if ($(_self.settings.itemTarget + '--top .teaser-highlight--picture').length) {
      scrollorama
        .animate(_self.settings.itemTarget + '--top .teaser-highlight--picture', {
          duration: vh,
          delay: -vh,
          property: 'top',
          start: -.7 * $(_self.settings.itemTarget + '--top .teaser-highlight--picture').height()
        });
    }
    if ($(_self.settings.itemTarget + '--top .teaser-highlight--content').length) {
      scrollorama
        .animate(_self.settings.itemTarget + '--top .teaser-highlight--content', {
          duration: vh,
          delay: -vh,
          property: 'top',
          start: -.3 * $(_self.settings.itemTarget + '--top .teaser-highlight--content').height()
        });
    }
    if ($(_self.settings.itemTarget + '--bottom .teaser-highlight').length) {
      scrollorama
        .animate(_self.settings.itemTarget + '--bottom .teaser-highlight', {
          duration: vh,
          delay: -vh,
          property: 'top',
          start: .3 * $(_self.settings.itemTarget + '--bottom .teaser-highlight').height()
        });
    }
    if ($(_self.settings.itemTarget + '--bottom .teaser-keydata').length) {
      scrollorama
        .animate(_self.settings.itemTarget + '--bottom .teaser-keydata', {
          duration: vh,
          delay: -vh,
          property: 'top',
          start: 1 * $(_self.settings.itemTarget + '--bottom .teaser-keydata').height()
        });
    }
  };

  Drupal.behaviors.layerPresentation = {
    attach: layerPresentation
  };

})(jQuery);

// Accordion & tabs for Archive Download Block

(function ($) {

  var tabsSwitcher = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'layer-tabs-switcher';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);
      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var $tabsSwitcher = $('.' + cssClass + '--tabs-list', $target);

        var cfg = {
          group: '> li',
          trigger: '.' + cssClass + '--trigger',
          section: '.' + cssClass + '--content',
          startOpened: ':first',
          scrollTo: true,
          responsive: {
            640: {
              tabsClass: cssClass + '--tabs-nav',
              tabs: function (tabs) {
                $('> li', tabs).each(function (i) {
                  var $li = $(this);
                  var span = $('<span />', {
                    class: cssClass + '--trigger'
                  });
                  $li.wrapInner(span);
                });
                $tabsSwitcher.before(tabs);
              },
              duration: 0,
              scrollTo: false,
              atLeastOne: true
            }
          }
        };
        $tabsSwitcher.rsAccordion(cfg);
      }
    });
  };

  Drupal.behaviors.tabsSwitcher = {
    attach: tabsSwitcher
  };

})(jQuery);

// Page Hat

(function ($) {

  var layoutCover = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'layout-cover';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);

      // Add scroll bottom
      var $scroll = $('.' + cssClass + '--scroll-bottom');
      if (!$scroll.length) {
        $scroll = $('<span />', {
          class: cssClass + '--scroll-bottom'
        });
        $target.append($scroll);
      }

      $scroll.click(function () {
        $('html,body').animate({
          scrollTop: $target.next().offset().top
        }, 'slow');
      });
    });
  };

  Drupal.behaviors.layoutCover = {
    attach: layoutCover
  };

})(jQuery);

var magazineWallInstances = [];
(function ($) {

  var magazineWall = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'magazine-wall';
    var $targets = $('.' + cssClass, context);

    $targets.each(function (index) {
      var $target = $(this);

      // Move optin block
      var $optinBlock = $('.optin-block', $target);

      if ($optinBlock.length) {
        $target.before($optinBlock);
      }

      // Launch wall of content
      if (!$target.data('init-' + cssClass)) {

        $target.data('init-' + cssClass, true);

        // Build Wall of Content (Masonry) to display list
        magazineWallInstances[index] = $target.wallOfContent({
          target: $target,
          wallContainerClass: cssClass + '--container',
          wallColClass: cssClass + '--col',
          blocksToOrder: '.teaser-links, .teaser-event, .teaser-highlight-news',
          bypass: true,
          responsive: {
            640: {
              bypass: false,
              grid: 2
            }
          }
        });
      }
      else {
        if (typeof magazineWallInstances[index] !== 'undefined' && typeof magazineWallInstances[index].reload === 'function') {
          magazineWallInstances[index].reload();
        }
      }
    });
  };

  Drupal.behaviors.magazineWall = {
    attach: magazineWall
  };

})(jQuery);

(function ($) {

  var needsForm = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'needs-form';
    var cssClassWrapper = 'needs-wrapper';
    var cssClassForm = cssClass + '--form';
    var cssClassFilters = 'needs-filters';
    var cssClassOption = 'button-checkbox-radio';
    var cssClassSubmit = cssClass + '--submit';
    var cssClassReset = cssClass + '--reset';
    var cssClassDropDown = cssClass + '--dropdown';
    var cssClassIsOpened = cssClassDropDown + '-is-opened';
    var cssClassLayerOut = cssClassDropDown + '--layer-out';
    var cssClassLayerContainer = cssClassDropDown + '--layer-container';
    var cssClassLayerContainerInner = cssClassDropDown + '--layer-container--inner';
    var cssClassLayerContainerContent = cssClassDropDown + '--layer-container--content';
    var cssClassClose = cssClassDropDown + '--close';
    var cssClassMaskTop = cssClassLayerContainer + '--mask-top';
    var cssClassMaskBottom = cssClassLayerContainer + '--mask-bottom';
    var cssClassTracker = cssClassDropDown + '--tracker';
    var cssClassList = cssClassDropDown + '--list';
    var cssClassItem = cssClassDropDown + '--item';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);

      if ($target.data('init-' + cssClass)) {
        return true; // continue
      }
      $target.data('init-' + cssClass, true);

      // move Drupal content in good place
      var $form = $target.find('.' + cssClassForm);
      $form.append($('.' + cssClassSubmit)); // move btn submit

      // create select from view filter
      $('.' + cssClassWrapper + ' .view-filters select').each(function () {
        var $select = $(this);
        var $label = $select.siblings('label');
        var label = $label.html();
        var name = $select.attr('name');

        $('#' + cssClass + '--select-' + name).data({
          $select: $select,
          label: label
        }).addClass('needs-select').append('<span class="needs-select--inner">' +
          '<span class="needs-select--label">' + label + '</span>' +
          '</span>');
      });

      var $filtersTags = $('.' + cssClassFilters, context);
      var $displayFiltersFieldset = $('.' + cssClassFilters + '--fieldset', context);
      var $filtersTagsDrupal = $('.' + cssClassWrapper + ' .view-filters fieldset[data-drupal-selector="edit-tag"]');
      var $resetBtnDrupal = $('.' + cssClassWrapper + ' .view-filters [data-drupal-selector="edit-reset"]');


      // create filter tags from view filter
      if ($filtersTagsDrupal.length) {

        // Create new HTML wrapper for filters
        $filtersTags = $('<div />', {
          class: cssClassFilters
        });
        $target.after($filtersTags);

        var $filtersTagsContainer = $('<div />', {
          class: cssClassFilters + '--container'
        });
        $filtersTags.append($filtersTagsContainer);

        // Duplicate legend
        var legendFilterTag = $('.fieldset-legend', $filtersTagsDrupal).text();
        if (legendFilterTag !== '' && typeof legendFilterTag !== 'undefined') {

          var $displayFiltersTitle = $('<label />', {
            class: cssClassFilters + '--title'
          }).html(legendFilterTag);
          $filtersTagsContainer.append($displayFiltersTitle);
        }

        $displayFiltersFieldset = $('<fieldset />', {
          class: cssClassFilters + '--fieldset'
        });
        $filtersTagsContainer.append($displayFiltersFieldset);

        // Duplicate options
        var $optionsFiltersTags = $('.form-checkboxes .form-item', $filtersTagsDrupal);

        $optionsFiltersTags.each(function () {

          var $option = $(this);
          var $label = $('.option', $option);
          var $labelText = $label.text();
          var $checkbox = $('.form-checkbox', $option);

          // Label
          var $filtersTagsLabel = $('<label />', {
            class: cssClassOption + '--label reversed',
            for: $label.attr('for')
          });
          $filtersTagsLabel.html($labelText);

          // Option
          var $filtersTagsOption = $('<input />', {
            type: 'checkbox',
            class: cssClassOption + '--option',
            name: $checkbox.attr('name'),
            id: $checkbox.attr('id'),
            value: $checkbox.val()
          });
          if ($checkbox.is(':checked')) {
            $filtersTagsOption.attr('checked', 'checked');
          }

          // Option on click
          $filtersTagsOption.on('click', function () {
            $checkbox.trigger('click');
          });

          $displayFiltersFieldset.append($filtersTagsOption);
          $displayFiltersFieldset.append($filtersTagsLabel);
        });
      }

      // create button toggle all
      // Label
      var $filtersTagsToggleAllLabel = $('<label />', {
        class: cssClassOption + '--label reversed tag-toggle-all',
        for: 'tag-toggle-all'
      });
      $filtersTagsToggleAllLabel.html(localSettings.all);

      // Option
      var $filtersTagsToggleAllOption = $('<input />', {
        type: 'checkbox',
        class: cssClassOption + '--option',
        name: 'tag-toggle-all',
        id: 'tag-toggle-all',
        value: 0
      });

      $filtersTagsToggleAllOption.on('change', function () {
        clearFiltersTags();
        if ($filtersTagsDrupal.length) {
          // force submit
          $('.form-checkboxes .form-item input', $filtersTagsDrupal).eq(0).trigger('change');
        }
      });

      var checkFiltersTags = function () {

        var $optionsFiltersTagsChecked = $('.' + cssClassOption + '--option:not(#tag-toggle-all):checked', $displayFiltersFieldset);
        var nbFiltersTagsChecked = $optionsFiltersTagsChecked.length;

        if (!nbFiltersTagsChecked) {
          $filtersTagsToggleAllOption.attr('checked', 'checked');
        }
        else {
          $filtersTagsToggleAllOption.removeAttr('checked');
        }
      };
      checkFiltersTags();

      var clearFiltersTags = function () {
        $filtersTagsToggleAllOption.attr('checked', 'checked');
        $('.' + cssClassOption + '--option:not(#tag-toggle-all):checked', $displayFiltersFieldset).removeAttr('checked');
        if ($filtersTagsDrupal.length) {
          $('.form-checkboxes .form-item input:checked', $filtersTagsDrupal).removeAttr('checked');
        }
      };

      if (!$filtersTagsDrupal.length) {

        // Option on change on front page only
        $('.' + cssClassOption + '--option:not(#tag-toggle-all)', $displayFiltersFieldset).on('change', function () {
          checkFiltersTags();
        });
      }

      $displayFiltersFieldset.prepend($filtersTagsToggleAllLabel);
      $displayFiltersFieldset.prepend($filtersTagsToggleAllOption);

      var $dropDown = $('<div>', {
        class: cssClassDropDown,
        html: '<div class="' + cssClassLayerOut + '"></div>' +
          '<div class="' + cssClassLayerContainer + '">' +
          '<button class="' + cssClassClose + '"></button>' +
          '<span class="' + cssClassMaskTop + '"></span>' +
          '<span class="' + cssClassMaskBottom + '"></span>' +
          '<div class="' + cssClassLayerContainerInner + '">' +
          '<div class="' + cssClassLayerContainerContent + '">' +
          '<span class="' + cssClassTracker + '"></span>' +
          '<ul class="' + cssClassList + '"></ul>' +
          '</div>' +
          '</div>' +
          '</div>'
      });

      var $reset = $('<button>', {
        class: cssClassReset,
        html: localSettings.clear_all,
        attr: {
          type: 'button'
        }
      });
      var $selects = $target.find('.needs-select');

      $target.append($reset);
      $target.append($dropDown);

      if ($resetBtnDrupal.length) {
        $reset.addClass('is-visible');
      }

      var $container = $target.find('.' + cssClassLayerContainer);
      var $containerInner = $target.find('.' + cssClassLayerContainerInner);
      var $containerContent = $target.find('.' + cssClassLayerContainerContent);
      var $maskTop = $target.find('.' + cssClassMaskTop);
      var $maskBottom = $target.find('.' + cssClassMaskBottom);
      var $list = $target.find('.' + cssClassList);
      var $close = $target.find('.' + cssClassClose);
      var $tracker = $target.find('.' + cssClassTracker);
      var trackerInitState = {
        top: $tracker.css('top'),
        height: $tracker.css('height'),
        opacity: $tracker.css('opacity'),
        marginTop: $tracker.css('margin-top')
      };

      var checkContentHeight = function () {
        var $list = $container.find('.' + cssClassList);

        if ($container.height() < $list.height()) {
          $container.addClass('has-scrollbar');
        }
        else {
          $container.removeClass('has-scrollbar');
        }
        $containerInner.trigger('scroll');
      };

      var placeTrackerOnActive = function ($active, opening) {

        if (typeof opening === 'undefined') {
          opening = false;
        }

        $tracker.css({
          top: $active.offset().top - $container.offset().top + $containerInner.scrollTop(),
          height: $active.height() - 5,
          opacity: 1,
          marginTop: 0
        });
        if (opening) {
          $containerInner.scrollTop($active.offset().top - $container.offset().top - ($container.height() - $active.height()) / 2);
        }
      };

      // check if value are field at the init
      // & set the value
      $selects.each(function () {
        var $selectDiv = $(this);
        var $select = $selectDiv.data('$select');
        var value = $select.val();
        var label = $select.find('option:selected').html();
        if (value !== '' && value !== 'All') {
          $reset.addClass('is-visible');
          $selectDiv.find('.needs-select--label').html(label).addClass('is-selected');
        }

        if ($select.find('option').length === 1) {
          $(this).addClass('disabled');
        }
      });
      // show target after build
      $target.css('visibility', 'visible');

      $selects.on('click', function () {
        var $selectDiv = $(this);
        var $select = $selectDiv.data('$select');
        $list.empty();
        $list.data('$selectDiv', $selectDiv);

        if ($select.find('option').length === 1) {
          return;
        }

        $('html').addClass(cssClassIsOpened);

        $select.find('option').each(function () {

          var value = typeof $(this).attr('value') !== 'undefined' ? $(this).attr('value') : $(this).html();

          if (value !== '' && value !== 'All') {
            $list.append('<li class="' + cssClassItem + ($select.val() === value ? ' is-selected is-active' : '') + '" data-value="' + value + '">' + $(this).html() + '</li>');
          }
        });

        checkContentHeight();

        if ($('.' + cssClassItem + '.is-selected').length) {
          setTimeout(function () { // avoid bug build by adding delay of 0
            var $selected = $('.' + cssClassItem + '.is-selected');
            placeTrackerOnActive($selected, true);
          }, 0);
        }
        else {
          $tracker.css(trackerInitState);
        }
      });

      // apply selected value on select
      $target.on('click', '.' + cssClassItem, function (event) {
        var $item = $(this);
        var $list = $item.closest('.' + cssClassList);
        var $selectDiv = $list.data('$selectDiv');
        var $select = $selectDiv.data('$select');
        var label = $item.html();
        var value = $item.data('value');
        $reset.addClass('is-visible');
        $selectDiv.find('.needs-select--label').html(label).addClass('is-selected');
        $select.val(value);
        // force active for touch screen
        $item.addClass('is-active').siblings().removeClass('is-active');
        var iDeltaTime = $('html').hasClass('touchevents') ? 300 : 0;

        clearFiltersTags();
        setTimeout(function () {
          $close.trigger('click');
        }, iDeltaTime);
        setTimeout(function () {
          $select.trigger('change');
        }, iDeltaTime + 500);
      });

      $target.on('click', '.' + cssClassLayerOut + ', .' + cssClassClose, function () {
        $tracker.css(trackerInitState);
        $('html').removeClass(cssClassIsOpened);
      });

      $reset.on('click', function (event) {

        if ($resetBtnDrupal.length) {
          $resetBtnDrupal.trigger('click');
          return false;
        }
        $reset.removeClass('is-visible');
        $selects.each(function () {
          var $selectDiv = $(this);
          var label = $selectDiv.data('label');
          $selectDiv.find('.needs-select--label').html(label).removeClass('is-selected');
          $selectDiv.data('$select').val('All');
          $selectDiv.data('$select').find('option').removeAttr('selected');
        });
        clearFiltersTags();
        $selects.eq(0).data('$select').trigger('change');
      });

      $container.on('mouseleave', function () {
        $(this).find('.is-active').removeClass('is-active');
        if ($('.' + cssClassItem + '.is-selected').length) {
          $('.' + cssClassItem + '.is-selected').addClass('is-active');
          placeTrackerOnActive($('.' + cssClassItem + '.is-selected'));
        }
        else {
          $tracker.css(trackerInitState);
        }
        $maskTop.removeClass('is-hover');
        $maskBottom.removeClass('is-hover');
      });

      $target.on('mouseenter', '.' + cssClassItem, function () {
        $(this).addClass('is-active').siblings().removeClass('is-active');
        placeTrackerOnActive($(this));
      });

      $container.on('mousemove', function (event) {
        var posY = event.pageY - $(this).offset().top;
        if (posY < $maskTop.height()) {
          $maskTop.addClass('is-hover');
        }
        else {
          $maskTop.removeClass('is-hover');
        }

        if (posY > $(this).height() - $maskBottom.height()) {
          $maskBottom.addClass('is-hover');
        }
        else {
          $maskBottom.removeClass('is-hover');
        }
      });

      $containerInner.on('scroll', function (event) {
        var height = $containerContent.outerHeight();
        var scrollTop = $(this).scrollTop();
        var scrollBottom = height - scrollTop - $(this).height();

        if (scrollTop === 0) {
          $maskTop.addClass('is-hidden');
        }
        else {
          $maskTop.removeClass('is-hidden');
        }
        if (scrollBottom === 0) {
          $maskBottom.addClass('is-hidden');
        }
        else {
          $maskBottom.removeClass('is-hidden');
        }
      });

      $(window).on('resize', function () {
        var $searchTool = $('.search-tool', context);
        var state = true;

        if ($('html').hasClass('touchevents') && $searchTool.hasClass('expanded')) {
          state = false;
        }

        if (state === true) {
          checkContentHeight();
        }
      });
    });
  };

  Drupal.behaviors.needsForm = {
    attach: needsForm
  };

})(jQuery);

var needsWallInstances = [];
(function ($) {

  var needsWall = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'needs-wall';
    var cssClassForm = 'needs-form';
    var cssClassDisplayPerPage = 'display-per-page';
    var $targets = $('.' + cssClass, context);

    if (!localStorage.getItem('BV-display-toggle-view')) {
      localStorage.setItem('BV-display-toggle-view', 'view-grid');
    }

    $targets.each(function (index) {
      var $target = $(this);
      var viewState = localStorage.getItem('BV-display-toggle-view');

      var changeView = function (viewState) {
        localStorage.setItem('BV-display-toggle-view', viewState);
        $target.removeClass('view-grid view-list').addClass(viewState);

        if (viewState === 'view-grid') {
          if (!$target.data('init-' + cssClass)) {

            $target.data('init-' + cssClass, true);

            // Build Wall of Content (Masonry) to display list
            needsWallInstances[index] = $target.wallOfContent({
              target: $target,
              wallContainerClass: cssClass + '--container',
              wallColClass: cssClass + '--col',
              blocksToOrder: '.teaser-offer',
              bypass: true,
              responsive: {
                640: {
                  bypass: false,
                  grid: 2
                },
                960: {
                  bypass: false,
                  grid: 4
                }
              }
            });
          }
          else {
            if (typeof needsWallInstances[index] !== 'undefined' && typeof needsWallInstances[index].reload === 'function') {
              needsWallInstances[index].reload();
            }
          }
        }
        else {
          if ($target.data('init-' + cssClass)) {
            $target.removeData('init-' + cssClass);
            needsWallInstances[index].destroy();
          }
        }
      };

      changeView(viewState);

      // Build header
      var $needsForm = $(' .' + cssClassForm, context);
      var $mapHeading = $('.vector-map', context);

      if ($needsForm.length || $mapHeading.length) {

        if ($target.data('init-form-' + cssClass)) {
          return true; // continue
        }
        $target.data('init-form' + cssClass, true);

        var $needsWallResults = $('.' + cssClass + '--results', context);
        var $needsWallItemsToDisplay = $('.' + cssClass + '--items-to-display', context);
        var $needsWallToggleView = $('.display-toggle-view', context);
        var $drupalItemToDisplay = $('[data-drupal-selector="edit-items-per-page"]', context);

        $('input', $needsWallToggleView).each(function () {
          if ($(this).val() === localStorage.getItem('BV-display-toggle-view')) {
            $(this).attr('checked', 'checked').siblings('input').removeAttr('checked');
          }
          $(this).on('change', function () {
            changeView($(this).val());
          });
        });

        if ($needsWallResults.length || $needsWallItemsToDisplay.length || $drupalItemToDisplay.length) {

          // Move results and items to display into header
          var $needsWallHeader = $('<div />', {
            class: cssClass + '--header container'
          });

          if ($needsWallResults.length) {
            $needsWallHeader.append($needsWallResults);
          }

          if ($needsWallItemsToDisplay.length) {
            $needsWallHeader.append($needsWallItemsToDisplay);
          }

          // Duplicate Drupal filter display per page
          if ($drupalItemToDisplay.length) {

            // Create new HTML wrapper for filters
            $needsWallItemsToDisplay = $('<div />', {
              class: cssClass + '--items-to-display'
            });
            var $displayPerPage = $('<div />', {
              class: cssClassDisplayPerPage
            });

            // Duplicate legend
            var $legend = $('.fieldset-legend', $drupalItemToDisplay).text();
            if ($legend !== '' && typeof $legend !== 'undefined') {

              var $displayPerPageTitle = $('<div />', {
                class: cssClassDisplayPerPage + '--title'
              }).html($legend);
              $displayPerPage.append($displayPerPageTitle);
            }

            // Duplicate options
            var $options = $('.form-radios .form-item-items-per-page', $drupalItemToDisplay);
            $options.each(function () {

              var $option = $(this);
              var $label = $('.option', $option);
              var $labelText = $label.text();
              var $radio = $('.form-radio', $option);

              // Label
              var $displayPerPageLabel = $('<label />', {
                class: cssClassDisplayPerPage + '--label',
                for: $label.attr('for')
              });
              $displayPerPageLabel.html($labelText);

              // Option
              var $displayPerPageOption = $('<input />', {
                type: 'radio',
                class: cssClassDisplayPerPage + '--option',
                name: $radio.attr('name'),
                id: $radio.attr('id'),
                value: $radio.val()
              });
              if ($radio.is(':checked')) {
                $displayPerPageOption.attr('checked', 'checked');
              }

              // Option on click
              $displayPerPageOption.click(function () {
                $radio.click();
                $displayPerPageOption.siblings('.' + cssClassDisplayPerPage + '--option:checked').removeAttr('checked');
              });

              $displayPerPage.append($displayPerPageOption);
              $displayPerPage.append($displayPerPageLabel);
            });

            // Add new HTML to Needs Wall component
            $needsWallItemsToDisplay.append($displayPerPage);
            $needsWallHeader.append($needsWallItemsToDisplay);
          }

          if ($needsWallToggleView.length === 1) {
            $needsWallItemsToDisplay.append($needsWallToggleView);
          }

          $target.before($needsWallHeader);
          $target.find('.' + cssClass + '--header').remove();
          $target.css('visibility', 'visible');
        }
      }
    });
  };

  Drupal.behaviors.needsWall = {
    attach: needsWall
  };

})(jQuery);

var $map;
(function ($) {

  var needsWallLocator = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'needs-wall';
    var cssClass2 = 'vector-map';
    var cssClassLocator = 'js-place-locator';
    var $targets = $('.' + cssClass + '.' + cssClassLocator, context);

    $targets.each(function (index) {
      var $target = $(this);
      var $mapHeading = $('.' + cssClass2, context);
      var mapDatas = [];

      // Get country field
      var $countryField = $('.' + cssClass2 + ' select', context);

      // Generic value for marker
      var markerPath = 'img/vector-map/';
      var markerWidth = 16;
      var markerHeight = 23;

      if (typeof drupalSettings !== 'undefined' && drupalSettings.path.themeBaseUrl.length) {
        markerPath = drupalSettings.path.themeBaseUrl + '/' + markerPath;
      }

      if (typeof drupalSettings !== 'undefined' && drupalSettings.poiLocations.length) {
        poiLocations = JSON.parse(drupalSettings.poiLocations);
      }
      poiLocations.forEach(function (location, i) {

        var latitude = parseFloat(location.latitude);
        var longitude = parseFloat(location.longitude);

        if (typeof latitude !== 'undefined' && typeof longitude !== 'undefined') {
          var contentHTML = '<span class="teaser-offer--close"></span>' + location.content;

          mapDatas.push({
            latitude: latitude,
            longitude: longitude,
            content: contentHTML,
            countryCode: location.countryCode,
            locationType: location.locationType,
            business: location.business,
            width: markerWidth,
            height: markerHeight
          });

          var iconName = 'map-marker';
          if (typeof location.locationType !== 'undefined' && location.locationType !== '') {
            iconName += '_' + location.locationType;
          }

          mapDatas[i].imageUrl = markerPath + iconName + '.svg';
        }
      });

      if (!$mapHeading.data('init-' + cssClass2)) {
        $mapHeading.data('init-' + cssClass2, true);

        // Create map
        var $layerMap = $('<div />', {
          id: 'layer-map',
          class: cssClass2 + '--map'
        });

        var $body = $('body');
        var $loader = $('<span />', {class: cssClass2 + '--loader'});
        var $ajaxLoader = $('<span />', {class: 'ajax-loader'});
        $loader.append($ajaxLoader);
        $body.append($loader);

        $mapHeading.append($layerMap);

        $('.fieldgroup', $mapHeading).each(function () {
          var $fieldgroup = $(this);
          var $trigger = $('.fieldset-legend', $fieldgroup);
          var $content = $('.fieldset-wrapper', $fieldgroup);
          $trigger.click(function () {
            $content.slideToggle(function () {
              $fieldgroup.toggleClass('collapsed');
            });
          });

          if ($fieldgroup.hasClass('expanded')) {
            $trigger.trigger('click');
          }
        });

        // Get geodata for map
        // Get active country list from drupal settings if exists
        if (typeof drupalSettings !== 'undefined' && drupalSettings.activeCountryList.length) {
          activeCountryList = drupalSettings.activeCountryList;
        }

        // Custom countries name
        var customCountriesName = activeCountryList;

        // Init am4chart
        $map = $target.vectorMap({
          licence: 'CH197293367',
          containerClass: 'layer-map',
          alignZoom: 'bottom',
          enableWheel: false,
          dataPoints: mapDatas,
          activeCountryList: activeCountryList,
          addCountryName: customCountriesName,
          onCountrySelection: function (country) {

            // Change value of select for country
            if ($countryField.length && $('option[value="' + country + '"]', $countryField).length) {
              $countryField.val(country).trigger('change');
            }
          },
          onComplete: function () {
            $loader.fadeOut('slow', function () {
              $mapHeading.css('visibility', 'visible');
              $body.css('overflow', 'auto');
              $(this).remove();
            });
            // Zoom on selected country
            $map.zoomToCountry($countryField.val());
          }
        });
      }
      else {
        $map.updateMarkers(mapDatas);
        $map.zoomToCountry($countryField.val());
      }
    });
  };

  Drupal.behaviors.needsWallLocator = {
    attach: needsWallLocator
  };

})(jQuery);

var newsWallInstances = [];
(function ($) {

  var newsWall = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'news-wall';
    var cssClassFilters = 'content-filters';
    var cssClassDisplayPerPage = 'display-per-page';
    var $targets = $('.' + cssClass, context);

    if (!localStorage.getItem('BV-display-toggle-view')) {
      localStorage.setItem('BV-display-toggle-view', 'view-grid');
    }

    $targets.each(function (index) {
      var $target = $(this);
      var viewState = localStorage.getItem('BV-display-toggle-view');

      var changeView = function (viewState) {
        localStorage.setItem('BV-display-toggle-view', viewState);
        $target.removeClass('view-grid view-list').addClass(viewState);

        if (viewState === 'view-grid') {
          if (!$target.data('init-' + cssClass)) {

            $target.data('init-' + cssClass, true);

            // Build Wall of Content (Masonry) to display list
            newsWallInstances[index] = $target.wallOfContent({
              target: $target,
              wallContainerClass: cssClass + '--container',
              wallColClass: cssClass + '--col',
              blocksToOrder: '.teaser-light',
              bypass: true,
              responsive: {
                640: {
                  bypass: false,
                  grid: 2
                },
                960: {
                  bypass: false,
                  grid: 4
                }
              }
            });
          }
          else {
            if (typeof newsWallInstances[index] !== 'undefined' && typeof newsWallInstances[index].reload === 'function') {
              newsWallInstances[index].reload();
            }
          }
        }
        else {
          if ($target.data('init-' + cssClass)) {
            $target.removeData('init-' + cssClass);
            newsWallInstances[index].destroy();
          }
        }
      };

      changeView(viewState);

      // Build header
      var $contentFilters = $(' .' + cssClassFilters, context);

      if ($contentFilters.length) {

        if ($contentFilters.data('init-' + cssClass)) {
          return true; // continue
        }
        $contentFilters.data('init-' + cssClass, true);

        var $newsWallToggleView = $('.display-toggle-view', context);
        var $drupalItemToDisplay = $('[data-drupal-selector="edit-items-per-page"]', context);

        $('input', $newsWallToggleView).each(function () {
          if ($(this).val() === localStorage.getItem('BV-display-toggle-view')) {
            $(this).attr('checked', 'checked').siblings('input').removeAttr('checked');
          }
          $(this).on('change', function () {
            changeView($(this).val());
          });
        });

        if ($drupalItemToDisplay.length) {

          // Move items to display into header
          var $newsWallHeader = $('<div />', {
            class: cssClass + '--header container'
          });

          // Duplicate Drupal filter display per page

          var $displayPerPage = $('<div />', {
            class: cssClassDisplayPerPage
          });

          // Duplicate legend
          var $legend = $('.fieldset-legend', $drupalItemToDisplay).text();
          if ($legend !== '' && typeof $legend !== 'undefined') {

            var $displayPerPageTitle = $('<div />', {
              class: cssClassDisplayPerPage + '--title'
            }).html($legend);
            $displayPerPage.append($displayPerPageTitle);
          }

          // Duplicate options
          var $options = $('.form-radios .form-item-items-per-page', $drupalItemToDisplay);
          $options.each(function () {

            var $option = $(this);
            var $label = $('.option', $option);
            var $labelText = $label.text();
            var $radio = $('.form-radio', $option);

            // Label
            var $displayPerPageLabel = $('<label />', {
              class: cssClassDisplayPerPage + '--label',
              for: $label.attr('for')
            });
            $displayPerPageLabel.html($labelText);

            // Option
            var $displayPerPageOption = $('<input />', {
              type: 'radio',
              class: cssClassDisplayPerPage + '--option',
              name: $radio.attr('name'),
              id: $radio.attr('id'),
              value: $radio.val()
            });
            if ($radio.is(':checked')) {
              $displayPerPageOption.attr('checked', 'checked');
            }

            // Option on click
            $displayPerPageOption.click(function () {
              $radio.click();
              $displayPerPageOption.siblings('.' + cssClassDisplayPerPage + '--option:checked').removeAttr('checked');
            });

            $displayPerPage.append($displayPerPageOption);
            $displayPerPage.append($displayPerPageLabel);
          });

          // Add new HTML to Needs Wall component
          $newsWallHeader.append($displayPerPage);

          if ($newsWallToggleView.length === 1) {
            $newsWallHeader.append($newsWallToggleView);
          }

          $drupalItemToDisplay.hide();
          $target.before($newsWallHeader);
          $target.find('.' + cssClass + '--header').remove();
        }

        $target.css('visibility', 'visible');
      }
    });
  };

  Drupal.behaviors.newsWall = {
    attach: newsWall
  };

})(jQuery);

(function ($) {

  var newsRoomForm = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var $targets = $('select[data-drupal-selector="edit-tag"]', context);

    $targets.each(function () {

      var $target = $(this);

      if ($target.data('init-newsroom-form')) {
        return true; // continue
      }
      $target.data('init-newsroom-form', true);

      // Get options of native select
      var $tags = $('option:not([value=All])', $target);

      // Get page heading
      var cssClass = 'page-heading';
      var $pageHeading = $('.' + cssClass + '.alternative-select', 'body');

      if ($pageHeading.length && $tags.length) {

        // Hide select for view-filters
        $target.parent('.form-item').hide();

        // Get default option
        var defaultOption = $('option:first-child', $target);
        var defaultLabel = Drupal.t('All markets');
        if ($target.siblings('label').length) {
          defaultLabel = $target.siblings('label').text();
        }

        // Create clear all button
        var $pageHeadingContent = $('.' + cssClass + '--content', $pageHeading);
        var $clearBtn;
        if (!$pageHeading.find('.' + cssClass + '--reset').length) {
          $clearBtn = $('<div />', {
            class: cssClass + '--reset is-visible'
          });
          $clearBtn.text(Drupal.t('clear all'));
          $pageHeadingContent.after($clearBtn);
        }
        else {
          $clearBtn = $pageHeading.find('.' + cssClass + '--reset');
          $clearBtn.addClass('is-visible');
        }

        $clearBtn.on('click', function () {
          defaultOption.prop('selected', true);
          $target.trigger('change');
        });

        // Get selected value
        var currentValue = $('option:selected', $target).text();
        if (currentValue === 'undefined' || currentValue === '' || currentValue === defaultOption.text()) {

          // Add default value to current value
          currentValue = defaultLabel;

          // Hide clear button
          $clearBtn.removeClass('is-visible');
        }

        // Create select from view filter
        var cssSelect = 'simple-sentence-select';
        var selectTagName = $target.attr('name');
        var $newSelect = $('#' + cssSelect + '-' + selectTagName, $pageHeading);
        $newSelect.empty();
        $newSelect.addClass(cssSelect);
        var $newSelectInner = $('<span />', {
          class: cssSelect + '--inner'
        });
        var $newSelectLabel = $('<span />', {
          class: cssSelect + '--label'
        });
        $newSelectLabel.text(currentValue);
        $newSelectInner.append($newSelectLabel);
        $newSelect.append($newSelectInner);

        // Create dropDownLayer (red side pannel) and attach event on new select
        var dropDownTags = $target.dropDownLayer({
          cssClass: cssClass,
          target: $('body'),
          options: $tags
        });
        $newSelect.css('cursor', 'pointer');
        $newSelect.on('click', dropDownTags.open);

        // Update dropDownLayer if option is already selected
        if (currentValue !== defaultLabel) {
          dropDownTags.updateReferer($('option:selected', $target).val());
        }
      }
    });
  };

  Drupal.behaviors.newsRoomForm = {
    attach: newsRoomForm
  };

})(jQuery);

// video intro history


(function ($) {

  var pageHistoryIntro = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'page-history-intro';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {

      var $target = $(this);
      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        $('.page-history-list').addClass('is-hidden');
        // if ie11
        var isIE11 = !!window.MSInputMethodContext && !!document.documentMode;
        if (!isIE11) {
          $('.site-footer').remove();
        }

        var $cover = $target.find('.page-hat');
        var $flaps = createFlaps($target);

        var $loader = $('<span>').addClass('ajax-loader').appendTo($target);
        $cover.css('visibility', 'visible');
        $target.css('background', 'transparent'); // hide bg when ready


        var bVideoDisplayed = false;
        var displayIntro = function () {
          if (bVideoDisplayed) {
            return false;
          }
          bVideoDisplayed = true;
          animFlaps($flaps, 'first');
          $loader.fadeOut();
        };

        var bIntroSkipped = false;
        var displayHistory = function () {
          if (bIntroSkipped) {
            // history already launch
            return false;
          }
          bIntroSkipped = true;

          animFlaps($flaps);
          setTimeout(function () {
            $cover.hide();
            pageHistoryListe();
            $('.page-history-list').removeClass('is-hidden').css('visibility', 'visible');
            setTimeout(function () {
              $target.remove();
            }, 500);
          }, 500);
        };

        // if there is no video
        // or
        // if we are on iOs
        // because on iOS because autoplay is disabled
        if (Modernizr.ios || !$('video', $cover).length) {
          // display bg picture
          displayIntro();

          // if ios we remove <video≥ to avoid conflict
          if ($('video', $cover).length) {
            $('video', $cover).remove();
          }
        }
        else {
          if ($('video', $cover)[0].readyState > 3) {
            displayIntro();
          }
          else {
            $('video', $cover).on('canplay', function () {
              displayIntro();
            });
          }

          if (Modernizr.ie || Modernizr.edge) {
            setTimeout(function () { // security for edge and ie if event doesn't trigger
              displayIntro();
            }, 2000);
          }

          $('video', $cover).on('ended', function () {
            displayHistory();
          });
        }

        $('.link-std', $cover).on('click', function (e) {
          e.stopPropagation();
          e.preventDefault();
          // skip intro
          displayHistory();
        });
      }
    });
  };

  Drupal.behaviors.pageHistoryIntro = {
    attach: pageHistoryIntro
  };

})(jQuery);

// Scroll steps two side / 1 side reversed scroll
var pageHistoryListe;

(function ($) {

  pageHistoryListe = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'page-history-list';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {

      var $target = $(this);
      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        // Variables

        // if ie11
        var isIE11 = !!window.MSInputMethodContext && !!document.documentMode;
        var $items = $target.find('.' + cssClass + '--item');
        var $itemsPast = $target.find('.' + cssClass + '--slide-past');
        var $itemsPresent = $target.find('.' + cssClass + '--slide-present');
        if (isIE11) {
          $('.no-touchevents').find($target).on('mousemove', function (e) {
            if (e.pageX < $(window).width() * .4) {
              $items.attr({'active-bg': 'left'});
            }
            else if (e.pageX > $(window).width() * .6) {
              $items.attr({'active-bg': 'right'});
            }
            else {
              $items.attr({'active-bg': ''});
            }
          });
        }
        else {
          // create revers scroll structure
          $target.append('<input type="hidden" value="none" id="activeslide">\n' +
            '<div id="down" class="mouse-icon"><div class="wheel"></div></div>' +
            '<ul class="' + cssClass + '--scene">\n' +
            '        <li class="' + cssClass + '--layer ' + cssClass + '--layer-left">\n' +
            '            <div class="' + cssClass + '--cont-inner"></div>\n' +
            '        </li>\n' +
            '        <li class="' + cssClass + '--layer ' + cssClass + '--layer-right">\n' +
            '            <div class="' + cssClass + '--cont-inner"></div>\n' +
            '        </li>\n' +
            '    </ul>\n' +
            '    <aside class="' + cssClass + '--panel"></aside>');


          // Automatically generates btn dates
          $('.' + cssClass + '--slide-past .' + cssClass + '--date').each(function () {
            $('.' + cssClass + '--panel').append('<span class="panel-btn"><i></i><em>' + $(this).html() + '</em></span>');
          });
          $('.' + cssClass + '--panel').append('<span class="panel-handle"></span>');

          // move past elements in left col
          $target.find('.' + cssClass + '--slide-past').each(function () {
            $(this).prependTo($('.' + cssClass + '--layer-left .' + cssClass + '--cont-inner'));
          });
          // move present elements in right col
          $target.find('.' + cssClass + '--slide-present').each(function () {
            $(this).appendTo($('.' + cssClass + '--layer-right .' + cssClass + '--cont-inner'));
          });

          // autoplay play video if existing
          $target.find('video').each(function () {
            this.play();
          });

          // remove original structure
          $items.remove();
          var windowHeight = $(window).height();
          var bgHeight = windowHeight - $('.site-heading').height();
          var slideCnt = $('.' + cssClass + '--layer-right .' + cssClass + '--slide').length;
          var isMoving = false;
          var UP = 38;
          var DOWN = 40;
          var TimeScroll = false;
          var active = 0;

          var $scene = $(this).find('.' + cssClass + '--scene');
          var content = '.' + cssClass + '--content';

          var getKey = function (e) {
            if (window.event) {
              return e.keyCode;
            } // IE
            else if (e.which) {
              return e.which;
            } // Netscape/Firefox/Opera
          };

          var activeSlide = function (direction, i, userAction) {
            if (typeof userAction === 'undefined') {
              userAction = true;
            }
            // Divide the top position to each slide height and get slide number
            // debugger
            if (direction === 1 && userAction) {
              active += i;
            }
            else if (direction === -1 && active > 0 && userAction) {
              active -= i;
            }
            else if (!userAction) {
              active = parseInt(i);
            }

            $('#down').fadeIn();
            $('.' + cssClass + '--layer-right .' + cssClass + '--slide, .' + cssClass + '--panel .panel-btn').removeClass('active');
            $('.' + cssClass + '--layer-right .' + cssClass + '--slide').eq(active).addClass('active');
            $('.' + cssClass + '--panel .panel-btn').eq(active).addClass('active');

            $('.' + cssClass + '--panel .panel-handle').css({
              top: $('.' + cssClass + '--panel .panel-btn').eq(active).offset().top - $('.' + cssClass + '--panel').offset().top
            });

            if (active + 1 === slideCnt) {
              $('#down').addClass('mouse-icon-up');
            }
            else {
              $('#down').removeClass('mouse-icon-up');
            }

            return false;
          };

          var scroller = function (i, direction) {
            // Allow only real directions min-max
            if (direction === 1 && slideCnt === active + 1 || (direction === -1 && active < 1)) {
              // do nothing
            }
            else {
              $(content).removeClass('animated');
              $scene.attr({'active-bg': ''});
              $('body').removeClass('cursor');
              $('.' + cssClass + '--layer-right').velocity({
                translateX: 0,
                translateZ: 0
              }, {
                queue: false,
                easing: [0.10, 0.90, 0.9, 1],
                duration: 900
              });
              $('.' + cssClass + '--layer-right .' + cssClass + '--slide').velocity({
                translateX: 0,
                translateZ: 0
              }, {
                queue: false,
                easing: [0.10, 0.90, 0.9, 1],
                duration: 900
              });
              $('.' + cssClass + '--layer-right .' + cssClass + '--cont-inner').css({
                transform: 'translate3d(0px,' + ((-1 * (bgHeight * active)) - (bgHeight * i * direction)) + 'px,0px)'
              });
              $('.' + cssClass + '--layer-left .' + cssClass + '--cont-inner').css({
                transform: 'translate3d(0px,' + ((-1 * (bgHeight * (slideCnt - active)) + bgHeight) + (bgHeight * i * direction)) + 'px,0px)'
              });
              activeSlide(direction, i);
              clearTimeout(TimeScroll);
              TimeScroll = setTimeout(function () {
                $('#down').fadeOut();
              }, 3000);
            }
          };

          var responsive = function () {
            windowHeight = $(window).height();
            bgHeight = windowHeight - $('.site-heading').height();

            // GENERAL
            $('.' + cssClass + '--layer, .' + cssClass + '--slide, .' + cssClass + '--scene').height(bgHeight);

            // force the height in attr html to avoid conflict with drupal js
            // code (need more investigation to find out)
            $('.' + cssClass + '--slide').attr('style', 'height: ' + bgHeight + 'px;');

            // mousewheelable area
            $('.' + cssClass + '--cont-inner').height(slideCnt * bgHeight);

            // resize on heightchange
            $('.' + cssClass + '--layer-left .' + cssClass + '--cont-inner').css({
              transform: 'translate3d(0px,-' + (bgHeight * (slideCnt - active) - bgHeight) + 'px,0px)'
            });
            $('.' + cssClass + '--layer-right .' + cssClass + '--cont-inner').css({
              transform: 'translate3d(0px,-' + (bgHeight * active) + 'px,0px)'
            });
            $itemsPast.each(function (key, item) {
              var $contentPast = $(this).find('.' + cssClass + '--content');
              var $contentPresent = $itemsPresent.eq(key).find('.' + cssClass + '--content');
              var delta = ($contentPast.height() - $contentPresent.height()) / 2;
              if (delta < 0) {
                $contentPast.css('marginTop', delta);
                $contentPresent.css('marginTop', 0);
              }
              else {
                $contentPast.css('marginTop', 0);
                $contentPresent.css('marginTop', -delta);
              }
            });
          };

          var firstLoad = function () {
            responsive();
            if ($('#activeslide').val() !== 'none') {
              activeSlide(1, $('#activeslide').val(), false);
            }
            else {
              activeSlide();
            }
          };

          var event = function (e) {
            var p1;
            if (e.type === 'mousedown' || e.type === 'mousemove') {
              p1 = {
                y: e.pageY,
                x: e.pageX
              };
            }
            else if (e.originalEvent.touches) {
              p1 = {
                y: e.originalEvent.touches[0].pageY,
                x: e.originalEvent.touches[0].pageX
              };
            }
            return p1;
          };

          setTimeout(function () {
            $('#intro').fadeOut();
          }, 3000);
          var y1;
          var y2;
          var x;
          var dragging = false;

          firstLoad();

          $scene.on('mousedown touchstart', function (e) {
            dragging = false;
            e.preventDefault();
            $('body').addClass('cursor');
            var p1 = event(e);
            y1 = p1.y;
            x = p1.x;
            $(this).on('mousemove touchmove', function (e) {
              var p1 = event(e);
              y2 = p1.y;

              if (y1 - y2 < 10 && y1 - y2 > -10) {
                dragging = false;
              }
              else {
                dragging = true;
              }
              if ((y1 - y2 < 0 && active === 0) || (y1 - y2 > 1 && slideCnt <= active + 1)) {
                // do nothing
              }
              else if (dragging === true) {
                $('.' + cssClass + '--layer-left .' + cssClass + '--cont-inner').css({
                  transform: 'translate3d(0px,' + (-1 * (bgHeight * (slideCnt - active)) + ((bgHeight + y1 - y2))) + 'px,0px)'
                });

                $('.' + cssClass + '--layer-right .' + cssClass + '--cont-inner').css({
                  transform: 'translate3d(0px,' + (-1 * (bgHeight * active) - ((y1 - y2))) + 'px,0px)'
                });
              }

              y2 = p1.y;
              $(this).data('p0', p1);
            });
          }).on('contextmenu mouseup touchend', function (e) {
            $('body').removeClass('cursor');
            if (dragging === false && $('html').hasClass('touchevents')) {
              $(content).removeClass('animated');
              $scene.attr({'active-bg': ''});
              if (x <= $(window).width() / 2) {
                $scene.attr({'active-bg': 'left'});
                $('.' + cssClass + '--layer-left').find(content).addClass('animated');
              }
              else {
                $scene.attr({'active-bg': 'right'});
                $('.' + cssClass + '--layer-right').find(content).addClass('animated');
              }
            }
            else {
              if (y1 - y2 > bgHeight / 4 && y1 > y2) {
                scroller(1, 1);
              }
              else if (y2 - y1 > bgHeight / 4 && y2 > y1) {
                scroller(1, -1);
              }
              scroller(1, 0);
            }

            $(this).off('mousemove');
            $(this).off('touchmove');
            $(this).off('touch');

          });


          $('.no-touchevents').find($target).on('mousemove', function (e) {
            if (!$('body').hasClass('cursor')) {

              if (e.pageX > $(window).width() * .1 && e.pageX < $(window).width() * .4) {
                $scene.attr({'active-bg': 'left'});
              }
              else if (e.pageX > $(window).width() * .6) {
                $scene.attr({'active-bg': 'right'});
              }
              else {
                $scene.attr({'active-bg': ''});
              }
            }
          });


          $('.no-touchable').bind('scroll mousewheel DOMMouseScroll MozMousePixelScroll', function (e) {
            e.preventDefault();
            if (isMoving) {
              return;
            }
            isMoving = true;
            if (e.originalEvent.detail > 0 || e.originalEvent.wheelDelta < 0) {
              scroller(1, 1);
            }
            else {
              scroller(1, -1);
            }
            setTimeout(function () {
              isMoving = false;
            }, 2000);
          });

          $('.mouse-icon').on('click', function () {
            scroller(1, 1);
          });

          $(document).on('click mousedown', '.mouse-icon-up', function () {
            scroller(1, -1);
          });

          $('.' + cssClass + '--panel .panel-btn').on('click mousedown touchend', function () {
            var steps = $(this).index() - active;
            if (steps > 0) {
              scroller(steps, 1);
            }
            else if (steps < 0) {
              scroller(Math.abs(steps), -1);
            }
            else {
              return false;
            }
          });

          $('.' + cssClass + '--cont-inner').css('transition', 'transform 0.8s');

          $(window).resize(function () {
            responsive();
          });

          $(window).keyup(function (e) {
            var keynum = getKey(e);
            if (keynum === UP) {
              scroller(1, -1);
            }
            if (keynum === DOWN) {
              scroller(1, 1);
            }
          });
        }
      }
    });
  };

})(jQuery);

// Page Intro

(function ($) {

  var pageIntro = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'page-intro';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);

      // SCROLL
      // Add scroll bottom
      var $scroll = $('.' + cssClass + '--scroll-bottom');
      if (!$scroll.length) {
        $scroll = $('<span />', {
          class: cssClass + '--scroll-bottom'
        });
        $target.append($scroll);
      }

      $scroll.click(function () {
        $('html,body').animate({
          scrollTop: $target.next().offset().top
        }, 'slow');
      });

      // COVER ANIMATION
      // Get slider

      var $list = $('.' + cssClass + '--list', $target);
      var $cover = $list.prev();
      var $video = $('video', $cover);

      // Add skip intro button
      if ($video.length) {

        var coverClass = $cover.attr('class');
        var cssClass2 = coverClass.split(' ');
        var $skipIntroButton = $('<div />', {
          class: cssClass2[0] + '--action'
        });
        $skipIntroButton.append('<span class="link-std">' + Drupal.t('Skip intro ') + '</span>');
        $skipIntroButton.on('click', function () {
          animSliderDisplay();
        });
        $cover.append($skipIntroButton);
      }

      // Get video and picture
      if ($list.length) {

        // Init loader and animation
        $list.css({
          opacity: 0
        });

        var $flaps = createFlaps($target);
        var $loader = $('<span>').addClass('ajax-loader').appendTo($target);

        // Init slider
        var $slider = $('ul:first', $list);
        var isInitSlider = false;
        var displaySlider = function () {

          if ($slider.length && !isInitSlider) {

            // Hide cover
            if ($cover.length && $cover.is(':visible')) {
              $cover.hide();
            }

            // Init slider
            $slider.responsiveSlider({
              sliderRange: 1,
              mode: 'fade',
              duration: 0,
              delay: 700,
              fitSlides: true,
              autoPlay: true,
              adaptativeHeight: false,
              onBeforeSlide: function () {
                animFlaps($flaps);
              },
              pager: function (_self, $prev, $next, $dotsHolder) {
                _self.after($dotsHolder);
              },
              responsive: {
                640: {
                  pager: function (_self, $prev, $next) {
                    $list.prepend($prev);
                    $list.append($next);
                  }
                }
              }
            });

            isInitSlider = true;

            // Display scroll
            $scroll.fadeIn('slow');
          }
        };

        // Launch slider with delay
        var animSliderDisplay = function (delay) {

          if (typeof delay !== 'number') {
            delay = 500;
          }

          setTimeout(function () {

            if ($cover.length || $video.length) {
              animFlaps($flaps);

              // Display list and launch slider
              $list.css('visibility', 'visible');
              $list.delay(200).animate({
                opacity: 1
              }, function () {
                displaySlider();
              });
            }
            else {
              $list.css('visibility', 'visible');
              $list.css('opacity', 1);
              displaySlider();
            }
          }, delay);
        };

        // Get video or picture cover
        if ($cover.length) {
          var $coverVideo = $('video', $cover);

          // Display cover and anim flaps
          $cover.css('visibility', 'visible');
          $loader.fadeOut('slow', function () {
            animFlaps($flaps, 'first');
          });

          if ($coverVideo.length) {

            // If ios we remove <video≥ to avoid conflict
            if (Modernizr.ios) {
              $coverVideo.remove();
              displaySlider();
            }

            // When video is ready to play
            if ($coverVideo[0].readyState === 4) {

              // Exception for IE, add some delay before displaying
              if (Modernizr.ie || Modernizr.edge) {
                setTimeout(function () { // security for edge and ie if event doesn't trigger
                  $list.css({
                    'opacity': 1,
                    'visibility': 'visible'
                  });
                }, 2000);
              }
            }

            // Launch slider on video ending
            $coverVideo.on('ended', animSliderDisplay);
          }
          else {
            animSliderDisplay(7000);
          }
        }
        else {

          // Anim list display
          $loader.fadeOut(750, function () {
            animFlaps($flaps, 'first');
            animSliderDisplay();
          });
        }
      }
    });
  };

  Drupal.behaviors.pageIntro = {
    attach: pageIntro
  };

})(jQuery);

// Animation Scroll Presentation

(function ($) {


  var pageLandingHeading = function (context, options) {

    var vw = $(window).width();
    if (vw < 640) { // no paralax effect on mobile
      return false;
    }

    if (typeof context === 'undefined') {
      context = document;
    }
    // set animated-scroll-debug=true in the store locator to enabled debug mode

    var _self = this;

    _self.settings = {
      itemClass: 'page-landing-heading',
      bAnimatedScrollDebug: false
    };


    _self.settings.itemTarget = '.' + _self.settings.itemClass;
    _self.settings.$item = $(_self.settings.itemTarget);

    if (!_self.settings.$item.length) {
      return false;
    }

    // initialize the plugin, pass in the class selector for the sections of
    // content (blocks)
    var scrollorama = $.scrollorama({
      enablePin: false, // avoid absolute position af container
      blocks: _self.settings.$item
    });

    // animate some examples
    if ($(_self.settings.itemTarget + '--picture-first').length) {
      scrollorama
        .animate(_self.settings.itemTarget + '--picture-first', {
          duration: 500,
          property: 'left',
          end: -1.5 * $(_self.settings.itemTarget + '--picture-first').width()
        });
    }
    if ($(_self.settings.itemTarget + '--content').length) {
      scrollorama
        .animate(_self.settings.itemTarget + '--content', {
          duration: 500,
          property: 'top',
          end: 200
        });
    }
    if ($(_self.settings.itemTarget + '--picture-second').length) {
      scrollorama
        .animate(_self.settings.itemTarget + '--picture-second', {
          duration: 500,
          property: 'top',
          end: 150
        });
    }
    if ($(_self.settings.itemTarget + '--picture-third').length) {
      scrollorama
        .animate(_self.settings.itemTarget + '--picture-third', {
          duration: 500,
          property: 'bottom',
          end: 400
        });
    }

  };

  Drupal.behaviors.pageLandingHeading = {
    attach: pageLandingHeading
  };

})(jQuery);

(function ($) {


    var surveyAddress = function (context, settings) {
        if (typeof context === 'undefined') {
            context = document;
        }

        var classPopinAddress = 'popin-survey-address';
        var classPopinContact = 'popin-survey-contact';
        var $popinSurveyAddress = $('.open-' + classPopinAddress);
        var $popinSurveyContact = $('.open-' + classPopinContact);
        var $body = $('body');

        var initGb = function () {

            var greyboxOption = {
                onBeforeOpen: function () {
                    $body.addClass('prevent-scroll');
                },
                onBeforeClose: function () {
                    $body.removeClass('prevent-scroll');
                }
            };

            $popinSurveyAddress.on('click', function () {
                var gb = new Greybox(greyboxOption);
                var $titleAddress   = $('.' + classPopinAddress + '--title').html()
                var $contentAddress = $('.' + classPopinAddress + '--content-wrapper').html();

                gb.setTitle($titleAddress);
                gb.html($contentAddress);
                return false;
            });
            $popinSurveyContact.on('click', function () {
                var gb = new Greybox(greyboxOption);
                var $titleContact   = $('.' + classPopinContact + '--title').html()
                var $contentContact = $('.' + classPopinContact + '--content-wrapper').html();

                gb.setTitle($titleContact);
                gb.html($contentContact);
                return false;
            });
        };

        // Init
        initGb();
        $(window).bind('resize', initGb);
    };

    Drupal.behaviors.surveyAddress = {
        attach: surveyAddress
    };

})(jQuery);

// Condition for quick access item

(function ($) {

  var quickAccess = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'quick-access';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);

      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var $ul = $('.' + cssClass + '--list', $target);
        var $lis = $('li', $ul);
        $lis.each(function () {
          var $li = $(this);
          var $link = $('.link-std', $li);
          var $cta = $('.teaser-img', $li);

          if ($link.length === 0 || $cta.length === 0) {
            $li.remove();
          }

          var cssClass2 = 'teaser-img';
          var $targetContentInner = $('<div>', {
            class: cssClass2 + '--content-inner'
          });
          var $targetContent = $('.' + cssClass2 + '--content', $cta);
          var $targetAction = $('.' + cssClass2 + '--action', $cta);
          $targetContent.wrapInner($targetContentInner);
          $targetContentInner = $('.' + cssClass2 + '--content-inner', $cta);
          $targetContent.append($targetAction);

          var truncateContent = function () {
            $targetContentInner.removeAttr('style');

            if ($targetContentInner.data('dotdotdot') !== null && $targetContentInner.destroy === 'function') {
              $targetContentInner.destroy();
            }
            setTimeout(function () {
              $targetContentInner.dotdotdot();
              $targetContentInner.css('visibility', 'visible');
            }, 200);
          };

          truncateContent();
          $(window).resize(truncateContent);
        });
      }
    });
  };

  Drupal.behaviors.quickAccess = {
    attach: quickAccess
  };

})(jQuery);

// Slider Gallery Section

(function ($) {

  var sliderGallery = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'section-gallery';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);

      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var $container = $('.' + cssClass + '--slider', context);
        var $list = $('.' + cssClass + '--list', $target);
        $list.responsiveSlider({
          adaptativeHeight: true,
          sliderRange: 1,
          mode: 'flex',
          fitSlides: false,
          pager: function (_self, $prev, $next) {
            $container.prepend($prev);
            $container.append($next);
          },
          responsive: {
            640: {
              sliderRange: 2
            },
            960: {
              bypass: true
            }
          }
        });
      }
    });
  };

  Drupal.behaviors.sliderGallery = {
    attach: sliderGallery
  };

})(jQuery);

// Create Sticky Nav & Burger Menu


(function ($) {

  var siteHeader = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'site-header';
    var $targets = $('.' + cssClass, context);

    if (!$targets.length) {
      $('.page-wrapper', context).css('margin-top', 'auto');
    }

    $targets.each(function () {
      var $target = $(this);
      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var $header = $(this);
        var $hightlights = $('.heading-highlights', $header);
        var $heading = $('.site-heading', $header);
        var $window = $(window);
        var $tools = $('.heading-highlights--tools', $hightlights);
        var $brand = $('.heading-highlights--brand', $hightlights);
        var $siteLogo = $('.site-logo', $heading);
        var $extraLogo = $('.extra-logo', $heading);
        var $body = $('body');
        var $mainMenu = $('.main-menu', $header);

        var navPosition = function () {
          var widthTools = 0;
          $tools.removeAttr('style');

          if (getViewportWidth() >= 1050) {
            $('> *', $tools).each(function () {
              var $item = $(this);
              if ($item.attr('class').split(' ')[0] !== 'share-price' && $item.attr('id') !== 'block-stocksblock') {
                widthTools += $item.innerWidth();
              }
            });

            $header.attr('style', '--margin-secondary-menu:' + widthTools + 'px');
          }
        };

        if (!$body.hasClass('path-frontpage')) {
          $header.addClass('sticky');
          $heading.append($tools.detach());
          $siteLogo.prepend($brand.clone());
        }

        if ($mainMenu.length > 1) {
          $header.addClass('js-nav');
          $window.resize(function () {
            navPosition();
            $header.css('visibility', 'visible');
          });
          $window.on('load', function () {
            navPosition();
          });
        }

        $window.on('load', function () {
          $header.css('visibility', 'visible');
        });

        $window.scroll(function () {
          var $this = $(this);

          if (!$header.hasClass('sticky')) {
            $header.addClass('sticky');
            $heading.append($tools.detach());
            $siteLogo.prepend($brand.clone());
          }

          if ($this.scrollTop() === 0 && $body.hasClass('path-frontpage')) {
            $header.removeClass('sticky');
            var $cloneTools = $('.heading-highlights--tools', $heading).detach();
            var $brandLogo = $('.heading-highlights--brand', $heading);
            $hightlights.append($cloneTools);
            $brandLogo.remove();
          }

          // Hide extra logo on scroll
          if($extraLogo.length) {

            if($this.scrollTop() > 50) {

              if (!$extraLogo.hasClass('hidden')) {
                $extraLogo.addClass('hidden');
              }
            }
            else {
              $extraLogo.removeClass('hidden');
            }
          }
        });

        var $menu = new BurgerMenu({
          trigger: function (trigger) {
            $header.prepend(trigger);
          },
          structure: {
            fixed: '',
            scrollable: '.main-menu, .js-place-to-burger'
          },
          side: 'left',
          duration: _duration,
          easing: 'easeInQuint',
          onBeforeOpen: function (self) {

            $.each(self.structure, function (key, element) {


              if (key === 'fixed') {
                var $close = $('<div />', {
                  class: 'burger-menu--close'
                });
                $close.click(self.close);
                var $cloneSharePrice = $('.share-price', $tools).clone();

                var $container = $('<div />', {
                  class: 'burger-menu--fixed--content'
                }).prepend(
                  $cloneSharePrice
                ).append(
                  $close
                );

                element.container.prepend(
                  $container
                );
              }

              if (key === 'scrollable') {

                var $nav = $('.main-menu > ul', element.container);
                var cfg = {
                  group: '> li',
                  trigger: '> span',
                  section: '.main-menu--section'
                };

                $nav.rsAccordion(cfg);

                $('> li', $nav).each(function () {
                  var $this = $(this);

                  if ($this.hasClass('alternate')) {
                    $('.menu-level-2 .menu-item', $this).addClass('js-group');
                  }
                  else {
                    $('.menu-item', $this).addClass('js-group');
                  }
                });

                var $subNav = $('.sub-menu > .menu', element.container);

                var cssSubMenuClass = 'sub-menu';
                var cssPrefixAccordion = 'accordions-enabled--col';
                var cssTrigger = '.' + cssSubMenuClass + '--trigger';
                var cssSection = 'ul.menu';
                var cssGroup = '.js-group';
                var $trackerSubNav = jQuery('.tracker', '.' + cssSubMenuClass + ' > .menu');

                var cfgSubNav = {
                  group: cssGroup,
                  trigger: cssTrigger,
                  section: cssSection,
                  scrollTo: false,
                  onAfterExpand: function () {
                    $trackerSubNav.css('opacity', 0);
                  },
                  onBeforeCollapse: function () {
                    $trackerSubNav.css('opacity', 0);
                  }
                };

                $subNav.find('.' + cssPrefixAccordion).rsAccordion(cfgSubNav);

                var $cloneSitePortals = $('.site-portals', $tools).clone();

                element.container.append(
                  $cloneSitePortals
                );
              }
            });
          },
          responsive: {
            1050: {
              bypass: true
            }
          }
        });
      }
    });
  };

  Drupal.behaviors.siteHeader = {
    attach: siteHeader
  };

})(jQuery);

(function ($) {

  var sliderCommunity = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'slider-community';
    var $targets = $('.' + cssClass + '--slider', context);

    $targets.each(function () {
      var $target = $(this);

      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        $target.responsiveSlider({
          adaptativeHeight: true,
          mode: 'flex',
          sliderRange: 1,
          fitSlides: true,
          autoPlay: true,
          autoPlayDuration: 4,
          pager: function (_self, $prev, $next, $dotsHolder) {
            _self.after($dotsHolder);
          }
        });
      }
    });
  };

  Drupal.behaviors.sliderCommunity = {
    attach: sliderCommunity
  };

})(jQuery);

// Create Slider Comparisons

(function ($) {

  var sliderComparisons = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'slider-comparisons';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);

      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var $list = $('.' + cssClass + '--slider', $target);
        var $container = $('.' + cssClass + '--container', $target);
        $list.responsiveSlider({
          adaptativeHeight: true,
          mode: 'flex',
          sliderRange: 1,
          fitSlides: true,
          pager: function (_self, $prev, $next, $dotsHolder) {
            _self.after($dotsHolder);
          },
          responsive: {
            640: {
              pager: function (_self, $prev, $next) {
                $container.prepend($prev);
                $container.append($next);
              }
            }
          }
        });
      }
    });
  };

  Drupal.behaviors.sliderComparisons = {
    attach: sliderComparisons
  };

})(jQuery);

// Slider Markets

(function ($) {

  var sliderMarkets = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'slider-markets';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);

      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var $list = $('ul:first', $target);
        var $li = $('> li', $list);
        var length = $li.length;
        var width = 100/length;

        $list.responsiveSlider({
          adaptativeHeight: false,
          sliderRange: 1,
          mode: 'flex',
          fitSlides: true,
          pager: function (_self, $prev, $next, $dotsHolder) {
            _self.after($dotsHolder);
          },
          responsive: {
            960: {
              mode: 'flex',
              onBeforeSlide: function (params) {
                var translate = (width * .25) * params.target.index;
                params.target.elt.width(width + '%');
                params.target.elt.nextAll().width(width * .75 + '%');
                params.target.elt.prevAll().width(width * .75 + '%');
                params.slider.css('transform', 'translateX(' + translate + '%)');

                var $prev = $('.responsive-slider--pager-prev', $target).removeAttr('style');
                var $next = $('.responsive-slider--pager-next', $target).removeAttr('style');

                if (params.target.index === 1) {
                  $prev.css('display', 'none');
                }

                if (params.target.index === (length - 2)) {
                  $next.css('display', 'none');
                }
              },
              pager: function (_self, $prev, $next) {
                $target.prepend($prev).append($next);

                $li.eq(0).siblings().css('width', width * .75 + '%');
                $('.responsive-slider--wrapper', $target).css({'padding':  '0 ' + $li.eq(0).next().width() + 'px'});
                $next.click();
              }
            }
          }
        });
      }
    });
  };

  Drupal.behaviors.sliderMarkets = {
    attach: sliderMarkets
  };

})(jQuery);

// Slider Markets

(function ($) {

  var stepsSlider = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'steps-slider';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);

      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        var $list = $('ul:first', $target);
        var $wrapper = $('<div />', {
          class: cssClass + '--wrapper'
        });
        $list.wrap($wrapper);

        var $nav = $('<ul />', {
          class: cssClass + '--nav'
        });

        $('> li', $list).each(function () {
          var $item = $(this);
          var $info = $('.teaser-step--info', $item).detach();
          var $picture = $('.teaser-step--picture', $item).clone();
          var $li = $('<li />');
          $picture.append($info);

          $nav.append(
            $li.append(
              $picture
            )
          );

          $list.hide();

          $li.click(function () {
            var index = $(this).index();
            $list.fadeIn();
            $list.responsiveSlider({
              adaptativeHeight: false,
              sliderRange: 1,
              mode: 'flex',
              startingIndex: index,
              fitSlides: true,
              pager: function (_self, $prev, $next, $dotsHolder) {
                var $overlay = $('<span />', {class: cssClass + '--overlay js-close'});
                var $close = $('<span />', {class: 'responsive-slider--close js-close'}).text('Close this step');
                var $header = $('.site-header', context);

                $.each($dotsHolder[0].children, function (i, item) {
                  var $title = $('.teaser-step--title', _self[0].children[i]);
                  var $tooltip = $('<span />', {class: 'responsive-slider--tooltip'});
                  $tooltip.text($title.text());
                  $(item).html($tooltip);
                });

                _self.before($dotsHolder);
                _self.before($prev);
                _self.before($next);

                if ($('.js-close').length === 0) {
                  _self.before($close);
                  $('body').prepend($overlay);
                }

                $('.js-close').click( function () {
                  var $this =  $(this);
                  $this.fadeOut(function () {
                    _self.parent().fadeOut(function(){
                      _self.destroySlider();
                      $overlay.remove();
                      $close.remove();
                      _self.hide();
                    });
                  });
                });
                animatedScrollTo($target.parent().offset().top - $header.height());
              }
            });
          });
        });
        $target.append($nav);

        var adjustHeight = function (target) {
          target.removeAttr('style');
          if ($(window).width() > 900) {
            var heightNav = target.height();
            $('> li', target).each(function () {
              var $li = $(this);
              var $title = $('.teaser-step--title', $li);
              var heightTitle = $title.outerHeight();

              if (heightTitle > heightNav) {
                heightNav = heightTitle;
                target.height(heightNav);
              }
            });
          }
        };

        adjustHeight($nav);
        $(window).resize(function () {
          adjustHeight($nav);
        });

        $target.css('visibility', 'visible');
      }
    });
  };

  Drupal.behaviors.stepsSlider = {
    attach: stepsSlider
  };

})(jQuery);

var trainingWallInstances = [];
(function ($) {

  var trainingWall = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'training-wall';
    var $targets = $('.' + cssClass, context);

    $targets.each(function (index) {
      var $target = $(this);

      // Move optin block
      var $optinBlock = $('.optin-block', $target);

      if ($optinBlock.length) {
        $target.before($optinBlock);
      }

      // Launch wall of content
      if (!$target.data('init-' + cssClass)) {

        $target.data('init-' + cssClass, true);

        // Build Wall of Content (Masonry) to display list
        trainingWallInstances[index] = $target.wallOfContent({
          target: $target,
          wallContainerClass: cssClass + '--container',
          wallColClass: cssClass + '--col',
          blocksToOrder: '.teaser-links, .teaser-event, .teaser-highlight-news',
          bypass: true,
          responsive: {
            640: {
              bypass: false,
              grid: 2
            }
          }
        });
      }
      else {
        if (typeof trainingWallInstances[index] !== 'undefined' && typeof trainingWallInstances[index].reload === 'function') {
          trainingWallInstances[index].reload();
        }
      }
    });
  };

  Drupal.behaviors.trainingWall = {
    attach: trainingWall
  };

})(jQuery);

(function ($) {

  /**
   * @typedef {object} vectorMap_options
   *
   * @property {string} containerClass='' - CSS rule for targeting the element
   *   to place the map
   * @property {number} zoomLevel=4 - Zoom level for the map
   * @property {string} alignZoom='right' - Horizontal alignment of zoom
   *   control
   * @property {string} alignZoom='bottom' - Vertical alignment of zoom control
   * @property {boolean} enableSmallMapPreview=false - Add small map preview on
   *   the corner to see where we are in the map
   * @property {boolean} enableMarker=true - Enable customized maker svg or
   *   simple point
   * @property {boolean} enableWheel=true - Enable wheel for zoom
   * @property {boolean} enableDrag=true - Enable to drag on the map
   * @property {number} startLat='' - Latitude of the starting point to center
   *   the map
   * @property {number} startLng='' - Longitude of the starting point to center
   *   the map
   * @property {string} countryColor='#bbbbbb' - Background color for the
   *   country
   * @property {string} countryHoverColor='' - Background color on
   *   rollover for the country
   * @property {string} countrySelectedColor='' - Background color for
   *   the country selected
   * @property {string} countryStrokeColor='#000000' - Background color of
   *   country stroke
   * @property {number} countryStrokeWidth=0.5 - Width of country stroke
   * @property {object} dataPoints={} - Object to store all the datas of marker
   * @property {string} tooltipKeyTitle='title' - Key to use for managing the
   *   title of Tooltip
   * @property {object} activeCountryList=[]' - Array of activated countries
   * @property {object} addCountryName=[]' - Array with the country name list
   * @property {function} onCountrySelection - Callback to be executed after
   *   country selection
   *
   * */

  $.fn.extend({

    vectorMap: function (cfg) {

      var defaults = {
        // Options
        licence: '',
        target: 'vector-map',
        zoomLevel: 1,
        alignZoom: 'right',
        valignZoom: 'bottom',
        enableMarkerImg: true,
        enableWheel: true,
        enableDrag: true,
        startLat: '',
        startLng: '',
        countryColor: '#ececec',
        countryHoverColor: '',
        countrySelectedColor: '#808080',
        countryStrokeColor: '#ffffff',
        countryStrokeWidth: 1.5,
        dataPoints: [{
          latitude: 48.857008,
          longitude: 2.348774,
          imageUrl: 'img/vector-map/map-marker.svg',
          width: 16,
          height: 23
        }],
        activeCountryList: [],
        addCountryName: [],

        onCountrySelection: function () {

        },
        onComplete: function () {

        },

        // _resizeTimeout: Time, in seconds, to recalculate the slider to the resize
        _resizeTimeout: 0.25
      };

      // Storage of the object
      var _self = this;

      // Configuration
      var options;

      // Element for the map am4chart
      var chart;
      var activatedCountry;
      var polygonSeries;

      // PRIVATE FUNCTIONS
      // Initialization of the map
      var init = function () {

        // Managing configuration options
        options = cfgManager(defaults, cfg);

        // Add amCharts 4 license
        am4core.addLicense(options.licence);

        // Use am4maps
        am4core.ready(function () {

          // Create map instance
          chart = am4core.create(options.containerClass, am4maps.MapChart);

          // Set map definition
          chart.geodata = am4geodata_worldLow;

          // Set projection
          chart.projection = new am4maps.projections.Miller();

          // Create map polygon series
          polygonSeries = chart.series.push(new am4maps.MapPolygonSeries());

          // Make map load polygon (like country names) data from GeoJSON
          polygonSeries.useGeodata = true;

          // Set default zoom
          chart.homeZoomLevel = options.zoomLevel;

          // Exclude countries
          polygonSeries.exclude = ['AQ'];

          // Set starting point in the map
          if (typeof options.startLat === 'number' && typeof options.startLng === 'number') {
            chart.homeGeoPoint = {
              latitude: parseFloat(options.startLat),
              longitude: parseFloat(options.startLng)
            };
          }

          // Configure zoom control
          chart.zoomControl = new am4maps.ZoomControl();
          chart.zoomControl.fontWeight = 'bold';
          chart.zoomControl.plusButton.background.fill = '#ffffff';
          chart.zoomControl.minusButton.background.fill = '#ffffff';
          chart.zoomControl.slider.height = 100;

          // Customize placement of zoom control
          chart.zoomControl.dx = 10;
          chart.zoomControl.dy = -40;
          if (options.alignZoom === 'top' || options.alignZoom === 'bottom') {
            chart.zoomControl.align = options.alignZoom;
          }

          if (options.valignZoom === 'left' || options.valignZoom === 'right') {
            chart.zoomControl.valign = options.valignZoom;
          }

          // Disable drag or wheel on map for zooming
          if (typeof options.enableWheel === 'boolean') {
            chart.chartContainer.wheelable = options.enableWheel;
          }

          if (typeof options.enableDrag === 'boolean') {
            chart.seriesContainer.draggable = options.enableDrag;
          }

          // Configure series
          var polygonTemplate = polygonSeries.mapPolygons.template;
          polygonTemplate.hideTooltip();
          polygonTemplate.background.fill = options.countryColor;
          polygonTemplate.stroke = options.countryStrokeColor;
          polygonTemplate.strokeWidth = options.countryStrokeWidth;
          polygonTemplate.applyOnClones = true;
          polygonTemplate.togglable = true;

          // Create hover behavior if defined
          if (options.countryHoverColor !== '') {
            var hs = polygonTemplate.states.create('hover');
            hs.properties.fill = options.countryHoverColor;
          }

          // Active behavior if defined
          if (options.countrySelectedColor !== '') {
            var ss = polygonTemplate.states.create('active');
            ss.properties.fill = options.countrySelectedColor;
          }

          // Define the activated countries
          if (typeof options.activeCountryList === 'object' && options.activeCountryList.length > 0) {

            chart.events.on('ready', function () {
              manageActivationCountry(options.activeCountryList, true);
              activatedCountry = options.activeCountryList;
            });
          }

          // Change the name of the countries and add the label on them
          if (typeof options.addCountryName === 'object' && options.addCountryName.length > 0) {

            var labelSeries = chart.series.push(new am4maps.MapImageSeries());
            labelSeries.id = 'labels';
            var labelTemplate = labelSeries.mapImages.template.createChild(am4core.Label);
            labelTemplate.horizontalCenter = 'middle';
            labelTemplate.verticalCenter = 'middle';
            labelTemplate.fontSize = 10;
            labelTemplate.fontWeight = 'bold';
            labelTemplate.fill = '#333333';
            labelTemplate.nonScaling = true;
            labelTemplate.interactionsEnabled = false;

            labelSeries.events.on('datavalidated', function () {

              options.addCountryName.forEach(function (poi) {
                var country = polygonSeries.getPolygonById(poi.id);

                if (typeof country !== 'undefined') {

                  var label = labelSeries.mapImages.create();
                  label.latitude = country.latitude;
                  label.longitude = country.longitude;
                  label.zoomLevel = poi.minZoomLevel;

                  if (typeof poi.latitude !== 'undefined' && poi.longitude !== 'undefined') {
                    label.latitude = poi.latitude;
                    label.longitude = poi.longitude;
                  }

                  label.children.getIndex(0).text = poi.name.toUpperCase();
                }
              });
            });

            // hide/show countries according to zoom level
            var updateCountriesVisibility = function (elt) {
              var chart = elt.target.baseSprite;
              var series = chart.map.getKey('labels');
              series.mapImages.each(function (image) {
                if (image.zoomLevel) {
                  if (image.zoomLevel >= chart.zoomLevel) {
                    image.hide();
                  }
                  else {
                    image.show();
                  }
                }
              });
            };

            labelSeries.events.on('datavalidated', updateCountriesVisibility);
            chart.events.on('zoomlevelchanged', updateCountriesVisibility);
          }

          // Activate country on select
          polygonTemplate.togglable = false;
          polygonTemplate.events.on('hit', function (ev) {

            var $target = ev.target;
            var id = $target.dataItem.dataContext.id;

            $.each(activeCountryList, function (i, item) {

              if (id === item.id) {

                // Zoom on the selected country
                $target.series.chart.zoomToMapObject(polygonSeries.getPolygonById(id));

                // Return country id in a function
                options.onCountrySelection(id);
              }
            });
          });

          // Add small map preview on zoom if enabled
          if (options.enableSmallMapPreview) {
            chart.smallMap = new am4maps.SmallMap();
            chart.smallMap.align = 'right';
            chart.smallMap.valign = 'top';
            chart.smallMap.series.push(polygonSeries);
          }

          // Create marker
          var markerSeries = chart.series.push(new am4maps.MapImageSeries());
          markerSeries.id = 'markers';
          var markerTemplate = markerSeries.mapImages.template;
          markerTemplate.propertyFields.longitude = 'longitude';
          markerTemplate.propertyFields.latitude = 'latitude';
          markerTemplate.nonScaling = true;

          var marker = markerTemplate.createChild(am4core.Image);
          if (options.enableMarkerImg) {
            marker = markerTemplate.createChild(am4core.Image);
            marker.propertyFields.href = 'imageUrl'; // Marker with customized image
            marker.horizontalCenter = 'middle';
            marker.verticalCenter = 'bottom';
          }
          else {
            marker = markerTemplate.createChild(am4core.Circle); // Marker with simple circle
          }

          marker.propertyFields.width = 'width';
          marker.propertyFields.height = 'height';

          // Add marker to map
          markerSeries.data = options.dataPoints;

          // Hide displayed tooltip
          var hideTooltip = function (currentMarker) {

            if (currentMarker) {
              currentMarker.tooltipHTML = '';
              currentMarker.alwaysShowTooltip = false;
              currentMarker.tooltip.hide();
            }
          };

          // Open tooltip HTML on 'hit' event
          var currentObject;

          markerTemplate.events.on('hit', function (ev) {
            hideTooltip(currentObject);

            // Configuration Tooltip HTML
            var marker = ev.target;
            marker.tooltipHTML = '{content}';
            marker.tooltip = new am4core.Tooltip();
            marker.tooltip.pointerOrientation = 'left';
            marker.tooltip.dy = -12;
            marker.tooltip.dx = 5;
            marker.tooltip.getFillFromObject = false;
            marker.tooltip.background.cornerRadius = 0;
            marker.tooltip.background.strokeWidth = 0;
            marker.tooltip.background.filters.clear();
            marker.tooltip.label.wrap = true;
            marker.tooltip.label.padding(0, 0, 0, 0);
            marker.tooltip.label.interactionsEnabled = true;
            marker.alwaysShowTooltip = true;
            marker.showTooltip();

            currentObject = marker;
          });

          // Hide Tooltip when clicking outside
          $(document).click(function (event) {

            if (event.target.closest('.map-layer') === null && event.target.tagName !== 'image') {
              hideTooltip(currentObject);
            }
          });

          // Hide Tooltip on zoom level changed
          chart.events.on('zoomlevelchanged', function () {
            hideTooltip(currentObject);
          });

          // Resetting map position/zoom
          var reset = chart.chartContainer.createChild(am4core.Button);
          reset.valign = 'bottom';
          reset.width = 30;
          reset.height = 40;
          reset.padding(0, 0, 0, 0);
          reset.dx = 15;
          reset.dy = -220;
          reset.background.fill = '#ffffff';
          reset.events.on('hit', function () {
            chart.goHome();
          });

          reset.icon = new am4core.Sprite();
          reset.icon.path = 'M10.7,2.2L10.7,2.2l0.7-0.4c0.2-0.1,0.4-0.4,0.3-0.6c0-0.3-0.2-0.5-0.4-0.6c-0.2-0.1-0.5-0.1-0.7,0L8.2,2 c0,0,0,0,0,0C8.1,2.1,8.1,2.1,8,2.2C8,2.3,7.9,2.4,7.9,2.5c0,0,0,0,0,0c0,0,0,0,0,0.1c0,0,0,0.1,0,0.1C7.9,2.9,8,3,8,3.1L10,5.3 c0.3,0.3,0.7,0.3,1,0.1c0.3-0.3,0.3-0.7,0.1-1l-0.6-0.7c3,0.9,4.9,3.8,4.7,6.9c-0.3,3.1-2.7,5.6-5.8,6c-3.1,0.4-6-1.5-7-4.5 s0.3-6.2,3-7.8c0.3-0.2,0.5-0.6,0.3-1C5.4,2.9,4.9,2.8,4.6,3C1.2,4.9-0.3,8.9,1,12.5s4.8,5.9,8.7,5.4s6.7-3.6,7-7.4 C16.9,6.7,14.4,3.2,10.7,2.2z';
          reset.icon.valign = 'middle';

          // Function after complete
          chart.events.on('ready', function () {
            $.each(markerSeries.data, function (i) {
              if (markerSeries.data.length - 1 === i) {
                options.onComplete();
              }
            });
          });
        });
      };

      var manageActivationCountry = function (list, status) {

        list.forEach(function (poi, i) {
          var country = polygonSeries.getPolygonById(poi.id);

          if (typeof country !== 'undefined') {
            country.isActive = status;
          }
        });
      };

      /**
       * @method external:"jQuery.fn".vectorMap.updateActiveCountryList
       * @description Add active behavior on country
       *
       * @param {object} id - List of country code (2 letters)
       *
       */
      _self.updateActiveCountryList = function (countryList) {

        if (typeof options.countrySelectedColor != 'undefined') {

          // Highlighted the new activated country
          chart.events.once('validated', function () {

            // Deactivate the previous country highlighted
            if (typeof activatedCountry === 'object' && activatedCountry !== '' && activatedCountry !== countryList) {
              manageActivationCountry(activatedCountry, false);
            }
            manageActivationCountry(countryList, true);
          });

          // Launch event for updating the map
          chart.dispatchImmediately('validated');

          // Place the new country on activated country list
          activatedCountry = countryList;
        }
      };

      /**
       * @method external:"jQuery.fn".vectorMap.zoomToCountry
       * @description Zoom on a specific country
       *
       * @param {object} id - country (iso code)
       *
       */
      _self.zoomToCountry = function (ev) {
        var series = chart.map.getKey('markers');
        series.mapImages.each(function (marker) {
          marker.tooltip.hide();
        });

        if (typeof ev !== 'undefined' && ev !== 'All') {
          chart.zoomToMapObject(polygonSeries.getPolygonById(ev));
        }
        else {
          chart.goHome();
        }
      };

      /**
       * @method external:"jQuery.fn".vectorMap.updateMarkers
       * @description Update map with data
       *
       */
      _self.updateMarkers = function (data) {

        chart.events.on('validated', function (elt) {
          var chart = elt.target.baseSprite;
          var series = chart.map.getKey('markers');
          series.data = data;
        });

        chart.dispatchImmediately('validated');
      };

      // Launching the initialization
      init();

      return _self;
    }

  });

})(jQuery);

// random display of gradients

(function ($) {

  var chosenJs = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'has-chosen';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {
      var $target = $(this);

      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);

        $target.on('chosen:ready', function (event, elt) {
          var chosen = elt.chosen;
          chosen.search_field.attr('placeholder', chosen.default_text);
          // Exclude chosen search field from drupal BEF autosubmit.
          chosen.search_field.attr('data-bef-auto-submit-exclude', '1');
        }).chosen();
      }
    });
  };

  Drupal.behaviors.chosenJs = {
    attach: chosenJs
  };

})(jQuery);

(function ($) {

    var stickyTable = function (context, settings) {

        if (typeof context === 'undefined') {
            context = document;
        }

        var cssClass = 'stickytable';
        var $targets = $('.' + cssClass, context);

        $targets.each(function () {
          var $target = $(this);

          if ($target.data('init-' + cssClass)) {
              return true; // continue
          }
          $target.data('init-' + cssClass, true);

          var blocHeight = 0;
          if ($('.site-header').length) {
            blocHeight += $('.site-header').height();
          }

          $targets.stickyTable({deltaTop: blocHeight});
        });
    };

    Drupal.behaviors.stickyTable = {
        attach: stickyTable
    };

})(jQuery);
(function ($) {

  /**
   * @typedef {object} rsAccordion_options
   *
   * @property {string} group='' - CSS rule targeting the elements of the DOM grouping'trigger' and'section
   * @property {string} trigger='' CSS rule targeting DOM elements triggering an opening
   * @property {string} section='' CSS rule targeting the DOM elements to open
   * @property {string} startOpened='' CSS rule filtering groups to open by default
   * @property {string} easing='linear' Easing function for opening animation (may require jQuery.easing)
   * @property {number} duration=_duration|500 Duration of animation (in miliseconds)
   * @property {boolean} oneByOne=true Only one open section at a time
   * @property {boolean} atLeastOne=false Prevent the open section from closing (only taken into account if oneByOne is "true")
   * @property {string} expandedClass='expanded' CSS class added to the group when its section is open
   * @property {string} collapsedClass='collapsed' CSS class added to the group when its section is closed
   * @property {string} accordionEnabled='accordion-enabled' CSS class added to the group when the accordion system is effective on it (a group may exist, but may not have a trigger or section, and therefore not meet the prerequisites)
   * @property {boolean} scrollTo=false Adjust the vertical scroll of the page at the top of the group when opening (requires the "animatedScrollTo" script)
   * @property {string} tabsClass='accordion-tabs' CSS class of tabs
   * @property {boolean|function} tabs=false Generate an ul>li to control the opening via false(default) | function tabs (if a function is declared, it receives the $(ul) pre-constructed parameter)
   * @property {function} onBeforeExpand=function(id,_self){} Callback triggered before opening
   * @property {function} onAfterExpand=function(id,_self){} Callback triggered after opening
   * @property {function} onBeforeCollapse=function(id,_self){} Callback triggered before closing
   * @property {function} onAfterCollapse=function(id,_self){} Callback triggered after closing
   * @property {object.<rsAccordion_options>} responsive={} Redefinition of options for the responsive (Mobile first). The object key corresponds to the screen width from which the previously declared options are overridden.
   *
   * */

  /**
   * @typedef {object} rsAccordion_output
   * @description Data returned by rsAccordion
   *
   * @property {jQuery} $tabsHolder - UL hosting tabs
   * @property {jQuery} $groups - Storage of groups
   * @property {jQuery} $triggers - Storage of triggers
   * @property {jQuery} $tabs - Storage of groups
   * @property {jQuery} $sections - Storage of sections
   * @property {array} expandedStatus - Status expanded or not of groups
   *
   * */

  /**
   * @class external:"jQuery.fn".rsAccordion
   *
   * @param {rsAccordion_options} [cfg] - Accordion Configuration Options
   *
   * @return {rsAccordion_output}
   */

  $.fn.extend({

    rsAccordion: function (cfg) {

      var defaults = {
        // Options
        group: '',
        trigger: '',
        section: '',
        startOpened: '',
        easing: 'linear',
        duration: typeof _duration !== 'undefined' ? _duration : 500,
        oneByOne: true,
        atLeastOne: false,
        expandedClass: 'expanded',
        collapsedClass: 'collapsed',
        accordionEnabled: 'accordion-enabled',
        scrollTo: false,
        tabsClass: 'accordion-tabs',
        tabs: false,
        responsive: {},

        /** Events **/
        onBeforeExpand: function () {
        },
        onAfterExpand: function () {
        },
        onBeforeCollapse: function () {
        },
        onAfterCollapse: function () {
        },

        // _resizeTimeout: Time, in seconds, to recalculate the slider to the resize
        _resizeTimeout: 0.25
      };

      // Storage of the object
      var _self = this;

      // Configuration
      var options;

      // Element storage
      _self.$groups = [];
      _self.$triggers = [];
      _self.$tabs = [];
      _self.$sections = [];

      // Status memory (expanded or not)
      _self.expandedStatus = [];

      // We declare the setTimeout of the resize application
      var resize;

      // PRIVATE FUNCTIONS
      // Initialization of the accordion
      var init = function () {

        // Resize detection
        $(window).bind('resize', _self.reload);

        // Managing configuration options
        options = cfgManager(defaults, cfg);

        // We're picking up all the target groups
        var allGroups = $(options.group, _self);

        _self.$tabsHolder = $('<ul />', {class: options.tabsClass});

        // Management of active items by default or not
        allGroups.filter(options.startOpened).each(function (i, group) {
          var $group = $(group);

          var $trigger = $(options.trigger, $group);
          var $section = $(options.section, $group);

          if ($trigger.length && $section.length) {
            // If the group includes a trigger and a section, we specify that it must be extended by default
            $group.data('accordion-section-to-expand-by-default', true);
          }

        });

        var filteredElts;
        if (options.startOpened !== '') {
          filteredElts = allGroups.filter(':not(' + options.startOpened + ')');
        }
        else {
          filteredElts = allGroups;
        }

        filteredElts.each(function (i, group) {
          var $group = $(group);

          var $trigger = $(options.trigger, $group);
          var $section = $(options.section, $group);

          if ($trigger.length && $section.length) {
            // If the group includes a trigger and a section, we specify that it should not be extended by default
            $group.data('accordion-section-to-expand-by-default', false);
          }

        });

        // Behaviour reporting
        var index = 0;
        allGroups.each(function (i, group) {

          var id = index;
          var $group = $(group);

          var $trigger = $(options.trigger, $group);
          var $section = $(options.section, $group);

          var $tab;
          if ($trigger.length) {
            $tab = $('<li />').html($trigger.html());
            _self.$tabsHolder.append($tab);
          }

          if ($trigger.length && $section.length) {

            _self.$groups[id] = $group;
            _self.$triggers[id] = $trigger;
            _self.$sections[id] = $section;
            _self.$tabs[id] = $tab;

            // We specify that the accordion behavior is active on this group
            $group.addClass(options.accordionEnabled);

            // Applying the default fallback or extension
            var accordionSectionToExpandByDefault = $group.data('accordion-section-to-expand-by-default');
            if (typeof accordionSectionToExpandByDefault === 'boolean') {
              // Disable animation options for initialization
              var memorizeScrollTo = options.scrollTo;
              var memorizeDuration = options.duration;
              options.scrollTo = false;
              options.duration = 0;

              if (accordionSectionToExpandByDefault) {
                _self.expand(id);
              }
              else {
                _self.collapse(id);
              }

              // We're restoring the options
              options.scrollTo = memorizeScrollTo;
              options.duration = memorizeDuration;
            }

            var toggler = function () {
              // If the group is not open
              if ($group.hasClass(options.collapsedClass)) {
                _self.expand(id);
              }
              // If the group is already open
              else if ($group.hasClass(options.expandedClass)) {
                if (
                  // If we operate "one by one" but we do not impose to have at least 1 always open
                (options.oneByOne && !options.atLeastOne) ||
                // If we don't work "one by one"
                (!options.oneByOne)
                ) {
                  _self.collapse(id);
                }
              }

              return false;
            };

            $trigger.click(toggler);
            $tab.click(toggler);

            index++;
          }
        });

        // Tab management
        if (typeof options.tabs === 'function') {
          options.tabs(_self.$tabsHolder);
        }
        else if (typeof options.tabs === 'boolean' && options.tabs) {
          _self.prepend(_self.$tabsHolder);
        }
      };

      // Declaring a closed section
      var setGroupCollapsed = function (id) {

        _self.$groups[id].removeClass(options.expandedClass);
        _self.$groups[id].addClass(options.collapsedClass);
        _self.$tabs[id].removeClass(options.expandedClass);
        _self.$tabs[id].addClass(options.collapsedClass);
        _self.expandedStatus[id] = false;

      };

      // Declare a section open
      var setGroupExpanded = function (id) {

        _self.$groups[id].removeClass(options.collapsedClass);
        _self.$groups[id].addClass(options.expandedClass);
        _self.$tabs[id].removeClass(options.collapsedClass);
        _self.$tabs[id].addClass(options.expandedClass);
        _self.expandedStatus[id] = true;

      };

      // PUBLIC FUNCTIONS
      /**
       * @method external:"jQuery.fn".rsAccordion.expand
       * @description Opening a section of the accordion
       *
       * @param {number} id - Group Index
       *
       */

      _self.expand = function (id) {

        if (!_self.$groups[id].hasClass(options.expandedClass)) {

          setGroupExpanded(id);

          if (options.oneByOne) {
            $.each(_self.$groups, function (i) {
              var index = i;
              if (index !== id) {
                _self.collapse(index);
              }
            });
          }

          options.onBeforeExpand(id, _self);
          _self.$sections[id].stop(true, true).slideDown({
            easing: options.easing,
            duration: options.duration,
            complete: function () {
              if (options.scrollTo) {
                animatedScrollTo(_self.$groups[id]);
              }
              options.onAfterExpand(id, _self);
            }
          });

        }

      };

      /**
       * @method external:"jQuery.fn".rsAccordion.collapse
       * @description Closing a section of the accordion
       *
       * @param {number} id - Group Index
       *
       */

      _self.collapse = function (id) {

        if (!_self.$groups[id].hasClass(options.collapsedClass)) {

          setGroupCollapsed(id);

          options.onBeforeCollapse(id, _self);
          _self.$sections[id].stop(true, true).slideUp({
            easing: options.easing,
            duration: options.duration,
            complete: function () {
              options.onAfterCollapse(id, _self);
            }
          });

        }

      };

      /**
       * @method external:"jQuery.fn".rsAccordion.reload
       * @description Re-initialize accordion
       *
       */

      _self.reload = function () {

        clearTimeout(resize);
        resize = setTimeout(function () {

          _self.destroy();
          init();

        }, (options._resizeTimeout * 1000));

      };

      /**
       * @method external:"jQuery.fn".rsAccordion.destroy
       * @description Destroy Accordion
       *
       */

      _self.destroy = function () {

        $.each(_self.$groups, function (i, group) {
          group.removeClass(options.expandedClass).removeClass(options.collapsedClass).removeClass(options.accordionEnabled);
        });
        $.each(_self.$triggers, function (i, trigger) {
          trigger.unbind('click');
        });
        $.each(_self.$sections, function (i, section) {
          section.show();
        });

        options = void 0;

        _self.$tabsHolder.remove();

        _self.$groups = [];
        _self.$triggers = [];
        _self.$tabs = [];
        _self.$sections = [];

        _self.expandedStatus = [];

        resize = void 0;

      };

      // Launching the initialization
      init();

      return _self;
    }

  });

})(jQuery);

(function ($) {

  /**
   * @typedef {object} animatedCounter_options
   * @description Possible configuration options of the animatedCounter class
   *
   * @property {number} start=0 - Number from where the counter starts
   * @property {number} end=parseFloat(this.text()) - Number of end of counter
   * @property {number} decimals=0 - Number of digits after the decimal point
   * @property {number} duration=_duration|500 - Duration of animation (in miliseconds)
   * @property {function} onComplete=null Callback triggered after animation
   * @property {function} onChange=null Callback triggered at each step of the animation
   * @property {object.<animatedCounter_options>} responsive={} Redefinition of options for the responsive (Mobile first). The object key corresponds to the screen width from which the previously declared options are overridden.
   *
   * */

  /**
   * @class external:"jQuery.fn".animatedCounter
   *
   * @param {animatedCounter_options} [cfg] - Animated counter configuration options
   *
   * @return {jQuery}
   */

  $.fn.extend({

    animatedCounter: function (cfg) {

      // Storage of the object
      var _self = this;

      if (typeof cfg !== 'object') {
        cfg = {};
      }

      var defaults = {
        start: 0,
        end: parseFloat($.trim(_self.text())),
        decimals: 0,
        duration: typeof _duration !== 'undefined' ? _duration : 500,
        onComplete: null,
        onChange: null
      };

      // Configuration
      var options;

      var initialStatus;

      // PRIVATE FUNCTIONS
      // Initialization of the animation
      var init = function () {

        // Managing configuration options
        options = cfgManager(defaults, cfg);

        if (_self.length && !isNaN(options.start) && !isNaN(options.end)) {
          initialStatus = _self.html();
          _self.startAnimation();
        }
      };

      // PUBLIC FUNCTIONS
      /**
       * @method external:"jQuery.fn".animatedCounter.setStart
       * @description Redefine the counter start option
       *
       * @param {number} start=0 - Number from where the counter starts
       *
       */

      _self.setStart = function (start) {
        var number = parseFloat($.trim(start));
        if (!isNaN(number)) {
          options.start = number;
        }
      };

      /**
       * @method external:"jQuery.fn".animatedCounter.getStart
       * @description Return the counter start option
       *
       * @return {number} - Meter start option
       *
       */

      _self.getStart = function () {
        return options.start;
      };

      /**
       * @method external:"jQuery.fn".animatedCounter.setEnd
       * @description Redefine the end option of the counter
       *
       * @param {number} end=0 - Number of end of counter
       *
       */

      _self.setEnd = function (end) {
        var number = parseFloat($.trim(end));
        if (!isNaN(number)) {
          options.end = number;
        }
      };

      /**
       * @method external:"jQuery.fn".animatedCounter.getEnd
       * @description Return the end option of the counter
       *
       * @return {number} - Meter end option
       *
       */

      _self.getEnd = function () {
        return options.end;
      };

      /**
       * @method external:"jQuery.fn".animatedCounter.startAnimation
       * @description Restart animation
       *
       * @return {object} - this
       */

      _self.startAnimation = function () {
        // set the content of the field to zero
        _self.text(options.start);

        // startAnimation jQuery function parameters
        var params = {
          duration: options.duration,
          easing: 'swing',
          step: function () {
            var value;
            if (options.decimals > 0) {
              var rounder = Math.pow(10, options.decimals);
              value = Math.round(this.Counter * rounder) / rounder;
            }
            else {
              value = Math.ceil(this.Counter);
            }

            if (typeof options.onChange === 'function') {
              options.onChange(_self, value);
            }
            else {
              _self.text(value);
            }
          },
          complete: function () {
            if (typeof options.onComplete === 'function') {
              options.onComplete(_self, options.end);
            }
            else {
              _self.text(options.end);
            }
          }
        };

        // animate jQuery
        $({Counter: options.start}).animate({
          Counter: options.end
        }, params);

        return _self;
      };

      /**
       * @method external:"jQuery.fn".animatedCounter.destroy
       * @description Destroy Counter
       *
       * @return {object} - this
       */

      _self.destroy = function () {
        _self.setStart = void 0;
        _self.setEnd = void 0;
        _self.getStart = void 0;
        _self.getEnd = void 0;
        _self.startAnimation = void 0;
        options = void 0;

        _self.html(initialStatus);
        initialStatus = void 0;

        return _self;
      };

      // Launching the initialization
      init();

      return _self;
    }

  });

})(jQuery);

// Animated digits : digit counter

var animatedDigits;

(function ($) {

  animatedDigits = function ($target, $parent, duration) {
    var done = false;
    var text = $target.text();
    var newText = text.replace(/\d+/g, '<span data-end="$&">0</span>');
    $target.html(newText);

    var animation = function () {
      var winHeight = $(window).height();
      var windowPos = $(window).scrollTop();
      var targetPos = $parent.offset().top;

      if (windowPos + (winHeight) > targetPos + Math.round($parent.height() / 3) && done === false) {
        done = true;
        $('span', $target).each(function (i) {
          var $span = $(this);
          var startNumber = $span.text();
          var endNumber = $span.attr('data-end');
          if (parseInt(endNumber) !== 0) {
            $span.delay(duration * (i + 1)).animatedCounter({
              start: startNumber,
              end: endNumber,
              duration: duration
            });
          }
          else {
            $span.text(endNumber);
          }
        });
      }
    };

    animation();
    $(window).scroll(function () {
      animation();
    });
  };
})(jQuery);

var BurgerMenu;

(function ($) {

  /**
   * @typedef {object} BurgerMenu_options
   * @description Possible configuration options of the BurgerMenu class
   *
   * @property {boolean} bypass=false Shorting menu activation
   * @property {string} prefix='burger-menu' Menu CSS prefix (BEM syntax)
   * @property {string|function} trigger='body' CSS insertion rule (append) of the 'body' trigger (default) | function
   * @property {string} openClass='open' Added CSS class on the trigger when the menu is open
   * @property {number} duration=_duration|500 Duration of the animation (in milliseconds)
   * @property {string} easing='easeInOut' Transition type for animation
   * @property {string} side='right' Side of appearance ('right' |'left')
   * @property {string} scroll=false Leave the scroll bar of the body or not
   * @property {object} structure={} Key : CSS suffix of <div /> including | Value: CSS rule of elements to clone
   * @property {function} onStructureChanged=function(_self.structure,_self){} Callback triggered each time the menu structure changes
   * @property {function} onBeforeOpen=function(_self){} Callback triggered before opening
   * @property {function} onAfterOpen=function(_self){} Callback triggered after opening
   * @property {function} onBeforeClose=function(_self){} Callback triggered before closing
   * @property {function} onAfterClose=function(_self){} Callback triggered after closing
   * @property {object.<BurgerMenu_options>} responsive={} Redefinition of options for the responsive (Mobile first). The object key corresponds to the screen width from which the previously declared options are overridden.
   *
   * */

  /**
   * @typedef {object} BurgerMenu_output
   * @description Data returned by BurgerMenu class
   *
   * @property {jQuery} $container - Menu container
   * @property {jQuery} $overlay - Overlay in the background
   * @property {jQuery} $trigger - Open/Close button
   * @property {jQuery} structure - Storing the HTML structure of the container
   *
   * */

  /**
   * @class BurgerMenu
   *
   * @param {BurgerMenu_options} [cfg] BurgerMenu configuration options
   *
   * @return {BurgerMenu_output}
   */

  BurgerMenu = function (cfg) {

    // Security if cfg has not been specified
    if (typeof cfg !== 'object') {
      cfg = {};
    }

    // Default variables
    var defaults = {
      bypass: false,
      prefix: 'burger-menu',
      trigger: 'body',
      openClass: 'open',
      duration: (typeof _duration === 'number') ? _duration : 500,
      easing: 'linear',
      side: 'right',
      scroll: false,
      structure: {},

      /** Events **/
      onStructureChanged: function () {
      },
      onBeforeOpen: function () {
      },
      onAfterOpen: function () {
      },
      onBeforeClose: function () {
      },
      onAfterClose: function () {
      },

      // _resizeTimeout: Time, in seconds, to recalculate the slider to the resize
      _resizeTimeout: 0.25
    };

    // Storage of the object
    var _self = this;

    // Configuration
    var options;

    // Memorisation of the body
    var $body = $('body');

    // Storing the HTML structure of the container
    _self.structure = {};

    // Is the menu open or not ?
    var isOpen = false;

    // Is the menu animated or not ?
    var isAnimating = false;

    // We memorize the width of the viewport at each reset of the slider
    var viewportWidth;

    // We declare the setTimeout of the resize application
    var resize;

    // PRIVATE FUNCTIONS

    // Initialising the burger menu
    var init = function () {

      // Resize detection
      $(window).bind('resize', _self.reload);

      // Managing configuration options
      options = cfgManager(defaults, cfg);

      // We memorize the size of the viewport
      viewportWidth = getViewportWidth();

      if (typeof options.bypass === 'boolean' && !options.bypass) {

        // Creation of the container
        _self.$container = $('<div />', {class: options.prefix + '--container'}).hide();

        // Creation of the container
        _self.$overlay = $('<div />', {class: options.prefix + '--overlay'}).hide();

        // Creating the trigger button
        _self.$trigger = $('<div />', {class: options.prefix + '--trigger'});

        // Behaviors
        _self.$trigger.click(function () {
          if (!isOpen) {
            _self.open();
          }
          else {
            _self.close();
          }
        });
        _self.$overlay.click(_self.close);

        // If the menu was previously open, we reopen it
        if (isOpen) {
          // We neutralize "isOpen" to allow the opening
          isOpen = false;
          _self.open();
        }

        // Trigger button insertion management
        switch (typeof options.trigger) {
          case 'string':
          case 'object':
            $(options.trigger).append(_self.$trigger);
            break;
          case 'function':
            options.trigger(_self.$trigger);
            break;
          default:
            break;
        }
      }
      else {
        isOpen = false;
      }

    };

    // Activate the menu
    var prepareBeforeOpen = function () {
      if (!options.scroll) {
        $body.css('overflow-y', 'hidden');
      }
      // Inserting content
      _self.addStructure(options.structure);
      // Insertion in the DOM
      $body.append(_self.$overlay).append(_self.$container);
    };

    // Deactivating the menu
    var cleanAfterClose = function () {
      if (!options.scroll) {
        $body.css('overflow-y', 'auto');
      }
      // Deleting content
      _self.empty();
      // Withdrawal of the DOM
      _self.$overlay.detach().hide();
      _self.$container.detach().hide();
    };

    // PUBLIC FUNCTIONS
    /**
     * @method BurgerMenu.addStructure
     * @description Add an element in the menu structure
     *
     * @param {object} struture - Key : CSS suffix of <div /> including | Value: CSS rule of the elements to clone
     *
     */

    _self.addStructure = function (struture) {
      if (typeof struture === 'object') {

        $.each(struture, function (suffix, cssRule) {

          var $div = $('<div />', {class: options.prefix + '--' + suffix});

          // Memorization of the elements
          // var index = _self.structure.length;
          _self.structure[suffix] = {
            container: $div,
            clones: []
          };

          if (typeof cssRule === 'string') {
            $(cssRule).each(function (i) {
              var $clone = $(this).clone();

              // Memorization of the elements
              _self.structure[suffix].clones[i] = $clone;

              // Insertion in the DOM
              $clone.appendTo($div);
            });
          }

          // Insertion in the DOM
          _self.$container.append($div);
        });

        options.onStructureChanged(_self.structure, _self);
      }
    };

    /**
     * @method BurgerMenu.empty
     * @description Empty container
     *
     */

    _self.empty = function () {
      _self.$container.empty();
      _self.structure = {};
      options.onStructureChanged(_self.structure, _self);
    };

    /**
     * @method BurgerMenu.open
     * @description Opening the menu
     *
     */

    _self.open = function () {
      if (!isOpen && !isAnimating) {
        isAnimating = true;

        prepareBeforeOpen();

        options.onBeforeOpen(_self);

        _self.$trigger.addClass(options.openClass);

        // Display side management
        var css = {right: '0px'};
        var side = defaults.side;
        if (options.side === 'left') {
          side = 'left';
          css = {left: '0px'};
        }

        // The menu is displayed outside the screen to calculate its width
        _self.$container.css(side, '150%').show();
        var width = _self.$container.width();
        _self.$container.css(side, '-' + width + 'px');

        // Animation
        _self.$overlay.stop(true, true).fadeIn({
          duration: options.duration
        });
        _self.$container.stop(true, true).animate(css, {
          duration: options.duration,
          easing: options.easing,
          complete: function () {

            isAnimating = false;
            isOpen = true;
            options.onAfterOpen(_self);
          }
        });
      }
    };

    /**
     * @method BurgerMenu.close
     * @description Closing the menu
     *
     */

    _self.close = function () {
      if (isOpen && !isAnimating) {
        isAnimating = true;

        options.onBeforeClose(_self);

        _self.$trigger.removeClass(options.openClass);
        var width = _self.$container.width();

        // Display side management
        var css = {right: '-' + width + 'px'};
        if (options.side === 'left') {
          css = {left: '-' + width + 'px'};
        }

        _self.$overlay.stop(true, true).fadeOut({
          duration: options.duration
        });
        _self.$container.stop(true, true).animate(css, {
          duration: options.duration,
          easing: options.easing,
          complete: function () {

            cleanAfterClose();

            isAnimating = false;
            isOpen = false;
            options.onAfterClose(_self);
          }
        });
      }
    };

    /**
     * @method BurgerMenu.reload
     * @description Reload the menu
     *
     */

    _self.reload = function () {

      clearTimeout(resize);
      resize = setTimeout(function () {
        var instantViewport = getViewportWidth();
        if (instantViewport !== viewportWidth) {

          // If the width has changed, the new width is stored and the greybox margin-top is adjusted.
          viewportWidth = instantViewport;

          _self.destroy();
          init();

        }

      }, (options._resizeTimeout * 1000));

    };

    /**
     * @method BurgerMenu.destroy
     * @description Destroy Burger Menu
     *
     */

    _self.destroy = function () {

      if (typeof options === 'object') {
        options.onAfterClose(_self);
      }

      if (typeof _self.$container !== 'undefined') {
        _self.$container.remove();
      }
      if (typeof _self.$overlay !== 'undefined') {
        _self.$overlay.remove();
      }
      if (typeof _self.$trigger !== 'undefined') {
        _self.$trigger.remove();
      }

      options = void 0;
      _self.$container = void 0;
      _self.$overlay = void 0;
      _self.$trigger = void 0;

      _self.structure = {};

      isAnimating = false;

      resize = void 0;

    };

    // Launching the initialization
    init();

    return _self;

  };

})(jQuery);

// Compare picture

// Prérequis: Modernizr doit être présent avec l'option Modernizr.touch activé pour les terminaux tactiles

(function ($) {

  $.fn.extend({

    /**
     * @function comparePicture
     *
     * @description Compare two superimposed photographs using a "ruler" that can be moved with the mouse and the touch.
     *
     * @param {(string)} before - Image to compare (ex : state before)
     * @param {(string)} after - Image of comparison which will adapt in width according to the position of the "ruler" (ex : state after)
     * @param {(string)} labelBefore - label for the before parameter
     * @param {(string)} labelAfter - label for the after parameter
     * @return {jQuery}
     */

    comparePicture: function (before, after, labelBefore, labelAfter) {

      // Object parameters
      var _self = this;
      var $imgBefore = before;
      var $imgAfter = after;
      var $labelBefore = labelBefore;
      var $labelAfter = labelAfter;

      // Global variables for positioning demo elements
      var $eltDemoAfter;
      var $eltDemoBefore;

      var _positionEltDemo;
      var _widthEltDemo;
      var _newWidth;
      var _deltaPosition;
      var _triggerX;
      var swipeOrigin = {
        x: 0,
        y: 0
      };

      // Building Demo HTML
      var buildDemo = function () {

        // Swipe construction
        var $overflow = $('<div />', {class: 'teaser-skin-result-demo--visual-after-overflow'});
        var $swipe = $('<div />', {class: 'teaser-skin-result-demo--swipe'});

        // Current images are wrapped to create the overlay effect
        $eltDemoBefore = $('<div />', {class: 'teaser-skin-result-demo--visual-before'}).append($imgBefore);
        $eltDemoAfter = $('<div />', {class: 'teaser-skin-result-demo--visual-after'}).append($overflow.append($imgAfter));

        // Building/Inserting image labels
        var $eltLabelBefore = $('<span />', {class: 'teaser-skin-result-demo--before'}).text($labelBefore);
        var $eltLabelAfter = $('<span />', {class: 'teaser-skin-result-demo--after'}).text($labelAfter);

        $swipe.append($eltLabelBefore).append($eltLabelAfter);
        $eltDemoAfter.append($swipe);
        _self.append($eltDemoAfter).append($eltDemoBefore);
      };

      // Initialization of the headphones to trigger the click function
      var init = function () {

        // Detect mousemove
        _self.bind('mousedown', function (e) {
          setSize(e);
          e.preventDefault();

          // At the mousemove we launch the setSize
          _self.bind('mousemove', function (e) {
            setSize(e);
            e.preventDefault();
          });
        });

        // End of mouseup calculation triggering
        _self.bind('mouseup', function (e) {
          setSize(e);
          _self.unbind('mousemove');
        });
      };

      // Initialising the headphones to trigger the touch function
      var initTouchEvents = function () {

        // Debug IE
        if (typeof window.navigator.msPointerEnabled !== 'undefined') {
          _self[0].addEventListener('MSPointerDown', swipeStart);
          _self[0].addEventListener('MSPointerMove', swipeMove);
          _self[0].addEventListener('MSPointerUp', swipeMove);
        }
        _self[0].addEventListener('touchstart', swipeStart, false);
        _self[0].addEventListener('touchmove', swipeMove, false);
        _self[0].addEventListener('touchend', swipeMove, false);
      };


      var swipeStart = function () {

        // If you touch with only 1 finger
        if (event.touches.length === 1) {

          var touch = event.touches[0];
          swipeOrigin.x = touch.pageX;
          swipeOrigin.y = touch.pageY;

          // The calculation of the size of the compared element is started
          setSize(event);
        }
      };

      var swipeMove = function () {

        // If you touch with only 1 finger
        if (event.touches.length === 1) {
          var touch = event.touches[0];

          // If you swipe more horizontally than vertically
          if (Math.abs(swipeOrigin.y - touch.pageY) < Math.abs(swipeOrigin.x - touch.pageX)) {

            // The calculation of the size of the compared element is started
            setSize(event);
            event.preventDefault();
          }
        }
      };

      // Calculation of the new size of the element compared according to the touchmove/mousemove
      var setSize = function (e) {
        _positionEltDemo = $(_self).offset().left;
        _widthEltDemo = parseFloat($(_self).css('width'));

        if (typeof Modernizr !== 'undefined' && typeof Modernizr.touch !== 'undefined' && Modernizr.touch) {
          _triggerX = e.changedTouches[0].pageX;
        }
        else {
          _triggerX = e.clientX;
        }

        if (!isNaN(_widthEltDemo)) {
          _deltaPosition = _triggerX - _positionEltDemo;

          // Calculating the ratio to define the new size
          _newWidth = (1 - (_deltaPosition / _widthEltDemo)) * 100;
          $eltDemoAfter.width(_newWidth + '%');
        }
      };

      // Add new HTML structure
      buildDemo();

      // Launching the initialization
      if (typeof Modernizr !== 'undefined' && typeof Modernizr.touch !== 'undefined' && Modernizr.touch) {
        initTouchEvents();
      }
      else {
        init();
      }

      return _self;
    }

  });

})(jQuery);

var Countdown;

(function ($) {

  /**
   * @typedef {object} Countdown_options
   * @description Possible configuration options of the Countdown class
   *
   * @property {date} deadline=null End date of the counter
   * @property {date} startTime=new Date() Counter start date
   * @property {function} callback=function(){} Callback triggered at every interval
   * @property {number} interval=1 Time remaining calculation interval (in seconds)
   *
   * */

  /**
   * @class Countdown
   * @description Counting system
   *
   * @param {Countdown_options} [cfg] Countdown configuration options
   *
   * @return {jQuery} this
   */

  Countdown = function (cfg) {

    // Security if cfg was not specified
    if (typeof cfg !== 'object') {
      cfg = {};
    }

    // default variables
    var defaults = {
      deadline: null,
      startTime: new Date(),
      callback: function () {
      },
      interval: 1 // in seconds
    };

    // Storing the object
    var _self = this;

    // Storage of the interval
    var intval;

    // Configuration
    var options = cfgManager(defaults, cfg);

    // Storage of time variables
    var oneSecond = 1000;
    var oneMinute = oneSecond * 60;
    var oneHour = oneMinute * 60;
    var oneDay = oneHour * 24;

    // Remaining time
    var remainingTime;

    // Initializing the counter and calculating the remaining time
    var init = function () {

      if (options.deadline instanceof Date && !isNaN(options.deadline.valueOf()) && options.startTime instanceof Date && !isNaN(options.startTime.valueOf())) {

        remainingTime = options.deadline.getTime() - options.startTime.getTime();
        start();
      }
    };

    // Meter start
    var start = function () {

      var exec = function () {
        var days = Math.floor(remainingTime / oneDay);
        var hours = Math.floor((remainingTime % oneDay) / oneHour);
        var minutes = Math.floor((remainingTime % oneHour) / oneMinute);
        var seconds = Math.floor((remainingTime % oneMinute) / oneSecond);

        var output = {
          days: days,
          hours: hours,
          minutes: minutes,
          seconds: seconds,
          milliseconds: (remainingTime % oneSecond)
        };

        options.callback(output);
      };

      intval = setInterval(function () {
        remainingTime -= options.interval * 1000;
        exec();
      }, (options.interval * 1000));
      exec();

      return _self;
    };

    // PUBLIC FUNCTIONS
    /**
     * @method Countdown.destroy
     * @description Destroy Countdown
     *
     */

    _self.destroy = function () {

      clearInterval(intval);

      return _self;
    };

    init();

    return _self;

  };

})(jQuery);

(function ($) {

  /**
   * @typedef {object} dropMenu_options_contexes
   *
   * @property {string} group='' - CSS rules for search groups containing sort + section
   * @property {string} trigger='' - CSS rules of the targeted trigger from the group triggering the opening of the section
   * @property {string} section='' - CSS rules of the targeted section from the group
   *
   * */

  /**
   * @typedef {object} dropMenu_options
   *
   * @property {array.<dropMenu_options_contexes>} contexes={} - Separate contexts from which we will look for the 3 elements of the DOM
   * @property {string} expandedClass='expanded' - CSS Class assigned to the group when the menu is open
   * @property {string} collapsedClass='collapsed' - CSS Class assigned to the group when the menu is closed
   * @property {string} enabledClass='drop-menu--enabled' - CSS Class assigned to the group when the 3 elements of the DOM have been identified and the "dropMenu" behavior is active
   * @property {string} overlayClass='drop-menu--overlay' - CSS Overlay class
   * @property {function} onBeforeExpand=function(id,_self){} - Callback triggered before opening
   * @property {function} onAfterExpand=function(){id,_self} - Callback triggered after opening
   * @property {function} onBeforeCollapse=function(){id,_self} - Callback triggered before closing
   * @property {function} onAfterCollapse=function(){id,_self} - Callback triggered after closing
   *
   * */

  /**
   * @typedef {object} dropMenu_output
   * @description Data returned by rsAccordion
   *
   * @property {jQuery} $groups - Storage of groups
   * @property {jQuery} $triggers - Trigger storage
   * @property {jQuery} $sections - Storage of sectionss
   * @property {array} expandedStatus - Status memory (expanded or not)
   * @property {array} $overlay - Background overlay
   *
   * */

  /**
   * @class external:"jQuery.fn".dropMenu
   *
   * @param {dropMenu_options} [cfg]
   *
   * @return {dropMenu_output}
   */

  $.fn.extend({

    dropMenu: function (cfg) {

      // Security if cfg has not been specified
      if (typeof cfg !== 'object') {
        cfg = {};
      }

      // Default variables
      var defaults = {
        // Options
        contexes: [{
          group: '',
          trigger: '',
          section: ''
        }],
        expandedClass: 'expanded',
        collapsedClass: 'collapsed',
        enabledClass: 'drop-menu--enabled',
        overlayClass: 'drop-menu--overlay',
        zIndex: 19,
        easing: 'easeInOutQuart',
        duration: typeof _duration !== 'undefined' ? _duration : 500,

        /** Events **/
        onBeforeExpand: function () {
        },
        onAfterExpand: function () {
        },
        onBeforeCollapse: function () {
        },
        onAfterCollapse: function () {
        }
      };

      // Storage of the object
      var _self = this;

      // Configuration
      var options;

      // Element storage
      _self.$groups = [];
      _self.$triggers = [];
      _self.$sections = [];

      // Status memory (expanded or not)
      _self.expandedStatus = [];

      // Body
      var $body = $('body');

      // PRIVATE FUNCTIONS
      // Drop menu initialization
      var init = function () {


        // Managing configuration options
        options = cfgManager(defaults, cfg);

        // Overlay construction
        _self.$overlay = $('<div />', {
          class: options.overlayClass,
          style: 'z-index:' + options.zIndex + ';'
        });

        // We go through all contexts
        var index = 0;
        $.each(options.contexes, function (i, contextCfg) {

          // We're picking up all the target groups
          var allGroups = $(contextCfg.group, _self);

          // Behaviour reporting
          allGroups.each(function (j, group) {

            var id = index;
            var $group = $(group);

            var $trigger = $(contextCfg.trigger, $group);
            var $section = $(contextCfg.section, $group);

            if ($trigger.length && $section.length) {

              _self.$groups[id] = $group;
              _self.$triggers[id] = $trigger;
              _self.$sections[id] = $section;
              _self.expandedStatus[id] = false;

              // We specify that the accordion behavior is active on this group
              $group.addClass(options.enabledClass).addClass(options.collapsedClass);
              $section.hide();

              var toggler = function () {

                // If the group is not open
                if ($group.hasClass(options.collapsedClass)) {
                  _self.expand(id);
                }
                // If the group is already open
                else if ($group.hasClass(options.expandedClass)) {
                  _self.collapse(id);
                }

                return false;
              };

              $trigger.click(toggler);

              index++;
            }
          });

        });

      };

      // Declaring a closed section
      var setGroupCollapsed = function (id) {

        _self.$groups[id].removeClass(options.expandedClass);
        _self.$groups[id].addClass(options.collapsedClass);
        _self.expandedStatus[id] = false;

      };

      // Declare a section open
      var setGroupExpanded = function (id) {

        _self.$groups[id].removeClass(options.collapsedClass);
        _self.$groups[id].addClass(options.expandedClass);
        _self.expandedStatus[id] = true;

      };

      // PUBLIC FUNCTIONS

      /**
       * @method external:"jQuery.fn".dropMenu.expand
       * @description Opening a menu section
       *
       * @param {number} id - Group ID to open
       */

      _self.expand = function (id) {

        if (!_self.$groups[id].hasClass(options.expandedClass)) {

          $.each(_self.expandedStatus, function (i, status) {
            if (status) {
              _self.collapse(i);
            }
          });

          setGroupExpanded(id);

          _self.$overlay.bind('click', function () {
            _self.collapse(id);
          });
          $body.append(_self.$overlay);

          if (_self.css('position') === 'static') {
            _self.css({position: 'relative'});
          }
          _self.css({'z-index': (options.zIndex + 1)});
          options.onBeforeExpand(id, _self);
          _self.$sections[id].stop(true, true).slideDown({
            easing: options.easing,
            duration: options.duration,
            complete: function () {
              options.onAfterExpand(id, _self);
            }
          });

        }

      };

      /**
       * @method external:"jQuery.fn".dropMenu.collapse
       * @description Closing a menu item
       *
       * @param {number} id - ID of the group to close
       */

      _self.collapse = function (id) {

        if (!_self.$groups[id].hasClass(options.collapsedClass)) {

          setGroupCollapsed(id);

          _self.$overlay.unbind('click');
          _self.$overlay.detach();

          _self.removeAttr('style');
          options.onBeforeCollapse(id, _self);
          _self.$sections[id].stop(true, true).slideUp({
            easing: options.easing,
            duration: options.duration,
            complete: function () {
              options.onAfterCollapse(id, _self);
            }
          });

        }

      };

      // Launching the initialization
      init();

      return _self;
    }

  });

})(jQuery);

// Dropdown Layer

(function ($) {

  $.fn.extend({

    /**
     * @typedef dropDownLayer_options
     * @description Configuration options of dropDownLayer
     *
     * @property {string} cssClass='dropdown-layer' - class to build the DropDown
     * @property {object} target={} - element to append the dropdown
     * @property {object} options={} - options to be added on the dropdown according DOM element
     */

    /**
     * @class external:"jQuery.fn".dropdownLayer
     * @description Add layer for dropdown menu or select
     *
     * @param {dropdownLayer_options} [cfg] - Configuration options
     *
     * @return {jQuery} this
     */

    dropDownLayer: function (cfg) {

      // Check if cfg is an object
      if (typeof cfg !== 'object') {
        cfg = {};
      }

      // Object parameters
      var defaults = {

        // Options
        cssClass: 'dropdown-layer',
        target: {},
        options: {}
      };

      // The object where the Wall will be attach
      var _self = this;

      // Item being read
      var hasBeenInitialized = false;

      // Future options
      var options;

      // Init tracker for rollover
      var $tracker;
      var trackerInitState;

      // Init dropdown
      var $dropDown;
      var $dropDownLayerOut;
      var $dropDownLayerContainer;
      var $dropDownLayerContainerInner;
      var $dropDownLayerContainerContent;

      var cssClassReset;
      var cssClassDropDown;
      var cssClassIsOpened;
      var cssClassLayerOut;
      var cssClassLayerContainer;
      var cssClassLayerContainerInner;
      var cssClassLayerContainerContent;
      var cssClassClose;
      var cssClassMaskTop;
      var cssClassMaskBottom;
      var cssClassTracker;
      var cssClassList;
      var cssClassItem;

      // Init btn close
      var $btnClose;

      // Init mask for scroll
      var $maskTop;
      var $maskBottom;

      // Init list for dropdown
      var $list ;

      // Init the object
      var init = function () {

        // Manage configuration options
        options = cfgManager();

        // Css class for future dropdown
        cssClassReset = options.cssClass + '--reset';
        cssClassDropDown = options.cssClass + '--dropdown';
        cssClassIsOpened = cssClassDropDown + '-is-opened';
        cssClassLayerOut = cssClassDropDown + '--layer-out';
        cssClassLayerContainer = cssClassDropDown + '--layer-container';
        cssClassLayerContainerInner = cssClassDropDown + '--layer-container--inner';
        cssClassLayerContainerContent = cssClassDropDown + '--layer-container--content';
        cssClassClose = cssClassDropDown + '--close';
        cssClassMaskTop = cssClassLayerContainer + '--mask-top';
        cssClassMaskBottom = cssClassLayerContainer + '--mask-bottom';
        cssClassTracker = cssClassDropDown + '--tracker';
        cssClassList = cssClassDropDown + '--list';
        cssClassItem = cssClassDropDown + '--item';

        // Detect if dropdown exists in the DOM
        var detectDropDown = $('body').find('.' + cssClassDropDown);
        if (detectDropDown.length) {
          hasBeenInitialized = true;
          _self.destroy();
        }

        // Build dropdown HTML
        buildDropDown(options.target, options.options);
      };

      // Clone an object
      var cloneObject = function (datas) {

        var output = {};
        $.each(datas, function (key, data) {
          output[key] = data;
        });

        return output;

      };

      // Manage configuration options
      var cfgManager = function () {

        var output = {};

        var clonedDefaults = cloneObject(defaults);
        output = $.extend(clonedDefaults, cfg);

        return output;
      };

      var buildDropDown = function (target, options) {

        // The dropdown already exists
        hasBeenInitialized = true;

        // Dropdown container
        $dropDown = $('<div />', {
          class: cssClassDropDown
        });

        $dropDownLayerOut = $('<div />', {
          class: cssClassLayerOut
        });
        $dropDown.append($dropDownLayerOut);
        $dropDownLayerOut.on('click', _self.close);

        $dropDownLayerContainer = $('<div />', {
          class: cssClassLayerContainer
        });
        $dropDown.append($dropDownLayerContainer);
        $dropDownLayerContainer.on('mousemove', function () {
          manageMask(event);
        });

        // Tracker
        $tracker = $('<span />', {
          class: cssClassTracker
        });
        trackerInitState = {
          top: $tracker.css('top'),
          height: $tracker.css('height'),
          opacity: $tracker.css('opacity'),
          marginTop: $tracker.css('margin-top')
        };

        // Close button
        $btnClose = $('<span />', {
          class: cssClassClose
        });
        $dropDownLayerContainer.append($btnClose);
        $btnClose.on('click', _self.close);

        // Mask for scroll
        $maskTop = $('<span />', {
          class: cssClassMaskTop
        });
        $dropDownLayerContainer.append($maskTop);

        $maskBottom = $('<span />', {
          class: cssClassMaskBottom
        });
        $dropDownLayerContainer.append($maskBottom);

        $dropDownLayerContainerInner = $('<div />', {
          class: cssClassLayerContainerInner
        });
        $dropDownLayerContainer.append($dropDownLayerContainerInner);

        $dropDownLayerContainerContent = $('<div />', {
          class: cssClassLayerContainerContent
        });
        $dropDownLayerContainerInner.append($dropDownLayerContainerContent);
        $dropDownLayerContainerInner.on('scroll', displayMask);

        // Add tracker for rollover
        $dropDownLayerContainerContent.append($tracker);

        $list = $('<ul />', {
          class: cssClassList
        });
        $dropDownLayerContainerContent.append($list);

        // Place option in dropdown
        options.each(function() {

          var $option = $(this);
          var $label = $option.text();
          if ($option.data('label')) {
            $label = $option.data('label');
          }
          else if ($option.prop('tagName') === 'INPUT') {
            var $optionLabel = $option.next('label');
            $label = $optionLabel.text();
          }
          var $dataValue = $option.attr('value');
          var $item = $('<li />', {
            class: cssClassItem,
            dataValue: $dataValue
          });
          $item.text($label);

          // Mouse events
          $item.on('mouseenter', manageHoverOption);
          $item.on('click', function () {
            activeOption($item, $option);
          });

          $list.append($item);
        });

        $list.on('mouseleave', manageSelectedOption);
        target.append($dropDown);
      };

      // Check content height of dropdown to allow scroll
      var checkContentHeight = function () {

        if ($dropDownLayerContainer.height() < $list.height()) {
          $dropDownLayerContainer.addClass('has-scrollbar');
        }
        else {
          $dropDownLayerContainer.removeClass('has-scrollbar');
        }
        $dropDownLayerContainerInner.trigger('scroll');
      };

      // Change position of tracker according selected element
      var placeTracker = function ($activeItem, opening) {

        if (typeof opening === 'undefined') {
          opening = false;
        }

        $tracker.css({
          top: $activeItem.offset().top - $dropDownLayerContainer.offset().top + $dropDownLayerContainerInner.scrollTop(),
          height: $activeItem.height() - 5,
          opacity: 1,
          marginTop: 0
        });

        if (opening) {
          $dropDownLayerContainerInner.scrollTop($activeItem.offset().top - $dropDownLayerContainer.offset().top - ($dropDownLayerContainer.height() - $activeItem.height()) / 2);
        }
      };

      // Manage position of mask according rollover
      var manageMask = function (event) {
        var posY = event.pageY - $tracker.offset().top;

        if (posY < $maskTop.height()) {
          $maskTop.addClass('is-hover');
        }
        else {
          $maskTop.removeClass('is-hover');
        }

        if (posY > $(this).height() - $maskBottom.height()) {
          $maskBottom.addClass('is-hover');
        }
        else {
          $maskBottom.removeClass('is-hover');
        }
      };

      var displayMask = function () {

        var $target = $(this);

        var height = $dropDownLayerContainerContent.outerHeight();
        var scrollTop = $target.scrollTop();
        var scrollBottom = height - scrollTop - $target.height();

        if (scrollTop === 0) {
          $maskTop.addClass('is-hidden');
        }
        else {
          $maskTop.removeClass('is-hidden');
        }
        if (scrollBottom === 0) {
          $maskBottom.addClass('is-hidden');
        }
        else {
          $maskBottom.removeClass('is-hidden');
        }
      };

      // Behavior for option on rollover
      var manageHoverOption = function () {

        var $target = $(this);

        $target.addClass('is-active').siblings().removeClass('is-active');
        placeTracker($target);
      };

      // Behavior for option on selected action
      var manageSelectedOption = function () {

        var $selectedOption = $('.' + cssClassItem + '.is-selected', $dropDownLayerContainer);
        $dropDownLayerContainer.find('.is-active').removeClass('is-active');

        if ($selectedOption.length) {
          $selectedOption.addClass('is-active');
          placeTracker($selectedOption);
        }
        else {
          $tracker.css(trackerInitState);
        }

        $maskTop.removeClass('is-hover');
        $maskBottom.removeClass('is-hover');
      };

      // Manage active class
      var manageActiveStatus = function (dropDownItem) {

        var $target = dropDownItem;
        $target.siblings('.is-active').removeClass('is-active');
        $target.siblings('.is-selected').removeClass('is-selected');
        $target.addClass('is-active is-selected');
        manageSelectedOption();
      };

      // Active option
      var activeOption = function (dropDownItem, originalItem) {

        var $target = dropDownItem;
        var $referer = originalItem;

        // Item of the dropDown list
        manageActiveStatus($target);

        // Item in the original DOM to update
        if ($referer.prop('tagName') === 'INPUT' || $referer.prop('tagName') === 'OPTION') {

          if ($referer.prop('tagName') === 'INPUT') {
            $referer.prop('checked', true);
          }

          if ($referer.prop('tagName') === 'OPTION') {
            $referer.siblings().prop('selected', false);
            $referer.prop('selected', true);
          }

          $referer.trigger('change');
        }
        else {
          $referer.addClass('is-selected');
          $referer.siblings('.is-selected').removeClass('is-selected');
        }

        _self.close();
      };

      /**
       * @method external:"jQuery.fn".dropDownLayer.updateReferer
       * @description Update active status for item in DropDown according its data value
       *
       * @return {jQuery} this
       */
      _self.updateReferer = function (dataValue) {

        var $itemToUpdate = $list.find('[datavalue='+ dataValue + ']');
        if ($itemToUpdate.length) {
          manageActiveStatus($itemToUpdate);
        }
      };

      /**
       * @method external:"jQuery.fn".dropDownLayer.clear
       * @description Clear all filters
       *
       * @return {jQuery} this
       */
      _self.clear = function () {
        $list.find('.is-selected, .is-active').removeClass('is-selected, is-active');
        $tracker.css(trackerInitState);
      };

      /**
       * @method external:"jQuery.fn".dropDownLayer.open
       * @description Open the DropDown
       *
       * @return {jQuery} this
       */
      _self.open = function () {
        $('html').addClass(cssClassIsOpened);

        // Check for scroll
        checkContentHeight();

        // Place tracker
        var $selectedItem = $('.' + cssClassItem + '.is-selected');
        if ($selectedItem.length) {
          setTimeout(function () {
            placeTracker($selectedItem, true);
          }, 0);
        }
        else {
          $tracker.css(trackerInitState);
        }
      };

      /**
       * @method external:"jQuery.fn".dropDownLayer.close
       * @description Close the DropDown
       *
       * @return {jQuery} this
       */
      _self.close = function () {
        $('html').removeClass(cssClassIsOpened);
      };

      /**
       * @method external:"jQuery.fn".dropDownLayer.reload
       * @description Rebuild the slider
       */
      _self.reload = function () {

        _self.destroy();
        buildDropDown();

      };

      /**
       * @method external:"jQuery.fn".dropDownLayer.destroy
       * @description Destruction of the slider
       */
      _self.destroy = function () {

        if (hasBeenInitialized) {

          // Stopping animations
          _self.stop(true, true);

          // Remove created dropdown
          $('body').find('.' + cssClassDropDown).remove();
        }
      };

      // Launch dropdown
      init();

      return _self;
    }

  });

})(jQuery);


var Greybox;

(function ($) {

  /**
   * @typedef Greybox_options
   * @description Greybox configuration options
   *
   * @property {string} prefix=greybox - Prefix CSS of the greybox
   * @property {number} duration=_duration|500 - Duration of animation (in miliseconds)
   * @property {number} top=50 - Offset top to the top edge of the browser
   * @property {string} close='' - HTML content of div.close
   * @property {string} cssClass='' - Additional CSS Class
   * @property {string} title='' - Greybox title
   * @property {function} onBeforeOpen=function(){} - Callback before opening the greybox
   * @property {function} onAfterOpen=function(){} - Callback after opening the greybox
   * @property {function} onBeforeClose=function(){} - Callback before closing the greybox
   * @property {function} onAfterClose=function(){} - Callback after closing the greybox
   */

  /**
   * @typedef Greybox_output
   * @description Data returned by Greybox class
   *
   * @property {object} config - Configuration in progress
   * @property {jQuery} $greybox - DOM elt
   * @property {object} $overlay - DOM elt
   * @property {object} $container - DOM elt
   * @property {object} $content - DOM elt
   * @property {object} $title - DOM elt
   * @property {object} $close - DOM elt
   * @property {object} $iframe - DOM elt
   * @property {object} $youtube - DOM elt
   * @property {object} $dailymotion - DOM elt
   * @property {object} $vimeo - DOM elt
   * @property {object} $image - DOM elt
   */

  /**
   * @class Greybox
   * @description Popin management system
   *
   * @param {Greybox_options} [cfg] - Configuration options
   *
   * @return {jQuery} this
   */

  Greybox = function (cfg) {

    // Security if cfg has not been specified
    if (typeof cfg !== 'object') {
      cfg = {};
    }

    // Default variables
    var defaults = {
      prefix: 'greybox',
      duration: (typeof _duration === 'number') ? _duration : 500,
      close: '',
      title: '',
      cssClass: '',

      /** Events **/
      onBeforeOpen: function () {
      },
      onAfterOpen: function () {
      },
      onBeforeClose: function () {
      },
      onAfterClose: function () {
      }
    };

    // Storage of the object
    var _self = this;

    // Configuration
    _self.config = {};

    // Memorization of the elements of the DOM
    var $document = $(document);

    // Declaration of special items
    _self.$greybox = null;
    _self.$overlay = null;
    _self.$container = null;
    _self.$content = null;
    _self.$title = null;
    _self.$close = null;
    _self.$iframe = null;
    _self.$youtube = null;
    _self.$dailymotion = null;
    _self.$vimeo = null;
    _self.$image = null;

    // We declare the setTimeout of image loading
    var imageLoaded;

    // We declare the setTimeout of the resize application
    var resize;

    // Waiting time after the resize before triggering the function (avoid triggering each size change)
    var resizeTimeout = 0.25;

    // Previously calculated viewport width
    var viewportWidth = null;

    // PRIVATE FUNCTIONS
    // Initialization of the Greybox
    var init = function () {

      viewportWidth = getViewportWidth();

      // Resize detection
      $(window).bind('resize', onResize);

      // Creation of the DOM elements
      _self.$greybox = $('<div />').hide();
      _self.$overlay = $('<div />').hide();
      _self.$container = $('<div />').hide();
      _self.$content = $('<div />');
      _self.$title = $('<div />');
      _self.$close = $('<div />');

      _self.$iframe = $('<iframe class="" src="" border="0" frameborder="0" width="100%" height="" allowTransparency="true" allowfullscreen></iframe>');
      _self.$youtube = $('<iframe class="" style="width:100%;" width="100%" height="" src="" frameborder="0" allowfullscreen></iframe>');
      _self.$dailymotion = $('<iframe class="" style="width:100%;" frameborder="0" width="100%" height="" src="" allowTransparency="true" allowfullscreen></iframe>');
      _self.$vimeo = $('<iframe class="" style="width:100%;" src="" width="100%" height="" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>');

      // Apply the requested configuration
      _self.setConfig(cfg);

      // HTML Structuring
      _self.$greybox.append(_self.$overlay);
      _self.$container.append(_self.$title);
      _self.$container.append(_self.$content);
      _self.$container.append(_self.$close);
      _self.$greybox.append(_self.$container);

      // Event Management
      _self.$close.click(function () {
        _self.close();
      });
      _self.$overlay.click(function () {
        _self.close();
      });

    };

    // Adjust the margin-top if the greybox is in absolute position
    var adjustTopIfAbsolute = function () {

      if (_self.$container.css('position') === 'absolute') {
        _self.$container.css({'margin-top': $document.scrollTop()});
      }
      else {
        _self.$container.css({'margin-top': 'inherit'});
      }

    };

    // Function to be executed at the resize of the browser (or orientation-changed)
    var onResize = function () {

      clearTimeout(resize);
      resize = setTimeout(function () {

        var instantViewport = getViewportWidth();
        if (instantViewport !== viewportWidth) {
          // If the width has changed, the new width is stored and the greybox margin-top is adjusted.
          viewportWidth = instantViewport;
          adjustTopIfAbsolute();
        }

      }, (resizeTimeout * 1000));

    };

    // PUBLIC FUNCTIONS

    /**
     * @method Greybox.setConfig
     * @description Resume the default configuration and apply the new
     *
     * @param {Greybox_options} config - Config
     *
     * @return {Greybox_options}
     */

    _self.setConfig = function (config) {

      _self.config = cfgManager(defaults, config);

      _self.setPrefix(_self.config.prefix);
      _self.setClass(_self.config.cssClass);
      _self.setCloseText(_self.config.close);
      _self.setTitle(_self.config.title);

      return _self.config;
    };

    /**
     * @method Greybox.getConfig
     * @description Returns the current configuration
     *
     * @return {Greybox_options}
     */

    _self.getConfig = function () {

      return _self.config;
    };

    /**
     * @method Greybox.open
     * @description Open the greybox
     *
     * @param {function} callback - Callback
     *
     * @return {this}
     */

    _self.open = function (callback) {

      if (typeof callback === 'undefined') {
        callback = function () {
        };
      }

      // Insertion in the DOM
      $('body').append(_self.$greybox);

      _self.config.onBeforeOpen(_self);

      // Preparation of the elements
      _self.$container.hide();
      _self.$overlay.hide();
      _self.$greybox.show();

      adjustTopIfAbsolute();

      // Animation
      _self.$overlay.stop(true, true).fadeIn({
        duration: _self.config.duration / 2,
        complete: function () {

          _self.$container.stop(true, true).fadeIn({
            duration: _self.config.duration / 2,
            complete: function () {

              // Complete
              callback();
              _self.config.onAfterOpen(_self);

            }
          });

        }
      });

      return _self;
    };

    /**
     * @method Greybox.close
     * @description Close the greybox
     *
     * @param {function} [callback] - Callback
     *
     * @return {this}
     */

    _self.close = function (callback) {

      if (typeof callback === 'undefined') {
        callback = function () {
        };
      }

      _self.config.onBeforeClose(_self);

      // Animation
      _self.$container.stop(true, true).fadeOut({
        duration: _self.config.duration / 2,
        complete: function () {

          _self.$overlay.stop(true, true).fadeOut({
            duration: _self.config.duration / 2,
            complete: function () {

              // Complete
              _self.$greybox.hide().detach();
              _self.config.onAfterClose(_self);
              callback();
              _self.$content.empty();

            }
          });

        }
      });

      return _self;
    };

    /**
     * @method Greybox.setPrefix
     * @description Modify the CSS prefix of the greybox
     *
     * @return {this}
     */

    _self.setPrefix = function (prefix) {

      _self.$greybox.attr('class', prefix);
      _self.$overlay.attr('class', prefix + '--overlay');
      _self.$container.attr('class', prefix + '--container');
      _self.$content.attr('class', prefix + '--content clearfix');
      _self.$title.attr('class', prefix + '--title');
      _self.$close.attr('class', prefix + '--close');
      _self.$iframe.attr('class', prefix + '--iframe');
      _self.$youtube.attr('class', prefix + '--iframe ' + prefix + '--youtube');
      _self.$dailymotion.attr('class', prefix + '--iframe ' + prefix + '--dailymotion');
      _self.$vimeo.attr('class', prefix + '--iframe ' + prefix + '--vimeo');

      return _self;
    };

    /**
     * @method Greybox.setCloseText
     * @description Insert text (or html) content in the close button
     *
     * @param {string} html - Content
     *
     * @return {this}
     */

    _self.setCloseText = function (html) {

      _self.$close.html(html);

      return _self;
    };

    /**
     * @method Greybox.setClass
     * @description Apply CSS class to $greybox
     *
     * @param {string} cssClass - CSS Class
     *
     * @return {this}
     */

    _self.setClass = function (cssClass) {

      _self.$greybox.addClass(cssClass);

      return _self;
    };

    /**
     * @method Greybox.unsetClass
     * @description Delete a CSS class at $greybox
     *
     * @param {string} cssClass - CSS Class
     *
     * @return {this}
     */

    _self.unsetClass = function (cssClass) {

      _self.$greybox.removeClass(cssClass);

      return _self;
    };

    /**
     * @method Greybox.setLoading
     * @description Indicates that the greybox is charging
     *
     * @return {this}
     */

    _self.setLoading = function () {

      _self.$greybox.addClass(_self.config.prefix + '--loading');

      return _self;
    };

    /**
     * @method Greybox.unsetLoading
     * @description Remove the charging indicator from the greybox
     *
     * @return {this}
     */

    _self.unsetLoading = function () {

      _self.$greybox.removeClass(_self.config.prefix + '--loading');

      return _self;
    };

    /**
     * @method Greybox.html
     * @description Insert HTML in the greybox
     *
     * @param {string} html - HTML content
     * @param {function} callback - Callback
     *
     * @return {this}
     */

    _self.html = function (html, callback) {

      if (typeof callback === 'undefined') {
        callback = function () {
        };
      }

      _self.$content.prepend(html);
      _self.open(callback);

      return _self;
    };

    /**
     * @method Greybox.setTitle
     * @description Insert a title in the greybox
     *
     * @param {string} html - Title content
     *
     * @return {this}
     */

    _self.setTitle = function (html) {

      if (html === '') {
        _self.$title.empty().detach();
      }
      else {
        _self.$title.html(html).insertBefore(_self.$content);
      }

      return _self;
    };

    /**
     * @method Greybox.iframe
     * @description Displaying an iframe
     *
     * @param {string} src - URL of the iframe
     * @param {number} height - Height of the iframe
     * @param {function} callback - Callback
     *
     * @return {this}
     */

    _self.iframe = function (src, height, callback) {

      if (typeof height === 'undefined' || height === null) {
        height = 400;
      }

      if (typeof callback === 'undefined') {
        callback = function () {
        };
      }

      _self.$iframe.detach();
      _self.$iframe.attr({
        src: src,
        height: height
      });
      _self.$content.prepend(_self.$iframe);
      _self.open(callback);

      return _self;
    };

    /**
     * @method Greybox.youtube
     * @description View a Youtube video
     *
     * @param {string} src - Youtube video code
     * @param {number} height - Video height
     * @param {function} callback - Callback
     *
     * @return {this}
     */

    _self.youtube = function (src, height, callback) {

      if (typeof height === 'undefined' || height === null) {
        height = 400;
      }

      if (typeof callback === 'undefined') {
        callback = function () {
        };
      }

      src = '//www.youtube.com/embed/' + src + '?rel=0&wmode=transparent';
      _self.$youtube.detach();
      _self.$youtube.attr({
        src: src,
        height: height
      });
      _self.$content.prepend(_self.$youtube);
      _self.open(callback);

      return _self;
    };

    /**
     * @method Greybox.dailymotion
     * @description View a video dailymotion
     *
     * @param {string} src - Video code dailymotion
     * @param {number} height - Video height
     * @param {function} callback - Callback
     *
     * @return {this}
     */

    _self.dailymotion = function (src, height, callback) {

      if (typeof height === 'undefined' || height === null) {
        height = 400;
      }

      if (typeof callback === 'undefined') {
        callback = function () {
        };
      }

      src = '//www.dailymotion.com/embed/video/' + src;
      _self.$dailymotion.detach();
      _self.$dailymotion.attr({
        src: src,
        height: height
      });
      _self.$content.prepend(_self.$dailymotion);
      _self.open(callback);

      return _self;
    };

    /**
     * @method Greybox.vimeo
     * @description View a vimeo video
     *
     * @param {string} src - Vimeo video code
     * @param {number} height - Video height
     * @param {function} callback - Callback
     *
     * @return {this}
     */

    _self.vimeo = function (src, height, callback) {

      if (typeof height === 'undefined' || height === null) {
        height = 400;
      }

      if (typeof callback === 'undefined') {
        callback = function () {
        };
      }

      src = '//player.vimeo.com/video/' + src;
      _self.$vimeo.detach();
      _self.$vimeo.attr({
        src: src,
        height: height
      });
      _self.$content.prepend(_self.$vimeo);
      _self.open(callback);

      return _self;
    };

    /**
     * @method Greybox.ajaxGet
     * @description Load GET content in AJAX
     *
     * @param {string} url - Request URL
     * @param {number} [params] - Parameters to pass
     * @param {function} [callback] - Callback at the end of ajax loading
     *
     * @return {this}
     */

    _self.ajaxGet = function (url, params, callback) {

      _self.open().setLoading();

      var jqParams = {
        type: 'get',
        url: url,
        complete: function (data) {

          _self.unsetLoading();
          _self.$content.prepend(data.responseText);

          if (typeof callback === 'function') {
            callback(_self, url, data);
          }
        }
      };

      if (typeof params === 'object') {
        jqParams.data = params;
      }

      $.ajax(jqParams);

      return _self;
    };

    /**
     * @method Greybox.ajaxPost
     * @description Load POST content to AJAX
     *
     * @param {string} url - Request URL
     * @param {number} [params] - Parameters to pass
     * @param {function} [callback] - Callback at the end of ajax loading
     *
     * @return {this}
     */

    _self.ajaxPost = function (url, params, callback) {

      _self.open().setLoading();

      var jqParams = {
        type: 'post',
        url: url,
        complete: function (data) {

          _self.unsetLoading();
          _self.$content.prepend(data.responseText);

          if (typeof callback === 'function') {
            callback(_self, url, data);
          }
        }
      };

      if (typeof params === 'object') {
        jqParams.data = params;
      }

      $.ajax(jqParams);

      return _self;
    };

    /**
     * @method Greybox.image
     * @description Upload an image
     *
     * @param {string} src - Image URL
     * @param {function} [callback] - Callback at the end of ajax loading
     *
     * @return {this}
     */

    _self.image = function (src, callback) {

      if (typeof imageLoaded !== 'undefined') {
        clearInterval(imageLoaded);
      }

      _self.open().setLoading();

      if (_self.$image !== null) {
        _self.$image.remove();
      }

      _self.$image = $('<img />', {
        src: '' + src,
        alt: '',
        class: _self.config.prefix + '--image'
      }).hide();
      _self.$content.prepend(_self.$image);

      // Management of the complete
      var complete = function () {
        _self.$image.fadeIn(_self.config.duration);
      };
      if (typeof callback === 'function') {
        complete = callback;
      }

      imageLoaded = setInterval(function () {

        if (_self.$image[0].complete) {

          clearInterval(imageLoaded);

          _self.unsetLoading();
          complete(_self, _self.$image, src);
        }

      }, 50);

      return _self;
    };

    // Launching the initialization
    init();

    return _self;

  };

})(jQuery);

// responsive slider

// Prerequisites: The slider must be formatted before applying the script. The
// script is based on the observed sizes. Prerequisite: The slider and his
// direct children must not have an attribute "style". Prerequisite: Modernizr
// must be present with Modernizr.touch option enabled for touch terminals.

(function ($) {

  $.fn.extend({

    // Store native or calculated percentage values
    responsiveSliderMemorizeOffset: function (value) {

      if (typeof this[0].sliderResponsive === 'undefined') {
        this[0].sliderResponsive = {};
      }
      this[0].sliderResponsive.offset = value;

      return this;
    },

    // Read native or calculated percentage values
    responsiveSliderReadOffset: function () {

      var value;
      if (typeof this[0].sliderResponsive.offset !== 'undefined') {
        value = this[0].sliderResponsive.offset;
      }

      return value;
    },

    // Store native or calculated percentage values
    responsiveSliderMemorizeData: function (type, value) {

      if (typeof this[0].sliderResponsive === 'undefined') {
        this[0].sliderResponsive = {};
      }
      this[0].sliderResponsive[type] = value;

      return this;
    },

    // Read native or calculated percentage values
    responsiveSliderReadData: function (type) {

      var value;
      if (typeof this[0].sliderResponsive !== 'undefined' && typeof this[0].sliderResponsive[type] !== 'undefined') {
        value = this[0].sliderResponsive[type];
      }

      return value;
    },

    // Store forced slider height
    responsiveSliderMemorizeSliderAdaptativeHeight: function (value) {

      if (typeof this[0].sliderResponsive === 'undefined') {
        this[0].sliderResponsive = {};
      }
      this[0].sliderResponsive.adaptativeHeight = value;

      return this;
    },

    // Read forced slider height
    responsiveSliderReadSliderAdaptativeHeight: function () {

      var value;
      if (typeof this[0].sliderResponsive.adaptativeHeight !== 'undefined') {
        value = this[0].sliderResponsive.adaptativeHeight;
      }

      return value;
    },

    // Reset the forced slider height to zero
    responsiveSliderResetSliderAdaptativeHeight: function () {

      if (typeof this[0].sliderResponsive === 'undefined') {
        this[0].sliderResponsive = {};
      }
      if (typeof this[0].sliderResponsive.adaptativeHeight !== 'undefined') {
        this[0].sliderResponsive.adaptativeHeight = void 0;
      }

      return this;
    },

    // Neutralize the visible dimension of an item
    responsiveSliderNeutralizeItemSize: function () {

      this.css({
        height: '1px',
        visibility: 'hidden'
      });

      return this;
    },

    // Deactivate the neutralization of the visible dimension of an item
    responsiveSliderRecoverItemSize: function () {

      this.css({
        height: 'auto',
        visibility: 'visible'
      });

      return this;
    },

    // Check if an element or one of its parents is hidden or not
    checkHidden: function () {

      var output = false;

      if (this.css('display') === 'none') {
        output = true;
      }
      this.parents().each(function () {
        if ($(this).css('display') === 'none') {
          output = true;
        }
      });

      return output;
    },

    /**
     * @function responsiveSlider_pager_fn
     * @param {object} this - Object insignSlider
     * @param {jQuery} $prev - Previous button
     * @param {jQuery} $next - Next button
     * @param {jQuery} $dotsHolder - DOM elt with pagination
     */

    /**
     * @typedef {object} responsiveSlider_options - Configuration options for
     *   responsiveSlider
     * @property {boolean} bypass=false - Short circuit the trigger of the
     *   slider or not
     * @property {fade|slide|flex} mode=slide - Slider scrolling mode
     * @property {boolean} allow loop on slider
     * @property {string} cssPrefix=responsive-slider - CSS prefix of generated
     *   classes
     * @property {boolean|responsiveSlider_pager_fn} pager=true - Insert or not
     *   the pagination (insert after the default target element) | Custom
     *   function
     * @property {number} sliderRange=1 - Number of items to scroll (If
     *   mode='fade', sliderRange is forced to 1)
     * @property {boolean} fitSlides=false - Adjust the last slides to the
     *   right edge
     * @property {boolean} adaptativeHeight=true - Adjust the height to the
     *   largest visible height
     * @property {number} duration=500 - Duration of animation between 2 slides
     *   (in milliseconds)
     * @property {number} delay=0 - Delays to start animation between 2 slides
     *   (in milliseconds)
     * @property {string} easing=null - Type of animation jQuery easing
     * @property {string} classCurrent=current - CSS class name of a current
     *   item
     * @property {string} classDisabled=off - CSS class name of a disabled item
     * @property {boolean} autoPlay=false - Enabling Auto Scroll
     * @property {number} autoPlayDuration=5 - Time between each auto scroll
     *   (in seconds)
     * @property {boolean} resumeAutoPlay=true - Auto scroll reactivation after
     *   a stop
     * @property {number} resumeAutoPlayDuration=5 - Time before auto scroll
     *   reactivation (in seconds)
     * @property {object.<responsiveSlider_options>} responsive - Objet jSON
     * whose key is the break point, and the value a jSON Object
     * redefining the slider configuration
     * for a screen size lower or equal (desktop first)
     */

    /**
     * @class external:"jQuery.fn".responsiveSlider
     * @description Calculate a width as a percentage
     *
     * @param {responsiveSlider_options} [cfg] - Slider configuration options
     *
     * @return {jQuery}
     */

    responsiveSlider: function (cfg) {

      var defaults = {
        // Options
        bypass: false,
        mode: 'slide',
        loop: false,
        cssPrefix: 'responsive-slider',
        pager: true,
        sliderRange: 1,
        fitSlides: false,
        adaptativeHeight: true,
        duration: typeof _duration !== 'undefined' ? _duration : 500,
        delay: 0,
        easing: null,
        startingIndex: null,
        classCurrent: 'current',
        classDisabled: 'off',
        responsive: {},
        autoPlay: false,
        autoPlayDuration: 5,
        resumeAutoPlay: true,
        resumeAutoPlayDuration: 5,

        /** Methods **/
        onBeforeSlide: function () {
        },
        onAfterSlide: function () {
        },

        /** Private configuration **/
        // _round: Number of digits after the decimal point
        _round: Math.pow(10, 4),
        // _resizeTimeout: Time, in seconds, to recalculate the slider to the
        // resize
        _resizeTimeout: 0.25,
        // _offsetTrigger: Width, in pixels, beyond which the swipe/slide is
        // activated
        _offsetTrigger: 20
      };

      // Storage of the object
      var _self = this;

      // Item being read
      var hasBeenInitialized = false;

      // Item being read
      var _current = 0;
      var _currentDot;
      var _previous;
      // var _previousDot;

      // Future final configuration options
      var options;

      // We declare the setTimeout of the resize application
      var resize;

      // We declare the setInterval of auto scrolling
      var autoPlay;

      // We declare the setTimeout to resume auto scrolling
      var resumeAutoPlay;

      // We memorize the width of the viewport at each reset of the slider
      var viewportWidth;

      // Swipe origin reference
      var swipeOrigin = {
        x: 0,
        y: 0
      };

      // Was the swipe horizontal?
      var swipeAxisX = false;

      // We declare a wrapper for the slider
      var $wrapper;

      // Pagination Elements
      var $prev;
      var $next;
      var $dotsHolder;
      var $dots;

      // Direct children
      var $children;

      // We memorize the first and last slide of the slider
      // var slideFirst;
      var slideLast;

      // PRIVATE FUNCTIONS
      // Initialization of the slider
      var init = function () {

        // Slide in progress: 0
        _current = 0;
        _currentDot = void 0;
        _previous = void 0;
        // _previousDot = void 0;
        options = void 0;
        resize = void 0;
        autoPlay = void 0;
        resumeAutoPlay = void 0;
        viewportWidth = void 0;
        // slideFirst = void 0;
        slideLast = void 0;
        _self.responsiveSliderResetSliderAdaptativeHeight();

        if (typeof window.navigator.msPointerEnabled !== 'undefined') {
          _self[0].removeEventListener('MSPointerDown', swipeStart);
          _self[0].removeEventListener('MSPointerMove', swipeMove);
          _self[0].removeEventListener('MSPointerUp', swipeEnd);
        }
        _self[0].removeEventListener('touchstart', swipeStart);
        _self[0].removeEventListener('touchmove', swipeMove);
        _self[0].removeEventListener('touchend', swipeEnd);

        // Managing configuration options
        options = cfgManager(defaults, cfg);

        // We force sliderRange to 1 if we are in fade mode
        if (options.mode === 'fade') {
          options.sliderRange = 1;
        }

        // Memorizing the size of the viewport
        viewportWidth = getViewportWidth();

        // Resize detection
        $(window).bind('resize', _self.reloadSlider);

        // If you don't want to bypass activation
        if (!options.bypass) {

          // We'll look for the direct children
          $children = $('> *', _self);

          // We check that the slider is not hidden
          var trigger = _self.checkHidden();

          // We check that the number of slides is much higher than the number
          // to slider
          if ($children.length > options.sliderRange && !trigger) {

            // We specify that the slider has been initialized at least once
            hasBeenInitialized = true;

            // Touch events for touch terminals
            if
            (
              typeof Modernizr !== 'undefined' &&
              (
                (typeof Modernizr.touch !== 'undefined' && Modernizr.touch) ||
                (typeof Modernizr.touchevents !== 'undefined' && Modernizr.touchevents)
              ) &&
              (
                options.mode === 'slide' ||
                options.mode === 'flex'
              )
            ) {
              initTouchEvents();
            }

            // We declare a wrapper for the slider
            $wrapper = $('<div />', {
              class: options.cssPrefix + '--wrapper',
              style: 'overflow:hidden;'
            });

            // CSS style on the slider
            _self.css({
              overflow: 'hidden',
              position: 'relative'
            });

            // The native width is stored
            var selfWidth = _self.widthPercentage();
            _self.responsiveSliderMemorizeData('native', selfWidth);

            // Initialization conditioned to "slide" or "fade" mode
            switch (options.mode) {
              case 'fade':
                // Fade or flex mode
                initModeFade();

                break;
              // "slide" or "flex" Case
              default:
                // Slide mode
                initModeSlide();

                break;
            }

            // Construction of the pagination
            buildPager();

            // Auto Scroll
            if (options.autoPlay) {
              _self.startAutoPlay();
            }

          }
        }
      };

      // Finalization of initialization in SLIDE mode
      var initModeFade = function () {

        // Wrapping
        _self.wrap($wrapper);

        // The following are masked
        $children.filter(':nth-child(n+2)').css({
          width: '100%',
          position: 'absolute',
          left: '0',
          top: '0',
          display: 'none'
        });

      };

      // Finalization of initialization in SLIDE mode
      var initModeSlide = function () {

        // The native width is stored
        var selfWidth = _self.widthPercentage();
        _self.responsiveSliderMemorizeData('native', selfWidth);

        // Storage of the width in percentage
        var totalWidth = 0;
        $children.each(function () {
          var $elt = $(this);
          var width = $elt.widthPercentage();

          $elt.responsiveSliderMemorizeData('native', width);
          $elt.responsiveSliderMemorizeOffset(totalWidth);
          $elt.responsiveSliderMemorizeData('offset-visible', totalWidth);

          totalWidth += width;
        });

        // The calculated slider width is stored
        _self.responsiveSliderMemorizeData('relative', totalWidth);

        // Wrapping
        $wrapper.css('width', _self.responsiveSliderReadData('native') + '%');
        _self.wrap($wrapper);

        // Application of slider width
        _self.css('width', totalWidth + '%');
        if (options.mode === 'flex') {
          _self.attr('style', _self.attr('style') + ' display: -ms-flexbox; display: flex;');
        }

        // Rescaling the slides to the right scale
        $children.each(function () {
          var $elt = $(this);
          var relativeWidth = Math.round((($elt.responsiveSliderReadData('native') * 100) / totalWidth) * options._round) / options._round;

          $elt.responsiveSliderMemorizeData('relative', relativeWidth);

          if (options.mode === 'slide') {
            $elt.css({
              float: 'left',
              clear: 'none',
              width: relativeWidth + '%'
            });
          }
          else if (options.mode === 'flex') {
            $elt.css({
              width: relativeWidth + '%'
            });
          }

          // Starting index for slider mode
          if (options.startingIndex !== null) {
            _self.css('left', - (_self.responsiveSliderReadData('native') * options.startingIndex) + '%');
          }
        });

        // If you want to adjust the last slides
        if (options.fitSlides) {

          var maxLeft = Math.abs(100 - _self.responsiveSliderReadData('relative'));
          var maxLeftRounded = Math.abs(100 - Math.round(_self.responsiveSliderReadData('relative')));

          var isOutOfRange = false;
          $children.each(function () {
            var $elt = $(this);

            var offset = Math.round($elt.responsiveSliderReadOffset());

            if (isOutOfRange) {
              $elt.responsiveSliderMemorizeData('isOutOfRange', true);
            }

            if (offset >= maxLeftRounded) {
              $elt.responsiveSliderMemorizeOffset(maxLeft);

              // It is indicated that this is the last element to be achieved
              if (!isOutOfRange) {
                $elt.responsiveSliderMemorizeData('isLast', true);
              }

              isOutOfRange = true;
            }
          });
        }
        else {
          $children.each(function () {
            var $elt = $(this);

            $elt.responsiveSliderMemorizeData('isOutOfRange', false);
            $elt.responsiveSliderMemorizeData('isLast', false);
          });
        }

        // Hide undisplayed slides
        var slidesOut = _self.getSlidesOut();
        if (options.adaptativeHeight) {
          slidesOut.responsiveSliderNeutralizeItemSize();
        }

      };

      // Managing configuration options
      var initTouchEvents = function () {

        if (typeof window.navigator.msPointerEnabled !== 'undefined') {
          _self[0].addEventListener('MSPointerDown', swipeStart, false);
          _self[0].addEventListener('MSPointerMove', swipeMove, false);
          _self[0].addEventListener('MSPointerUp', swipeEnd, false);
        }
        _self[0].addEventListener('touchstart', swipeStart, false);
        _self[0].addEventListener('touchmove', swipeMove, false);
        _self[0].addEventListener('touchend', swipeEnd, false);

      };

      // Construction of the pagination
      var buildPager = function () {

        // Pagination Elements
        $prev = $('<div />', {
          class: options.cssPrefix + '--pager-prev'
        });
        $next = $('<div />', {
          class: options.cssPrefix + '--pager-next'
        });
        $dotsHolder = $('<ul />', {
          class: options.cssPrefix + '--pager-dots'
        });

        // The previous button is disabled by default
        if (!options.loop && options.startingIndex === null) {
          $prev.addClass(options.classDisabled);
        }

        // Click management
        $prev.click(_self.prevSlide);
        $next.click(_self.nextSlide);

        var indexLast = 0;
        $children.each(function (i) {
          var $elt = $(this);

          // Creation of the DOM element
          var $dot = $('<li />', {
            class: options.cssPrefix + '--pager-dot'
          });

          if (options.startingIndex !== null && (options.mode === 'slide' || options.mode === 'flex')) {
            if (options.startingIndex === i) {
              $dot.addClass(options.classCurrent);

              if(options.startingIndex === 0) $prev.addClass(options.classDisabled);
              if(options.startingIndex === _self[0].childElementCount - 1) $next.addClass(options.classDisabled);
            }
          }
          else {
            if (!i) $dot.addClass(options.classCurrent);
          }

          // The index to which the dowry is linked is stored
          $dot.responsiveSliderMemorizeData('slideIndex', i);

          // Click management
          $dot.click(function () {
            _self.triggerDot(i, $dot);
          });

          var isLast = $elt.responsiveSliderReadData('isLast');
          var isOutOfRange = $elt.responsiveSliderReadData('isOutOfRange');
          // If the point corresponds to "sliderRange", it is inserted
          // Or if it's the last one to reach
          if (((i % options.sliderRange) === 0 || isLast) && !isOutOfRange) {
            indexLast = i;
            $dotsHolder.append(
              $dot
            );
          }
        });
        $dots = $('> li', $dotsHolder);

        // We memorize the first and last slide of the slider
        // slideFirst = $children.eq(0);
        slideLast = $children.eq(indexLast);

        // We memorize the current
        _currentDot = $('.' + options.classCurrent, $dotsHolder);
        // _previousDot = $dots.last();

        // If we have no hidden slide, we have no pagination, so we can destroy
        // the slider
        if (_self.getSlidesOut().length) {
          // Standard pagination or a specific function is executed
          if (typeof options.pager === 'boolean' && options.pager) {
            insertPager();
          }
          if (typeof options.pager === 'function') {
            options.pager(_self, $prev, $next, $dotsHolder);
          }
        }

      };

      // Standard insertion of pagination
      var insertPager = function () {

        // We get the wrapper, because it is impossible to insert in the HTML
        // DOM by targeting an element that was used in.wrap()
        var wrapper = _self.parent();
        wrapper.after(
          $dotsHolder
        ).after(
          $next
        ).after(
          $prev
        );

      };

      // Proceed to the animation
      var animateSlider = function (target) {

        // Item previously displayed
        var previous = $children.eq(_previous);

        // Datas at the callback of the slider info
        var datas = {
          slider: _self,
          previous: {
            index: _previous,
            elt: previous
          },
          target: {
            index: _current,
            elt: target
          }
        };

        // Custom function "onBeforeSlide"
        options.onBeforeSlide(datas);

        // Default common configuration
        var animationCommon = {
          duration: options.duration,
          complete: function () {
            options.onAfterSlide(datas);
          }
        };

        // Check if options.easing is declared and if the easing method exists
        if (typeof options.easing === 'string' && typeof jQuery.easing[options.easing] !== 'undefined') {
          animationCommon.easing = options.easing;
        }

        // Toggles according to slide mode
        switch (options.mode) {
          case 'fade':

            // Target initialization for height calculation
            target.css({
              width: '100%',
              position: 'absolute',
              left: '0',
              top: '0',
              display: 'block',
              opacity: 0
            });

            // Height storage
            var height = target.innerHeight();

            // Initialization of the target
            target.removeAttr('style').css({
              width: '100%',
              position: 'absolute',
              left: '0',
              top: '0',
              display: 'none'
            });

            // Mode fade
            var animationCfgSlider = cloneObject(animationCommon);
            animationCfgSlider = $.extend(animationCfgSlider, {
              complete: function () {
              }
            });
            var animationCfgPrevious = cloneObject(animationCommon);
            animationCfgPrevious = $.extend(animationCfgPrevious, {
              complete: function () {
                previous.css({
                  position: 'absolute'
                });
              }
            });
            var animationCfgTarget = cloneObject(animationCommon);
            animationCfgTarget = $.extend(animationCfgTarget, {
              complete: function () {
                target.removeAttr('style');
                options.onAfterSlide(datas);
              }
            });

            // Animation
            setTimeout(function () {
              previous.fadeOut(animationCfgPrevious);
              target.fadeIn(animationCfgTarget);

              if (options.adaptativeHeight) {
                _self.animate({
                  height: height + 'px'
                }, animationCfgSlider);
              }
            }, options.delay);

            break;

          // "slide" or "flex" Case
          default:

            // We memorize the currently visible slides
            var slidesOut = _self.getSlidesOut();

            // slide Mode
            var offset = target.responsiveSliderReadOffset();
            var animationCfg = cloneObject(animationCommon);
            animationCfg = $.extend(animationCfg, {
              complete: function () {
                if (options.adaptativeHeight) {
                  slidesOut.responsiveSliderNeutralizeItemSize();
                }
                options.onAfterSlide(datas);
              }
            });

            // We refix the height of the slider
            var formerHeight = _self.responsiveSliderReadSliderAdaptativeHeight();
            if (typeof formerHeight === 'undefined') {
              formerHeight = _self.innerHeight();
            }

            // We re-display all the slides
            $children.responsiveSliderRecoverItemSize();

            // We're looking for, among the future slides, the biggest
            var higher = _self.getSlidesInHigher();

            // The calculated height is stored
            _self.responsiveSliderMemorizeSliderAdaptativeHeight(higher);

            // Animation
            setTimeout(function () {
              var css = {
                left: '-' + offset + '%'
              };
              if (higher !== formerHeight && options.adaptativeHeight) {
                _self.css({
                  height: formerHeight + 'px'
                });
                css.height = higher + 'px';
              }
              _self.animate(css, animationCfg);
            }, options.delay);

            break;

        }

      };

      // Swipe start
      var swipeStart = function () {

        // If you touch with only 1 finger
        if (event.touches.length === 1) {

          // We recover the value
          var touch = event.touches[0];
          swipeOrigin.x = touch.pageX;
          swipeOrigin.y = touch.pageY;

          // offsetOrigin = ctx.position();

          // We stop a possible animation in progress
          _self.stop(true, true);

          // We're looking for, among the future slides, the biggest
          var higher = _self.getSlidesInHigher();

          // The height of the slider is fixed
          if (options.adaptativeHeight) {
            _self.css({
              height: higher + 'px'
            });
          }

          // We re-display all the slides
          $children.responsiveSliderRecoverItemSize();

          // Auto Scroll Stop
          if (options.autoPlay) {
            clearInterval(autoPlay);
          }

          // Stop resumption of auto scrolling
          if (options.resumeAutoPlay) {
            clearTimeout(resumeAutoPlay);
          }

          // event.preventDefault();
        }

      };

      // Swipe move
      var swipeMove = function () {

        // If you touch with only 1 finger
        if (event.touches.length === 1) {

          // We recover the value
          var touch = event.touches[0];

          // If you swipe more horizontally than vertically
          if (Math.abs(swipeOrigin.y - touch.pageY) < Math.abs(swipeOrigin.x - touch.pageX)) {

            var swipeOffset = swipeOrigin.x - touch.pageX;

            // If you swipe beyond the trigger threshold
            if (Math.abs(swipeOffset) > options._offsetTrigger) {
              swipeAxisX = true;

              // Relative swipeOffset calculation
              swipeOffset = (swipeOffset * _self.responsiveSliderReadData('relative') / 100) / _self.width();

              // Passage in % and rounding
              swipeOffset = Math.round(swipeOffset * 100 * options._round) / options._round;

              var sliderOffset = -_self.getCurrent().elt.responsiveSliderReadOffset();
              var swipeOffsetPercent = sliderOffset - swipeOffset;

              // We check that the offset does not exceed 0
              if (swipeOffsetPercent > 0) {
                swipeOffsetPercent = 0;
              }

              // Check that the offset does not exceed the last slide
              var maxOffset = -slideLast.responsiveSliderReadOffset();
              if (swipeOffsetPercent < maxOffset) {
                swipeOffsetPercent = maxOffset;
              }

              _self.css({
                left: swipeOffsetPercent + '%'
              });

              // We stop the vertical scroll that blocks the display
              event.stopPropagation();
              event.preventDefault();
            }
            else {
              swipeAxisX = false;
            }

          }
        }

      };

      // Swipe end
      var swipeEnd = function () {

        // If you touch with only 1 finger
        if (event.changedTouches.length === 1) {

          // We recover the value
          var touch = event.changedTouches[0];

          // Swipe direction
          var swipeOffset = swipeOrigin.x - touch.pageX;

          // If we swiped beyond the trigger threshold
          if (swipeAxisX && Math.abs(swipeOffset) > options._offsetTrigger) {

            if (swipeOffset > 0) {
              _self.nextSlide();
            }
            else {
              _self.prevSlide();
            }

          }
        }

      };

      // PUBLIC FUNCTIONS

      /**
       * @method external:"jQuery.fn".responsiveSlider.reachSlide
       * @description Reach a given slide
       *
       * @param {number} index - Target slide index
       * @param {number} trigger - Clipped pagination index
       */

      _self.reachSlide = function (index, trigger) {

        // The precedents/next ones are memorized
        _previous = _current;
        _current = index;
        // _previousDot = _currentDot;
        _currentDot = trigger;

        if (!_currentDot.next().length && !options.loop) {
          $next.addClass(options.classDisabled);
        }
        else {
          $next.removeClass(options.classDisabled);
        }
        if (!_currentDot.prev().length && !options.loop) {
          $prev.addClass(options.classDisabled);
        }
        else {
          $prev.removeClass(options.classDisabled);
        }

        // We stop the animations
        _self.stop(true, true);
        $children.stop(true, true);

        // We start the animation
        var target = $children.eq(trigger.responsiveSliderReadData('slideIndex'));
        animateSlider(target);

      };

      /**
       * @method external:"jQuery.fn".responsiveSlider.prevSlide
       * @description Reach the next slide
       */

      _self.prevSlide = function () {

        var prev = _currentDot.prev();
        if (prev.length) {
          prev.click();
        }
        else if (options.loop) {
          prev = $dots.first();
          prev.click();
        }

      };

      // $next.unbind('click').bind('click', _self.nextSlideEndless);

      // $prev.unbind('click').bind('click', _self.prevSlideEndless);

      /**
       * @method external:"jQuery.fn".responsiveSlider.nextSlide
       * @description Reach the next slide
       */

      _self.nextSlide = function () {

        var next = _currentDot.next();
        if (next.length) {
          next.click();
        }
        else if (options.loop) {
          next = $dots.first();
          next.click();
        }

      };

      /**
       * @method external:"jQuery.fn".responsiveSlider.triggerDot
       * @description Reaching a slide from pagination
       *
       * @param {number} index - Index of the targeted slide
       * @param {number} trigger - Clipped pagination index
       */

      _self.triggerDot = function (index, trigger) {

        if (!trigger.hasClass(options.classCurrent)) {

          // Add the current class
          $dots.removeClass(options.classCurrent);
          trigger.addClass(options.classCurrent);

          // Auto stop scrolling if available
          if (options.autoPlay) {
            _self.stopAutoPlay();
          }

          _self.reachSlide(index, trigger);

        }

      };

      /**
       * @method external:"jQuery.fn".responsiveSlider.nextSlideEndless
       * @description Reach the next slide recursively (return to the first one
       *   if you have reached the end)
       */

      _self.nextSlideEndless = function () {

        var next = _currentDot.next();
        if (!next.length) {
          next = $dots.first();
        }

        // We trigger the slide
        next.click();
      };

      /**
       * @method external:"jQuery.fn".responsiveSlider.prevSlideEndless
       * @description Reach the previous slide recursively (return to the last one
       *   if you have reached the start)
       */

      _self.prevSlideEndless = function () {

        var next = _currentDot.prev();
        if (!next.length) {
          next = $dots.last();
        }

        // We trigger the slide
        next.click();
      };

      /**
       * @typedef {object} responsiveSlider_getCurrent_return
       *
       * @property {number} index - Current slide index
       * @property {jQuery} elt - Current slide jQuery object
       */

      /**
       * @method external:"jQuery.fn".responsiveSlider.getCurrent
       * @description Know the slide in progress
       *
       * @return {responsiveSlider_getCurrent_return}
       */

      _self.getCurrent = function () {

        return {
          index: _current,
          elt: $children.eq(_current)
        };

      };

      /**
       * @method external:"jQuery.fn".responsiveSlider.getSlides
       * @description Know the HTML elements corresponding to the slides
       *
       * @return {jQuery} - Objet jQuery
       */

      _self.getSlides = function () {

        return $children;

      };

      /**
       * @method external:"jQuery.fn".responsiveSlider.getSlidesIn
       * @description Know those currently visible
       *
       * @return {jQuery} - Objet jQuery
       */

      _self.getSlidesIn = function () {

        var output;

        // Matching Elements
        var filtered = [];

        // We're looking for the first visible item
        var targetMin;
        if (typeof _currentDot === 'undefined') {
          targetMin = $children.first();
        }
        else {
          targetMin = $children.eq(_currentDot.responsiveSliderReadData('slideIndex'));
        }

        filtered.push(targetMin[0]);
        var cumulativeWidth = targetMin.responsiveSliderReadData('native');
        targetMin.nextAll().each(function () {
          var $item = $(this);

          if (Math.round(cumulativeWidth) < 100) {
            filtered.push(this);
          }

          cumulativeWidth += $item.responsiveSliderReadData('native');
        });

        output = $(filtered);

        return output;
      };

      /**
       * @method external:"jQuery.fn".responsiveSlider.getSlidesOut
       * @description Know those currently unseen
       *
       * @return {jQuery} - Objet jQuery
       */

      _self.getSlidesOut = function () {

        var output;

        // We keep only the elements between the current index and the number
        // of items to slider
        var filtered = [];

        var slidesIn = _self.getSlidesIn();
        slidesIn.first().prevAll().each(function () {
          filtered.push(this);
        });
        slidesIn.last().nextAll().each(function () {
          filtered.push(this);
        });

        output = $(filtered);

        return output;
      };

      /**
       * @method external:"jQuery.fn".responsiveSlider.getSlidesInHigher
       * @description Know the biggest slide among those currently visible
       *
       * @return {jQuery} - Objet jQuery
       */

      _self.getSlidesInHigher = function () {

        var higher = 0;

        var slidesIn = _self.getSlidesIn();
        slidesIn.each(function () {
          var item = $(this);
          var height = item.innerHeight();
          if (height > higher) {
            higher = height;
          }
        });

        return higher;
      };

      /**
       * @method external:"jQuery.fn".responsiveSlider.startAutoPlay
       * @description Start auto playback
       */

      _self.startAutoPlay = function () {

        autoPlay = setInterval(function () {
          var next = _currentDot.next();
          if (!next.length) {
            next = $dots.first();
          }
          _self.triggerDot(next.index(), next);
        }, (options.autoPlayDuration * 1000));

      };

      /**
       * @method external:"jQuery.fn".responsiveSlider.stopAutoPlay
       * @description Stop auto playback
       *
       * @param {boolean} [preventResume=false] - Prevent automatic restart
       */

      _self.stopAutoPlay = function (preventResume) {

        if (!(typeof preventResume === 'boolean' && preventResume)) {
          preventResume = false;
        }

        clearInterval(autoPlay);
        clearTimeout(resumeAutoPlay);

        // Auto stop scrolling if available
        if (options.resumeAutoPlay && !preventResume) {
          resumeAutoPlay = setTimeout(function () {
            _self.startAutoPlay();
          }, (options.resumeAutoPlayDuration * 1000));
        }

      };

      /**
       * @method external:"jQuery.fn".responsiveSlider.reloadSlider
       * @description Rebuild the slider
       */

      _self.reloadSlider = function () {

        clearTimeout(resize);
        resize = setTimeout(function () {
          var instantViewport = getViewportWidth();
          if (instantViewport !== viewportWidth) {

            // If the width has changed, the new width is stored and the
            // greybox margin-top is adjusted.
            viewportWidth = instantViewport;

            _self.destroySlider();
            init();
          }

        }, (options._resizeTimeout * 1000));

      };

      /**
       * @method external:"jQuery.fn".responsiveSlider.destroySlider
       * @description Destruction of the slider
       */

      _self.destroySlider = function () {

        if (hasBeenInitialized) {
          // Stop resize detection
          $(window).unbind('resize', _self.reloadSlider);

          // Stop swipe events
          if (typeof Modernizr !== 'undefined' && typeof Modernizr.touch !== 'undefined' && Modernizr.touch) {
            if (typeof window.navigator.msPointerEnabled !== 'undefined') {
              _self[0].removeEventListener('MSPointerDown', swipeStart);
              _self[0].removeEventListener('MSPointerMove', swipeMove);
              _self[0].removeEventListener('MSPointerUp', swipeEnd);
            }
            _self[0].removeEventListener('touchstart', swipeStart);
            _self[0].removeEventListener('touchmove', swipeMove);
            _self[0].removeEventListener('touchend', swipeEnd);
          }

          // Auto Scroll Stop
          if (options.autoPlay) {
            clearInterval(autoPlay);
          }

          // Stop resumption of auto scrolling
          if (options.resumeAutoPlay) {
            clearTimeout(resumeAutoPlay);
          }

          // Stopping animations
          _self.stop(true, true);
          $children.stop(true, true);

          // Deleting Pagination Elements
          if (typeof $prev !== 'undefined') {
            $prev.remove();
          }
          if (typeof $next !== 'undefined') {
            $next.remove();
          }
          if (typeof $dotsHolder !== 'undefined') {
            $dotsHolder.remove();
          }
          if (typeof $dots !== 'undefined') {
            $dots.remove();
          }

          // Deleting Added Styles
          _self.removeAttr('style');

          // Deleting the wrapper
          if (_self.parent().is('div.' + options.cssPrefix + '--wrapper')) {
            _self.unwrap($wrapper);
          }

          // Rescaling the slides to the right scale
          $children.removeAttr('style');
        }

      };

      // Launching the initialization
      init();

      return _self;
    }
  });

})(jQuery);

// Title effect : random display of letters

var titleEffect;

(function ($) {

  titleEffect = function ($target, offset, offsetVariation, translationDuration, opacityDuration) {
    var $realTarget = $target;

    if ($realTarget.children('p').length) {
      $realTarget = $target.children('p');
    }

    var randomLetters = [];
    var targetInnerHTML = '';

    var html = $realTarget.html().trim();
    html = html.replace('&nbsp;', ' ');

    // Make separation between HTML tag and text
    var decodeHTML = function (html) {
      var txt = document.createElement('textarea');
      txt.innerHTML = html;
      return txt.value;
    };
    html = decodeHTML(html);
    html = html.replace(new RegExp('>', 'g'), '> ');
    html = html.replace(new RegExp('</', 'g'), ' </');
    var $array = html.split(' ');

    // Polyfill startsWith for IE
    if (!String.prototype.startsWith) {
      String.prototype.startsWith = function(searchString, position) {
        position = position || 0;
        return this.indexOf(searchString, position) === position;
      };
    }

    // Join entries in the array for having complete HTML tag
    var joinEntries = function (array, index) {

      var previousIndex = index - 1;
      if(typeof array[previousIndex] !== 'undefined') {
        array[index] = array[previousIndex] + ' ' + array[index];
        array.splice(previousIndex, 1);
      }
    };

    // Build new array with correct tag with class
    for (var index = 0; index < $array.length; index++) {

      if ($array[index] !== 'undefined') {

        if ($array[index].startsWith('class="small">') || $array[index].startsWith('class="smallest">')) {
          joinEntries($array, index);
        }
      }
    }

    // Create word container
    $.each($array, function (key, value) {

      if (value !== '') {
        if (value.match('<[^>]*>')) {
          targetInnerHTML += value;
        }
        else {
          targetInnerHTML += '<div class="word-container">' + value + '</div>' + ' ';
        }
      }
    });

    var inTag = false;
    var finalHTML = '';

    // Letter effects animations
    for (var i = 0; i < targetInnerHTML.length; i++) {
      if (inTag) {
        finalHTML += targetInnerHTML[i];
      }
      if (targetInnerHTML[i] === '<') {
        inTag = true;
        finalHTML += targetInnerHTML[i];
      }
      if (!inTag) {

        if ($.trim(targetInnerHTML[i]) !== '') {

          var whitelistLetter = Math.floor(Math.random() * 3);
          var offsetY = 0;
          if (!whitelistLetter) {
            offsetY = offset - (Math.round(Math.random()) * offset * 2);
            offsetY += Math.floor(Math.random() * (offsetVariation * 2)) - offsetVariation;

            finalHTML += '<span class="letter-effect" style="top:' + offsetY + 'px;">';
            finalHTML += targetInnerHTML[i];
            finalHTML += '</span>';

            if (randomLetters.indexOf(targetInnerHTML[i].toLowerCase()) === -1) {
              randomLetters.push(targetInnerHTML[i].toLowerCase());
            }
          }
          else {
            finalHTML += '<span>' + targetInnerHTML[i] + '</span>';
          }
        }
        else {
          finalHTML += targetInnerHTML[i];
        }
      }
      if (targetInnerHTML[i] === '>') {
        inTag = false;
      }
    }

    $realTarget.html(finalHTML);

    var letterArray = [];

    $target.animate({opacity: 1}, opacityDuration, 'easeInCubic', function () {
      $('span.letter-effect', $realTarget).each(function () {
        var $span = $(this);
        var letter = $span.text();
        letterArray.push(letter);

        var top = parseFloat($span.css('top'));
        $span.css('width', $span.width());
        var counter = 0;
        $span.animate({
          opacity: 1
        }, {
          duration: translationDuration * (1 / 2 + Math.random() / 2),
          easing: 'easeOutCubic',
          step: function (data) {
            if (data !== 1) {
              if (data <= .96) {
                if (!(counter % (Math.round(data * data * 6)))) {
                  $span.html(
                    randomLetters[
                      Math.floor(Math.random() * (randomLetters.length - 1))
                      ]
                  );
                }
                $span.css(
                  'top', (top - (data * top)) + 'px'
                );
              }
              else {
                $span.html(letter).css(
                  'top', (top - (data * top)) + 'px'
                );
              }
            }
            counter++;
          }
        });
      });
    });

    var checkPageFocus = setInterval(function() {

      if(!document.hasFocus()) {
        var $span = $('span.letter-effect', $realTarget);

        $span.stop(true, true);
        $span.removeAttr('style');
        $span.each(function(i, item) {
          $(item).html(letterArray[i]);
        });
        $span.removeAttr('class');
        clearInterval(checkPageFocus);
      }
    }, 250);
  };
})(jQuery);

// Wall of content

// Prerequisite: the wall elements have to be css ready

(function ($) {

  $.fn.extend({

    /**
     * @typedef wallOfContent_options
     * @description Configuration options of Wall of Content
     *
     * @property {boolean} bypass=false - destroy the build of Wall
     * @property {object} target={} - DOM element which will have the blocks to move
     * @property {string} wallContainerClass='wall-content' - class of Wall wrapper
     * @property {object} wallColClass='wall-content--col' - class of Wall column
     * @property {string} blocksToOrder='' - block to re order in the Wall
     * @property {number} grid=3 - number of column
     * @property {object.<wallOfContent_options>} responsive - .
     */

    /**
     * @class external:"jQuery.fn".wallOfContent
     * @description Organize the layout in different columns
     *
     * @param {wallOfContent_options} [cfg] - Configuration options (optional)
     *
     * @return {jQuery} this
     */

    wallOfContent: function (cfg) {

      // Check if cfg is an object
      if (typeof cfg !== 'object') {
        cfg = {};
      }

      // Object parameters
      var defaults = {
        // Options
        bypass: false,
        target: {},
        wallContainerClass: 'wall-content',
        wallColClass: 'wall-content--col',
        blocksToOrder: '',
        grid: 3,
        responsive: {},
        _resizeTimeout: 0.25
      };

      // The object where the Wall will be attach
      var _self = this;

      // Future options
      var options;

      // SetTimeOut of resize
      var resize;

      // Memorize the origin layout
      var layout;

      // Content wrapper of the Wall
      var $wallContentWrapper = $('<div />');

      // Get the width of the viewport
      var viewportWidth;

      // Original Wall
      var $target;

      _self.$blockToRegister = [];

      // Wall initialization
      var init = function () {

        // Detect resizing to launch the Wall
        $(window).bind('resize', _self.reload);

        // Manage configuration options
        options = cfgManager();

        $wallContentWrapper.attr('class', options.wallContainerClass);

        // Delete the origin DOM element
        $target = $(options.target, _self);

        if (!options.bypass && $target.length) {
          $target.hide();

          // Save the layout of origin
          layout = registerLayout();

          // Construct the Wall
          if (layout.length) {
            buildWallOfContent();
          }
        }
      };

      // Clone an object
      var cloneObject = function (datas) {

        var output = {};
        $.each(datas, function (key, data) {
          output[key] = data;
        });

        return output;

      };

      // Manage configuration options
      var cfgManager = function () {

        var output = {};

        var clonedDefaults = cloneObject(defaults);
        output = $.extend(clonedDefaults, cfg);

        // Memorize the screen width
        viewportWidth = getViewportWidth();

        if (typeof output.responsive === 'object') {
          $.each(output.responsive, function (breakpoint, inheritCfg) {
            var initBreakpoint = parseInt(breakpoint);

            if (!isNaN(initBreakpoint) && viewportWidth >= initBreakpoint) {
              output = $.extend(output, inheritCfg);
            }
          });
        }

        return output;
      };

      // Get the viewport width
      var getViewportWidth = function () {

        var viewportWidth;

        // For the most of web browser
        if (typeof window.outerWidth !== 'undefined') {
          viewportWidth = window.outerWidth;
        }
        // For IE8, we break the responsive behavior
        else {
          viewportWidth = -Number.NEGATIVE_INFINITY;
        }

        // For iOs window.outerWidth return 0
        if (viewportWidth === 0) {

          if (typeof window.orientation !== 'undefined') {
            if (window.orientation === 0 || window.orientation === 180) {
              viewportWidth = screen.width;
            }
            else if (window.orientation === 90 || window.orientation === -90) {
              if (screen.availWidth > screen.width) {
                viewportWidth = screen.availWidth;
              }
              else {
                viewportWidth = $(window).width();
              }
            }
          }
        }

        return viewportWidth;
      };

      // Memorize layout of origin
      var registerLayout = function () {

        // Blocks to move in the Wall
        _self.$blockToRegister = $(options.blocksToOrder, $target);

        // Empty the layout to avoid duplicate element
        var output = [];

        _self.$blockToRegister.each(function (i) {

          var $block = $(this);

          output.push({
            block: $block,
            ancestor: $block.parent(),
            columnClass: '.' + options.wallColClass + ((i % options.grid) + 1)
          });
        });

        return output;
      };

      // Construct the Wall DOM
      var buildWallOfContent = function () {

        $wallContentWrapper.detach();

        // New columns to append in Wall Content Wrapper
        for (var i = 1; i < options.grid + 1; i++) {

          var $wallContentColumn = $('<div />', {
            class: options.wallColClass + ' ' + options.wallColClass + i
          });

          // Add the column to the Wall
          $wallContentWrapper.append($wallContentColumn);
        }

        // Move all blocks in new Wall of Content Columns
        $.each(layout, function (i, block) {

          var $blockCol = $(block.columnClass, $wallContentWrapper);

          block.block.css({opacity: 0});
          block.block.detach().appendTo($blockCol);
          block.block.delay(i * (_duration / 8)).animate({
            opacity: 1
          }, {
            duration: _duration
          });
        });

        // Add Wall in DOM
        $target.after($wallContentWrapper);
      };

      /**
       * @method external:"jQuery.fn".wallOfContent.reload
       * @description Construct the Wall again
       */

      _self.reload = function () {

        clearTimeout(resize);
        resize = setTimeout(function () {

          _self.destroy();
          init();

        }, (options._resizeTimeout * 1000));
      };

      /**
       * @method external:"jQuery.fn".wallOfContent.destroy
       * @description Destroy the Wall
       *
       * @return {jQuery} this
       */

      _self.destroy = function () {

        // Stop resizing detection
        $(window).unbind('resize', _self.reload);

        $target.show();

        // Initialize the origin layout in DOM
        if (typeof _self.$blockToRegister !== 'undefined' && _self.$blockToRegister.length) {
          _self.$blockToRegister.each(function (i) {
            $(this).css({opacity: 1});
            $(this).detach().appendTo(layout[i].ancestor);
          });
        }

        // Detach the previous wrapper Wall created
        $wallContentWrapper.detach();
        $wallContentWrapper.empty();
      };

      // Launch Wall of Content
      init();

      return _self;
    }

  });

})(jQuery);

var animCursor;

(function ($) {

  animCursor = function ($container, item) {

    $container.addClass('set-relative-from-mobile');
    var $tracker = $('<span>', {
      class: 'tracker'
    });
    $container.append($tracker);

    var trackerInitState = {
      opacity: 0,
      top: 0
    };

    var $title = $('.toc-title', $container);
    if ($title.length) {
      trackerInitState = {
        opacity: 1,
        top: $tracker.css('top'),
        height: parseInt($title.css('height')) - 10
      };
    }
    $tracker.css(trackerInitState);

    $container.on('mouseleave touchend', function () {
      $tracker.css(trackerInitState);
    });

    var placeTrackerOnActive = function ($active) {

      $tracker.css({
        opacity: 1,
        top: $active.offset().top - $container.offset().top,
        height: $active.height(),
        left: $active.offset().left - $container.offset().left
      });
    };

    $container.on('mouseenter touch', item, function () {
      placeTrackerOnActive($(this));
    });
  };

})(jQuery);

// Animation inview

(function ($) {


  var animatedInview = function (context, options) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var self = this;

    self.settings = {
      classItem: 'anim-inview-',
      classInview: 'is-inview'
    };

    $('[class*=' + self.settings.classItem + ']', context).each(function () {
      $(this).bind('inview', function (event, visible) {

        if (visible) {
          $(this).addClass(self.settings.classInview);
        }
      });
    });
  };

  Drupal.behaviors.animatedInview = {
    attach: animatedInview
  };

})(jQuery);

var createFlaps;
var animFlaps;

(function ($) {

  var iNbFlaps = 6;
  var $flaps;
  var cssClass = 'flaps';

  /**
   * @function animFlapsToRight
   *
   * @description anime flaps to right
   *
   * @return false
   */

  var animFlapsToRight = function ($flaps) {

    $flaps.find('span').each(function (i) {
      var $flap = $(this);
      var animCallback = function () {
        $(this).addClass('flap-no-transition flap-translate--to-left').removeClass('flap-translate--to-right');
      };
      setTimeout(function () {
        $flap.addClass('flap-translate--to-right').one(transitionEvent, animCallback);
      }, 40 * i);
    });
  };

  /**
   * @function createFlaps
   *
   * @description create flaps
   *
   * @return $flaps
   */

  createFlaps = function ($target) {
    $flaps = $('<span />', {
      class: cssClass
    });
    $target.append($flaps);
    for (var i = 0; i < iNbFlaps; i++) {
      var $flap = $('<span />', {
        class: cssClass + '--flap'
      }).append('<span />');
      $flaps.append($flap);
    }
    return $flaps;
  };

  /**
   * @function animFlaps
   *
   * @description animate flaps
   *
   * @return false
   */

  animFlaps = function ($flaps, step) {
    if (typeof step === 'undefined') {
      step = 'next';
    }

    if (step === 'first') {
      setTimeout(function () {
        animFlapsToRight($flaps);
      }, 500);
    }
    else {
      $flaps.find('span').each(function (i) {
        var $flap = $(this);
        setTimeout(function () {
          $flap.removeClass('flap-no-transition flap-translate--to-left').one(transitionEvent, function () {
            if (i === iNbFlaps - 1) {
              animFlapsToRight($flaps);
            }
          });
        }, 40 * i);
      });
    }
  };

})(jQuery);

// JS letters effect

(function ($) {

  var jsLettersEffect = function (context, settings) {

    if (bBackstopJS) { // do not Test
      return false;
    }

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'js-letters-effect';
    var $targets = $('.' + cssClass, context);

    $targets.each(function () {

      var $target = $(this);
      // add delay to wait flap animations if we are on the home page
      var iDelay = $targets.closest('.page-intro').length ? 1200 : 0;

      if (!$target.data('init-' + cssClass)) {
        $target.data('init-' + cssClass, true);
        setTimeout(function () {
          titleEffect($target, 300, 20, 3000, 1000);
        }, iDelay);
      }
    });
  };

  Drupal.behaviors.jsLettersEffect = {
    attach: jsLettersEffect
  };

})(jQuery);

// Search Results


(function ($) {

  var searchPage = function (context, settings) {

    if (typeof context === 'undefined') {
      context = document;
    }

    var cssClass = 'search-results-page';
    // /!\ do not set context container to avoid bug in drupal
    // because at reload .search-results-page is the context
    var $targets = $('.' + cssClass);

    $targets.each(function () {
      var $target = $(this);
      // test the init on a children witch is recreate at the reload
      if ($target.find('.view-filters').data('init-' + cssClass)) {
        return true; // continue
      }
      $target.find('.view-filters').data('init-' + cssClass, true);

      var $viewHeader = $('.view-header', $target);
      var $viewFilters = $('.view-filters', $target);
      var $viewContent = $('.view-content', $target);
      var $formActions = $('.form-actions', $viewFilters);
      var $contentFilters = $('.content-filters', $target);
      var $submit = $('input.form-submit', $formActions);
      var $searchFieldInput = $('input[data-drupal-selector=edit-keyword]', $viewFilters);
      var $searchFieldContainer = $searchFieldInput.parent();
      var $pager = $('fieldset[data-drupal-selector=edit-items-per-page]', $viewFilters);

      var $containerSearchField = $('<div />', {
        class: 'container'
      });
      var $fieldsContainer = $('<div />', {
        class: 'advanced-search-field--fields'
      });
      var $searchFieldContent = $('<div />', {
        class: 'advanced-search-field--content'
      });

      var $searchFieldResult = $('<p />').text($viewHeader.text());

      $viewHeader.on('change', function() {
        var text = $(this).text();
        $searchFieldResult.text(text);
      });

      var $searchFieldSubmit = $('<input />', {
        type: 'button',
        class: 'advanced-search-field--submit'
      }).val(localSettings.submit);

      $searchFieldSubmit.click(function () {
        $submit.click();
      });

      $searchFieldInput.wrap($fieldsContainer);
      $searchFieldInput.after($searchFieldSubmit);
      $searchFieldInput.attr('placeholder', localSettings.type_keyword);
      $searchFieldContainer.prepend($searchFieldResult);
      $searchFieldContainer.wrapInner($searchFieldContent);
      $searchFieldContainer.wrap($containerSearchField);
      $searchFieldContainer.addClass('advanced-search-field');

      var $containerPager = $('<div />', {
        class: 'container'
      });
      var $displayPerPage = $('<div />', {
        class: 'display-per-page'
      });

      $pager.wrapInner($displayPerPage);
      $pager.wrap($containerPager);

      $('label', $pager).click(function () {
        $(this).siblings('input').on('change', function() {
          $submit.click();
        });
      });

      var $selects = $('select', $contentFilters);
      $selects.each( function () {
        var $select = $(this);

        $select.on('change', function() {
          $submit.click();
        });
      });

      var $containerResult = $('<div />', {
        class: 'container'
      });
      $viewContent.wrap($containerResult);

      $formActions.hide();
    });
  };

  Drupal.behaviors.searchPage = {
    attach: searchPage
  };

})(jQuery);
;
var gb = new Greybox();
;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

Drupal.debounce = function (func, wait, immediate) {
  var timeout = void 0;
  var result = void 0;
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var context = this;
    var later = function later() {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
      }
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
    }
    return result;
  };
};;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

(function ($, Drupal, debounce) {
  $.fn.drupalGetSummary = function () {
    var callback = this.data('summaryCallback');
    return this[0] && callback ? $.trim(callback(this[0])) : '';
  };

  $.fn.drupalSetSummary = function (callback) {
    var self = this;

    if (typeof callback !== 'function') {
      var val = callback;
      callback = function callback() {
        return val;
      };
    }

    return this.data('summaryCallback', callback).off('formUpdated.summary').on('formUpdated.summary', function () {
      self.trigger('summaryUpdated');
    }).trigger('summaryUpdated');
  };

  Drupal.behaviors.formSingleSubmit = {
    attach: function attach() {
      function onFormSubmit(e) {
        var $form = $(e.currentTarget);
        var formValues = $form.serialize();
        var previousValues = $form.attr('data-drupal-form-submit-last');
        if (previousValues === formValues) {
          e.preventDefault();
        } else {
          $form.attr('data-drupal-form-submit-last', formValues);
        }
      }

      $('body').once('form-single-submit').on('submit.singleSubmit', 'form:not([method~="GET"])', onFormSubmit);
    }
  };

  function triggerFormUpdated(element) {
    $(element).trigger('formUpdated');
  }

  function fieldsList(form) {
    var $fieldList = $(form).find('[name]').map(function (index, element) {
      return element.getAttribute('id');
    });

    return $.makeArray($fieldList);
  }

  Drupal.behaviors.formUpdated = {
    attach: function attach(context) {
      var $context = $(context);
      var contextIsForm = $context.is('form');
      var $forms = (contextIsForm ? $context : $context.find('form')).once('form-updated');
      var formFields = void 0;

      if ($forms.length) {
        $.makeArray($forms).forEach(function (form) {
          var events = 'change.formUpdated input.formUpdated ';
          var eventHandler = debounce(function (event) {
            triggerFormUpdated(event.target);
          }, 300);
          formFields = fieldsList(form).join(',');

          form.setAttribute('data-drupal-form-fields', formFields);
          $(form).on(events, eventHandler);
        });
      }

      if (contextIsForm) {
        formFields = fieldsList(context).join(',');

        var currentFields = $(context).attr('data-drupal-form-fields');

        if (formFields !== currentFields) {
          triggerFormUpdated(context);
        }
      }
    },
    detach: function detach(context, settings, trigger) {
      var $context = $(context);
      var contextIsForm = $context.is('form');
      if (trigger === 'unload') {
        var $forms = (contextIsForm ? $context : $context.find('form')).removeOnce('form-updated');
        if ($forms.length) {
          $.makeArray($forms).forEach(function (form) {
            form.removeAttribute('data-drupal-form-fields');
            $(form).off('.formUpdated');
          });
        }
      }
    }
  };

  Drupal.behaviors.fillUserInfoFromBrowser = {
    attach: function attach(context, settings) {
      var userInfo = ['name', 'mail', 'homepage'];
      var $forms = $('[data-user-info-from-browser]').once('user-info-from-browser');
      if ($forms.length) {
        userInfo.forEach(function (info) {
          var $element = $forms.find('[name=' + info + ']');
          var browserData = localStorage.getItem('Drupal.visitor.' + info);
          var emptyOrDefault = $element.val() === '' || $element.attr('data-drupal-default-value') === $element.val();
          if ($element.length && emptyOrDefault && browserData) {
            $element.val(browserData);
          }
        });
      }
      $forms.on('submit', function () {
        userInfo.forEach(function (info) {
          var $element = $forms.find('[name=' + info + ']');
          if ($element.length) {
            localStorage.setItem('Drupal.visitor.' + info, $element.val());
          }
        });
      });
    }
  };

  var handleFragmentLinkClickOrHashChange = function handleFragmentLinkClickOrHashChange(e) {
    var url = void 0;
    if (e.type === 'click') {
      url = e.currentTarget.location ? e.currentTarget.location : e.currentTarget;
    } else {
      url = window.location;
    }
    var hash = url.hash.substr(1);
    if (hash) {
      var $target = $('#' + hash);
      $('body').trigger('formFragmentLinkClickOrHashChange', [$target]);

      setTimeout(function () {
        return $target.trigger('focus');
      }, 300);
    }
  };

  var debouncedHandleFragmentLinkClickOrHashChange = debounce(handleFragmentLinkClickOrHashChange, 300, true);

  $(window).on('hashchange.form-fragment', debouncedHandleFragmentLinkClickOrHashChange);

  $(document).on('click.form-fragment', 'a[href*="#"]', debouncedHandleFragmentLinkClickOrHashChange);
})(jQuery, Drupal, Drupal.debounce);;
/**
 * @file
 * Webform behaviors.
 */

(function ($, Drupal) {

  'use strict';

  // Trigger Drupal's attaching of behaviors after the page is
  // completely loaded.
  // @see https://stackoverflow.com/questions/37838430/detect-if-page-is-load-from-back-button
  // @see https://stackoverflow.com/questions/20899274/how-to-refresh-page-on-back-button-click/20899422#20899422
  var isChrome = (/chrom(e|ium)/.test(window.navigator.userAgent.toLowerCase()));
  if (isChrome) {
    // Track back button in navigation.
    // @see https://stackoverflow.com/questions/37838430/detect-if-page-is-load-from-back-button
    var backButton = false;
    if (window.performance) {
      var navEntries = window.performance.getEntriesByType('navigation');
      if (navEntries.length > 0 && navEntries[0].type === 'back_forward') {
        backButton = true;
      }
      else if (window.performance.navigation
        && window.performance.navigation.type === window.performance.navigation.TYPE_BACK_FORWARD) {
        backButton = true;
      }
    }

    // If the back button is pressed, delay Drupal's attaching of behaviors.
    if (backButton) {
      var attachBehaviors = Drupal.attachBehaviors;
      Drupal.attachBehaviors = function (context, settings) {
        setTimeout(function (context, settings) {
          attachBehaviors(context, settings);
        }, 300);
      };
    }
  }

})(jQuery, Drupal);
;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

(function ($, Drupal) {
  var states = {
    postponed: []
  };

  Drupal.states = states;

  function invert(a, invertState) {
    return invertState && typeof a !== 'undefined' ? !a : a;
  }

  function _compare2(a, b) {
    if (a === b) {
      return typeof a === 'undefined' ? a : true;
    }

    return typeof a === 'undefined' || typeof b === 'undefined';
  }

  function ternary(a, b) {
    if (typeof a === 'undefined') {
      return b;
    }
    if (typeof b === 'undefined') {
      return a;
    }

    return a && b;
  }

  Drupal.behaviors.states = {
    attach: function attach(context, settings) {
      var $states = $(context).find('[data-drupal-states]');
      var il = $states.length;

      var _loop = function _loop(i) {
        var config = JSON.parse($states[i].getAttribute('data-drupal-states'));
        Object.keys(config || {}).forEach(function (state) {
          new states.Dependent({
            element: $($states[i]),
            state: states.State.sanitize(state),
            constraints: config[state]
          });
        });
      };

      for (var i = 0; i < il; i++) {
        _loop(i);
      }

      while (states.postponed.length) {
        states.postponed.shift()();
      }
    }
  };

  states.Dependent = function (args) {
    var _this = this;

    $.extend(this, { values: {}, oldValue: null }, args);

    this.dependees = this.getDependees();
    Object.keys(this.dependees || {}).forEach(function (selector) {
      _this.initializeDependee(selector, _this.dependees[selector]);
    });
  };

  states.Dependent.comparisons = {
    RegExp: function RegExp(reference, value) {
      return reference.test(value);
    },
    Function: function Function(reference, value) {
      return reference(value);
    },
    Number: function Number(reference, value) {
      return typeof value === 'string' ? _compare2(reference.toString(), value) : _compare2(reference, value);
    }
  };

  states.Dependent.prototype = {
    initializeDependee: function initializeDependee(selector, dependeeStates) {
      var _this2 = this;

      this.values[selector] = {};

      Object.keys(dependeeStates).forEach(function (i) {
        var state = dependeeStates[i];

        if ($.inArray(state, dependeeStates) === -1) {
          return;
        }

        state = states.State.sanitize(state);

        _this2.values[selector][state.name] = null;

        $(selector).on('state:' + state, { selector: selector, state: state }, function (e) {
          _this2.update(e.data.selector, e.data.state, e.value);
        });

        new states.Trigger({ selector: selector, state: state });
      });
    },
    compare: function compare(reference, selector, state) {
      var value = this.values[selector][state.name];
      if (reference.constructor.name in states.Dependent.comparisons) {
        return states.Dependent.comparisons[reference.constructor.name](reference, value);
      }

      return _compare2(reference, value);
    },
    update: function update(selector, state, value) {
      if (value !== this.values[selector][state.name]) {
        this.values[selector][state.name] = value;
        this.reevaluate();
      }
    },
    reevaluate: function reevaluate() {
      var value = this.verifyConstraints(this.constraints);

      if (value !== this.oldValue) {
        this.oldValue = value;

        value = invert(value, this.state.invert);

        this.element.trigger({
          type: 'state:' + this.state,
          value: value,
          trigger: true
        });
      }
    },
    verifyConstraints: function verifyConstraints(constraints, selector) {
      var result = void 0;
      if ($.isArray(constraints)) {
        var hasXor = $.inArray('xor', constraints) === -1;
        var len = constraints.length;
        for (var i = 0; i < len; i++) {
          if (constraints[i] !== 'xor') {
            var constraint = this.checkConstraints(constraints[i], selector, i);

            if (constraint && (hasXor || result)) {
              return hasXor;
            }
            result = result || constraint;
          }
        }
      } else if ($.isPlainObject(constraints)) {
          for (var n in constraints) {
            if (constraints.hasOwnProperty(n)) {
              result = ternary(result, this.checkConstraints(constraints[n], selector, n));

              if (result === false) {
                return false;
              }
            }
          }
        }
      return result;
    },
    checkConstraints: function checkConstraints(value, selector, state) {
      if (typeof state !== 'string' || /[0-9]/.test(state[0])) {
        state = null;
      } else if (typeof selector === 'undefined') {
        selector = state;
        state = null;
      }

      if (state !== null) {
        state = states.State.sanitize(state);
        return invert(this.compare(value, selector, state), state.invert);
      }

      return this.verifyConstraints(value, selector);
    },
    getDependees: function getDependees() {
      var cache = {};

      var _compare = this.compare;
      this.compare = function (reference, selector, state) {
        (cache[selector] || (cache[selector] = [])).push(state.name);
      };

      this.verifyConstraints(this.constraints);

      this.compare = _compare;

      return cache;
    }
  };

  states.Trigger = function (args) {
    $.extend(this, args);

    if (this.state in states.Trigger.states) {
      this.element = $(this.selector);

      if (!this.element.data('trigger:' + this.state)) {
        this.initialize();
      }
    }
  };

  states.Trigger.prototype = {
    initialize: function initialize() {
      var _this3 = this;

      var trigger = states.Trigger.states[this.state];

      if (typeof trigger === 'function') {
        trigger.call(window, this.element);
      } else {
        Object.keys(trigger || {}).forEach(function (event) {
          _this3.defaultTrigger(event, trigger[event]);
        });
      }

      this.element.data('trigger:' + this.state, true);
    },
    defaultTrigger: function defaultTrigger(event, valueFn) {
      var oldValue = valueFn.call(this.element);

      this.element.on(event, $.proxy(function (e) {
        var value = valueFn.call(this.element, e);

        if (oldValue !== value) {
          this.element.trigger({
            type: 'state:' + this.state,
            value: value,
            oldValue: oldValue
          });
          oldValue = value;
        }
      }, this));

      states.postponed.push($.proxy(function () {
        this.element.trigger({
          type: 'state:' + this.state,
          value: oldValue,
          oldValue: null
        });
      }, this));
    }
  };

  states.Trigger.states = {
    empty: {
      keyup: function keyup() {
        return this.val() === '';
      }
    },

    checked: {
      change: function change() {
        var checked = false;
        this.each(function () {
          checked = $(this).prop('checked');

          return !checked;
        });
        return checked;
      }
    },

    value: {
      keyup: function keyup() {
        if (this.length > 1) {
          return this.filter(':checked').val() || false;
        }
        return this.val();
      },
      change: function change() {
        if (this.length > 1) {
          return this.filter(':checked').val() || false;
        }
        return this.val();
      }
    },

    collapsed: {
      collapsed: function collapsed(e) {
        return typeof e !== 'undefined' && 'value' in e ? e.value : !this.is('[open]');
      }
    }
  };

  states.State = function (state) {
    this.pristine = state;
    this.name = state;

    var process = true;
    do {
      while (this.name.charAt(0) === '!') {
        this.name = this.name.substring(1);
        this.invert = !this.invert;
      }

      if (this.name in states.State.aliases) {
        this.name = states.State.aliases[this.name];
      } else {
        process = false;
      }
    } while (process);
  };

  states.State.sanitize = function (state) {
    if (state instanceof states.State) {
      return state;
    }

    return new states.State(state);
  };

  states.State.aliases = {
    enabled: '!disabled',
    invisible: '!visible',
    invalid: '!valid',
    untouched: '!touched',
    optional: '!required',
    filled: '!empty',
    unchecked: '!checked',
    irrelevant: '!relevant',
    expanded: '!collapsed',
    open: '!collapsed',
    closed: 'collapsed',
    readwrite: '!readonly'
  };

  states.State.prototype = {
    invert: false,

    toString: function toString() {
      return this.name;
    }
  };

  var $document = $(document);
  $document.on('state:disabled', function (e) {
    if (e.trigger) {
      $(e.target).prop('disabled', e.value).closest('.js-form-item, .js-form-submit, .js-form-wrapper').toggleClass('form-disabled', e.value).find('select, input, textarea').prop('disabled', e.value);
    }
  });

  $document.on('state:required', function (e) {
    if (e.trigger) {
      if (e.value) {
        var label = 'label' + (e.target.id ? '[for=' + e.target.id + ']' : '');
        var $label = $(e.target).attr({ required: 'required', 'aria-required': 'true' }).closest('.js-form-item, .js-form-wrapper').find(label);

        if (!$label.hasClass('js-form-required').length) {
          $label.addClass('js-form-required form-required');
        }
      } else {
        $(e.target).removeAttr('required aria-required').closest('.js-form-item, .js-form-wrapper').find('label.js-form-required').removeClass('js-form-required form-required');
      }
    }
  });

  $document.on('state:visible', function (e) {
    if (e.trigger) {
      $(e.target).closest('.js-form-item, .js-form-submit, .js-form-wrapper').toggle(e.value);
    }
  });

  $document.on('state:checked', function (e) {
    if (e.trigger) {
      $(e.target).prop('checked', e.value);
    }
  });

  $document.on('state:collapsed', function (e) {
    if (e.trigger) {
      if ($(e.target).is('[open]') === e.value) {
        $(e.target).find('> summary').trigger('click');
      }
    }
  });
})(jQuery, Drupal);;
/**
 * @file
 * JavaScript behaviors for custom webform #states.
 */

(function ($, Drupal) {

  'use strict';

  Drupal.webform = Drupal.webform || {};
  Drupal.webform.states = Drupal.webform.states || {};
  Drupal.webform.states.slideDown = Drupal.webform.states.slideDown || {};
  Drupal.webform.states.slideDown.duration = 'slow';
  Drupal.webform.states.slideUp = Drupal.webform.states.slideUp || {};
  Drupal.webform.states.slideUp.duration = 'fast';

  /* ************************************************************************ */
  // jQuery functions.
  /* ************************************************************************ */

  /**
   * Check if an element has a specified data attribute.
   *
   * @param {string} data
   *   The data attribute name.
   *
   * @return {boolean}
   *   TRUE if an element has a specified data attribute.
   */
  $.fn.hasData = function (data) {
    return (typeof this.data(data) !== 'undefined');
  };

  /**
   * Check if element is within the webform or not.
   *
   * @return {boolean}
   *   TRUE if element is within the webform.
   */
  $.fn.isWebform = function () {
    return $(this).closest('form[id^="webform"], form[data-is-webform]').length ? true : false;
  };

  /**
   * Check if element is to be treated as a webform element.
   *
   * @return {boolean}
   *   TRUE if element is to be treated as a webform element.
   */
  $.fn.isWebformElement = function () {
    return ($(this).isWebform() || $(this).closest('[data-is-webform-element]').length) ? true : false;
  };

  /* ************************************************************************ */
  // Trigger.
  /* ************************************************************************ */

  // The change event is triggered by cut-n-paste and select menus.
  // Issue #2445271: #states element empty check not triggered on mouse
  // based paste.
  // @see https://www.drupal.org/node/2445271
  Drupal.states.Trigger.states.empty.change = function change() {
    return this.val() === '';
  };

  /* ************************************************************************ */
  // Dependents.
  /* ************************************************************************ */


  // Apply solution included in #1962800 patch.
  // Issue #1962800: Form #states not working with literal integers as
  // values in IE11.
  // @see https://www.drupal.org/project/drupal/issues/1962800
  // @see https://www.drupal.org/files/issues/core-states-not-working-with-integers-ie11_1962800_46.patch
  //
  // This issue causes pattern, less than, and greater than support to break.
  // @see https://www.drupal.org/project/webform/issues/2981724
  var states = Drupal.states;
  Drupal.states.Dependent.prototype.compare = function compare(reference, selector, state) {
    var value = this.values[selector][state.name];

    var name = reference.constructor.name;
    if (!name) {
      name = $.type(reference);

      name = name.charAt(0).toUpperCase() + name.slice(1);
    }
    if (name in states.Dependent.comparisons) {
      return states.Dependent.comparisons[name](reference, value);
    }

    if (reference.constructor.name in states.Dependent.comparisons) {
      return states.Dependent.comparisons[reference.constructor.name](reference, value);
    }

    return _compare2(reference, value);
  };
  function _compare2(a, b) {
    if (a === b) {
      return typeof a === 'undefined' ? a : true;
    }

    return typeof a === 'undefined' || typeof b === 'undefined';
  }

  // Adds pattern, less than, and greater than support to #state API.
  // @see http://drupalsun.com/julia-evans/2012/03/09/extending-form-api-states-regular-expressions
  Drupal.states.Dependent.comparisons.Object = function (reference, value) {
    if ('pattern' in reference) {
      return (new RegExp(reference['pattern'])).test(value);
    }
    else if ('!pattern' in reference) {
      return !((new RegExp(reference['!pattern'])).test(value));
    }
    else if ('less' in reference) {
      return (value !== '' && parseFloat(reference['less']) > parseFloat(value));
    }
    else if ('less_equal' in reference) {
      return (value !== '' && parseFloat(reference['less_equal']) >= parseFloat(value));
    }
    else if ('greater' in reference) {
      return (value !== '' && parseFloat(reference['greater']) < parseFloat(value));
    }
    else if ('greater_equal' in reference) {
      return (value !== '' && parseFloat(reference['greater_equal']) <= parseFloat(value));
    }
    else if ('between' in reference || '!between' in reference) {
      if (value === '') {
        return false;
      }

      var between = reference['between'] || reference['!between'];
      var betweenParts = between.split(':');
      var greater = betweenParts[0];
      var less = (typeof betweenParts[1] !== 'undefined') ? betweenParts[1] : null;
      var isGreaterThan = (greater === null || greater === '' || parseFloat(value) >= parseFloat(greater));
      var isLessThan = (less === null || less === '' || parseFloat(value) <= parseFloat(less));
      var result = (isGreaterThan && isLessThan);
      return (reference['!between']) ? !result : result;
    }
    else {
      return reference.indexOf(value) !== false;
    }
  };

  /* ************************************************************************ */
  // States events.
  /* ************************************************************************ */

  var $document = $(document);

  $document.on('state:required', function (e) {
    if (e.trigger && $(e.target).isWebformElement()) {
      var $target = $(e.target);
      // Fix #required file upload.
      // @see Issue #2860529: Conditional required File upload field don't work.
      toggleRequired($target.find('input[type="file"]'), e.value);

      // Fix #required for radios.
      // @see Issue #2856795: If radio buttons are required but not filled form is nevertheless submitted.
      if ($target.is('.js-form-type-radios, .js-form-type-webform-radios-other, .js-webform-type-radios, .js-webform-type-webform-radios-other')) {
        toggleRequired($target.find('input[type="radio"]'), e.value);
      }

      // Fix #required for checkboxes.
      // @see Issue #2938414: Checkboxes don't support #states required.
      // @see checkboxRequiredhandler
      if ($target.is('.js-form-type-checkboxes, .js-form-type-webform-checkboxes-other, .js-webform-type-checkboxes, .js-webform-type-webform-checkboxes-other')) {
        var $checkboxes = $target.find('input[type="checkbox"]');
        if (e.value) {
          // Add event handler.
          $checkboxes.on('click', statesCheckboxesRequiredEventHandler);
          // Initialize and add required attribute.
          checkboxesRequired($target);
        }
        else {
          // Remove event handler.
          $checkboxes.off('click', statesCheckboxesRequiredEventHandler);
          // Remove required attribute.
          toggleRequired($checkboxes, false);
        }
      }

      // Fix required label for elements without the for attribute.
      // @see Issue #3145300: Conditional Visible Select Other not working.
      if ($target.is('.js-form-type-webform-select-other, .js-webform-type-webform-select-other')) {
        var $select = $target.find('select');
        toggleRequired($select, e.value);
        copyRequireMessage($target, $select);
      }
      if ($target.find('> label:not([for])').length) {
        $target.find('> label').toggleClass('js-form-required form-required', e.value);
      }

      // Fix required label for checkboxes and radios.
      // @see Issue #2938414: Checkboxes don't support #states required
      // @see Issue #2731991: Setting required on radios marks all options required.
      // @see Issue #2856315: Conditional Logic - Requiring Radios in a Fieldset.
      // Fix #required for fieldsets.
      // @see Issue #2977569: Hidden fieldsets that become visible with conditional logic cannot be made required.
      if ($target.is('.js-webform-type-radios, .js-webform-type-checkboxes, fieldset')) {
        $target.find('legend span.fieldset-legend:not(.visually-hidden)').toggleClass('js-form-required form-required', e.value);
      }

      // Issue #2986017: Fieldsets shouldn't have required attribute.
      if ($target.is('fieldset')) {
        $target.removeAttr('required aria-required');
      }
    }
  });

  $document.on('state:checked', function (e) {
    if (e.trigger) {
      $(e.target).trigger('change');
    }
  });

  $document.on('state:readonly', function (e) {
    if (e.trigger && $(e.target).isWebformElement()) {
      $(e.target).prop('readonly', e.value).closest('.js-form-item, .js-form-wrapper').toggleClass('webform-readonly', e.value).find('input, textarea').prop('readonly', e.value);

      // Trigger webform:readonly.
      $(e.target).trigger('webform:readonly')
        .find('select, input, textarea, button').trigger('webform:readonly');
    }
  });

  $document.on('state:visible state:visible-slide', function (e) {
    if (e.trigger && $(e.target).isWebformElement()) {
      if (e.value) {
        $(':input', e.target).addBack().each(function () {
          restoreValueAndRequired(this);
          triggerEventHandlers(this);
        });
      }
      else {
        // @see https://www.sitepoint.com/jquery-function-clear-form-data/
        $(':input', e.target).addBack().each(function () {
          backupValueAndRequired(this);
          clearValueAndRequired(this);
          triggerEventHandlers(this);
        });
      }
    }
  });

  $document.on('state:visible-slide', function (e) {
    if (e.trigger && $(e.target).isWebformElement()) {
      var effect = e.value ? 'slideDown' : 'slideUp';
      var duration = Drupal.webform.states[effect].duration;
      $(e.target).closest('.js-form-item, .js-form-submit, .js-form-wrapper')[effect](duration);
    }
  });
  Drupal.states.State.aliases['invisible-slide'] = '!visible-slide';

  $document.on('state:disabled', function (e) {
    if (e.trigger && $(e.target).isWebformElement()) {
      // Make sure disabled property is set before triggering webform:disabled.
      // Copied from: core/misc/states.js
      $(e.target)
        .prop('disabled', e.value)
        .closest('.js-form-item, .js-form-submit, .js-form-wrapper').toggleClass('form-disabled', e.value)
        .find('select, input, textarea, button').prop('disabled', e.value);

      // Never disable hidden file[fids] because the existing values will
      // be completely lost when the webform is submitted.
      var fileElements = $(e.target)
        .find(':input[type="hidden"][name$="[fids]"]');
      if (fileElements.length) {
        // Remove 'disabled' attribute from fieldset which will block
        // all disabled elements from being submitted.
        if ($(e.target).is('fieldset')) {
          $(e.target).prop('disabled', false);
        }
        fileElements.removeAttr('disabled');
      }

      // Trigger webform:disabled.
      $(e.target).trigger('webform:disabled')
        .find('select, input, textarea, button').trigger('webform:disabled');
    }
  });

  /* ************************************************************************ */
  // Behaviors.
  /* ************************************************************************ */

  /**
   * Adds HTML5 validation to required checkboxes.
   *
   * @type {Drupal~behavior}
   *
   * @see https://www.drupal.org/project/webform/issues/3068998
   */
  Drupal.behaviors.webformCheckboxesRequired = {
    attach: function (context) {
      $('.js-form-type-checkboxes.required, .js-form-type-webform-checkboxes-other.required, .js-webform-type-checkboxes.required, .js-webform-type-webform-checkboxes-other.required, .js-webform-type-webform-radios-other.checkboxes', context)
        .once('webform-checkboxes-required')
        .each(function () {
          var $element = $(this);
          $element.find('input[type="checkbox"]').on('click', statesCheckboxesRequiredEventHandler);
          setTimeout(function () {checkboxesRequired($element);});
        });
    }
  };

  /**
   * Adds HTML5 validation to required radios.
   *
   * @type {Drupal~behavior}
   *
   * @see https://www.drupal.org/project/webform/issues/2856795
   */
  Drupal.behaviors.webformRadiosRequired = {
    attach: function (context) {
      $('.js-form-type-radios, .js-form-type-webform-radios-other, .js-webform-type-radios, .js-webform-type-webform-radios-other', context)
        .once('webform-radios-required')
        .each(function () {
          var $element = $(this);
          setTimeout(function () {radiosRequired($element);});
        });
    }
  };

  /**
   * Add HTML5 multiple checkboxes required validation.
   *
   * @param {jQuery} $element
   *   An jQuery object containing HTML5 radios.
   *
   * @see https://stackoverflow.com/a/37825072/145846
   */
  function checkboxesRequired($element) {
    var $firstCheckbox = $element.find('input[type="checkbox"]').first();
    var isChecked = $element.find('input[type="checkbox"]').is(':checked');
    toggleRequired($firstCheckbox, !isChecked);
    copyRequireMessage($element, $firstCheckbox);
  }

  /**
   * Add HTML5 radios required validation.
   *
   * @param {jQuery} $element
   *   An jQuery object containing HTML5 radios.
   *
   * @see https://www.drupal.org/project/webform/issues/2856795
   */
  function radiosRequired($element) {
    var $radios = $element.find('input[type="radio"]');
    var isRequired = $element.hasClass('required');
    toggleRequired($radios, isRequired);
    copyRequireMessage($element, $radios);
  }

  /* ************************************************************************ */
  // Event handlers.
  /* ************************************************************************ */

  /**
   * Trigger #states API HTML5 multiple checkboxes required validation.
   *
   * @see https://stackoverflow.com/a/37825072/145846
   */
  function statesCheckboxesRequiredEventHandler() {
    var $element = $(this).closest('.js-webform-type-checkboxes, .js-webform-type-webform-checkboxes-other');
    checkboxesRequired($element);
  }

  /**
   * Trigger an input's event handlers.
   *
   * @param {element} input
   *   An input.
   */
  function triggerEventHandlers(input) {
    var $input = $(input);
    var type = input.type;
    var tag = input.tagName.toLowerCase();
    // Add 'webform.states' as extra parameter to event handlers.
    // @see Drupal.behaviors.webformUnsaved
    var extraParameters = ['webform.states'];
    if (type === 'checkbox' || type === 'radio') {
      $input
        .trigger('change', extraParameters)
        .trigger('blur', extraParameters);
    }
    else if (tag === 'select') {
      $input
        .trigger('change', extraParameters)
        .trigger('blur', extraParameters);
    }
    else if (type !== 'submit' && type !== 'button' && type !== 'file') {
      $input
        .trigger('input', extraParameters)
        .trigger('change', extraParameters)
        .trigger('keydown', extraParameters)
        .trigger('keyup', extraParameters)
        .trigger('blur', extraParameters);

      // Make sure input mask is reset when value is restored.
      // @see https://www.drupal.org/project/webform/issues/3124155
      if ($input.attr('data-inputmask-mask')) {
        setTimeout(function () {$input.inputmask('remove').inputmask();});
      }
    }
  }

  /* ************************************************************************ */
  // Backup and restore value functions.
  /* ************************************************************************ */

  /**
   * Backup an input's current value and required attribute
   *
   * @param {element} input
   *   An input.
   */
  function backupValueAndRequired(input) {
    var $input = $(input);
    var type = input.type;
    var tag = input.tagName.toLowerCase(); // Normalize case.

    // Backup required.
    if ($input.prop('required') && !$input.hasData('webform-required')) {
      $input.data('webform-required', true);
    }

    // Backup value.
    if (!$input.hasData('webform-value')) {
      if (type === 'checkbox' || type === 'radio') {
        $input.data('webform-value', $input.prop('checked'));
      }
      else if (tag === 'select') {
        var values = [];
        $input.find('option:selected').each(function (i, option) {
          values[i] = option.value;
        });
        $input.data('webform-value', values);
      }
      else if (type !== 'submit' && type !== 'button') {
        $input.data('webform-value', input.value);
      }
    }
  }

  /**
   * Restore an input's value and required attribute.
   *
   * @param {element} input
   *   An input.
   */
  function restoreValueAndRequired(input) {
    var $input = $(input);

    // Restore value.
    var value = $input.data('webform-value');
    if (typeof value !== 'undefined') {
      var type = input.type;
      var tag = input.tagName.toLowerCase(); // Normalize case.

      if (type === 'checkbox' || type === 'radio') {
        $input.prop('checked', value);
      }
      else if (tag === 'select') {
        $.each(value, function (i, option_value) {
          $input.find("option[value='" + option_value + "']").prop('selected', true);
        });
      }
      else if (type !== 'submit' && type !== 'button') {
        input.value = value;
      }
      $input.removeData('webform-value');
    }

    // Restore required.
    var required = $input.data('webform-required');
    if (typeof required !== 'undefined') {
      if (required) {
        $input.prop('required', true);
      }
      $input.removeData('webform-required');
    }
  }

  /**
   * Clear an input's value and required attributes.
   *
   * @param {element} input
   *   An input.
   */
  function clearValueAndRequired(input) {
    var $input = $(input);

    // Check for #states no clear attribute.
    // @see https://css-tricks.com/snippets/jquery/make-an-jquery-hasattr/
    if ($input.closest('[data-webform-states-no-clear]').length) {
      return;
    }

    // Clear value.
    var type = input.type;
    var tag = input.tagName.toLowerCase(); // Normalize case.
    if (type === 'checkbox' || type === 'radio') {
      $input.prop('checked', false);
    }
    else if (tag === 'select') {
      if ($input.find('option[value=""]').length) {
        $input.val('');
      }
      else {
        input.selectedIndex = -1;
      }
    }
    else if (type !== 'submit' && type !== 'button') {
      input.value = (type === 'color') ? '#000000' : '';
    }

    // Clear required.
    $input.prop('required', false);
  }

  /* ************************************************************************ */
  // Helper functions.
  /* ************************************************************************ */

  /**
   * Toggle an input's required attributes.
   *
   * @param {element} $input
   *   An input.
   * @param {boolean} required
   *   Is input required.
   */
  function toggleRequired($input, required) {
    if (required) {
      $input.attr({'required': 'required', 'aria-required': 'true'});
    }
    else {
      $input.removeAttr('required aria-required');
    }
  }

  /**
   * Copy the clientside_validation.module's message.
   *
   * @param {jQuery} $source
   *   The source element.
   * @param {jQuery} $destination
   *   The destination element.
   */
  function copyRequireMessage($source, $destination) {
    if ($source.attr('data-msg-required')) {
      $destination.attr('data-msg-required', $source.attr('data-msg-required'));
    }
  }

})(jQuery, Drupal);
;
/**
 * @file
 * JavaScript behaviors for webforms.
 */

(function ($, Drupal) {

  'use strict';

  /**
   * Remove single submit event listener.
   *
   * @type {Drupal~behavior}
   *
   * @prop {Drupal~behaviorAttach} attach
   *   Attaches the behavior for removing single submit event listener.
   *
   * @see Drupal.behaviors.formSingleSubmit
   */
  Drupal.behaviors.webformRemoveFormSingleSubmit = {
    attach: function attach() {
      function onFormSubmit(e) {
        var $form = $(e.currentTarget);
        $form.removeAttr('data-drupal-form-submit-last');
      }
      $('body')
        .once('webform-single-submit')
        .on('submit.singleSubmit', 'form.webform-remove-single-submit', onFormSubmit);
    }
  };

  /**
   * Prevent webform autosubmit on wizard pages.
   *
   * @type {Drupal~behavior}
   *
   * @prop {Drupal~behaviorAttach} attach
   *   Attaches the behavior for disabling webform autosubmit.
   *   Wizard pages need to be progressed with the Previous or Next buttons,
   *   not by pressing Enter.
   */
  Drupal.behaviors.webformDisableAutoSubmit = {
    attach: function (context) {
      // Not using context so that inputs loaded via Ajax will have autosubmit
      // disabled.
      // @see http://stackoverflow.com/questions/11235622/jquery-disable-form-submit-on-enter
      $('.js-webform-disable-autosubmit input')
        .not(':button, :submit, :reset, :image, :file')
        .once('webform-disable-autosubmit')
        .on('keyup keypress', function (e) {
          if (e.which === 13) {
            e.preventDefault();
            return false;
          }
        });
    }
  };

  /**
   * Skip client-side validation when submit button is pressed.
   *
   * @type {Drupal~behavior}
   *
   * @prop {Drupal~behaviorAttach} attach
   *   Attaches the behavior for the skipping client-side validation.
   *
   * @deprecated in Webform 8.x-5.x and will be removed in Webform 8.x-6.x.
   *   Use 'formnovalidate' attribute instead.
   */
  Drupal.behaviors.webformSubmitNoValidate = {
    attach: function (context) {
      $(context).find(':submit.js-webform-novalidate')
        .once('webform-novalidate')
        .attr('formnovalidate', 'formnovalidate');
    }
  };

  /**
   * Custom required and pattern validation error messages.
   *
   * @type {Drupal~behavior}
   *
   * @prop {Drupal~behaviorAttach} attach
   *   Attaches the behavior for the webform custom required and pattern
   *   validation error messages.
   *
   * @see http://stackoverflow.com/questions/5272433/html5-form-required-attribute-set-custom-validation-message
   **/
  Drupal.behaviors.webformRequiredError = {
    attach: function (context) {
      $(context).find(':input[data-webform-required-error], :input[data-webform-pattern-error]').once('webform-required-error')
        .on('invalid', function () {
          this.setCustomValidity('');
          if (this.valid) {
            return;
          }

          if (this.validity.patternMismatch && $(this).attr('data-webform-pattern-error')) {
            this.setCustomValidity($(this).attr('data-webform-pattern-error'));
          }
          else if (this.validity.valueMissing && $(this).attr('data-webform-required-error')) {
            this.setCustomValidity($(this).attr('data-webform-required-error'));
          }
        })
        .on('input change', function () {
          // Find all related elements by name and reset custom validity.
          // This specifically applies to required radios and checkboxes.
          var name = $(this).attr('name');
          $(this.form).find(':input[name="' + name + '"]').each(function () {
            this.setCustomValidity('');
          });
        });
    }
  };

  // When #state:required is triggered we need to reset the target elements
  // custom validity.
  $(document).on('state:required', function (e) {
    $(e.target).filter('[data-webform-required-error]')
      .each(function () {this.setCustomValidity('');});
  });

})(jQuery, Drupal);
;
/**
 * @file
 * JavaScript behaviors for details element.
 */

(function ($, Drupal) {

  'use strict';

  // Determine if local storage exists and is enabled.
  // This approach is copied from Modernizr.
  // @see https://github.com/Modernizr/Modernizr/blob/c56fb8b09515f629806ca44742932902ac145302/modernizr.js#L696-731
  var hasLocalStorage = (function () {
    try {
      localStorage.setItem('webform', 'webform');
      localStorage.removeItem('webform');
      return true;
    }
    catch (e) {
      return false;
    }
  }());

  /**
   * Attach handler to save details open/close state.
   *
   * @type {Drupal~behavior}
   */
  Drupal.behaviors.webformDetailsSave = {
    attach: function (context) {
      if (!hasLocalStorage) {
        return;
      }

      // Summary click event handler.
      $('details > summary', context).once('webform-details-summary-save').on('click', function () {
        var $details = $(this).parent();

        // @see https://css-tricks.com/snippets/jquery/make-an-jquery-hasattr/
        if ($details[0].hasAttribute('data-webform-details-nosave')) {
          return;
        }

        var name = Drupal.webformDetailsSaveGetName($details);
        if (!name) {
          return;
        }

        var open = ($details.attr('open') !== 'open') ? '1' : '0';
        localStorage.setItem(name, open);
      });

      // Initialize details open state via local storage.
      $('details', context).once('webform-details-save').each(function () {
        var $details = $(this);

        var name = Drupal.webformDetailsSaveGetName($details);
        if (!name) {
          return;
        }

        var open = localStorage.getItem(name);
        if (open === null) {
          return;
        }

        if (open === '1') {
          $details.attr('open', 'open');
        }
        else {
          $details.removeAttr('open');
        }
      });
    }

  };

  /**
   * Get the name used to store the state of details element.
   *
   * @param {jQuery} $details
   *   A details element.
   *
   * @return {string}
   *   The name used to store the state of details element.
   */
  Drupal.webformDetailsSaveGetName = function ($details) {
    if (!hasLocalStorage) {
      return '';
    }

    // Ignore details that are vertical tabs pane.
    if ($details.hasClass('vertical-tabs__pane')) {
      return '';
    }

    // Any details element not included a webform must have define its own id.
    var webformId = $details.attr('data-webform-element-id');
    if (webformId) {
      return 'Drupal.webform.' + webformId.replace('--', '.');
    }

    var detailsId = $details.attr('id');
    if (!detailsId) {
      return '';
    }

    var $form = $details.parents('form');
    if (!$form.length || !$form.attr('id')) {
      return '';
    }

    var formId = $form.attr('id');
    if (!formId) {
      return '';
    }

    // ISSUE: When Drupal renders a webform in a modal dialog it appends a unique
    // identifier to webform ids and details ids. (i.e. my-form--FeSFISegTUI)
    // WORKAROUND: Remove the unique id that delimited using double dashes.
    formId = formId.replace(/--.+?$/, '').replace(/-/g, '_');
    detailsId = detailsId.replace(/--.+?$/, '').replace(/-/g, '_');
    return 'Drupal.webform.' + formId + '.' + detailsId;
  };

})(jQuery, Drupal);
;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

(function (Drupal, debounce) {
  var liveElement = void 0;
  var announcements = [];

  Drupal.behaviors.drupalAnnounce = {
    attach: function attach(context) {
      if (!liveElement) {
        liveElement = document.createElement('div');
        liveElement.id = 'drupal-live-announce';
        liveElement.className = 'visually-hidden';
        liveElement.setAttribute('aria-live', 'polite');
        liveElement.setAttribute('aria-busy', 'false');
        document.body.appendChild(liveElement);
      }
    }
  };

  function announce() {
    var text = [];
    var priority = 'polite';
    var announcement = void 0;

    var il = announcements.length;
    for (var i = 0; i < il; i++) {
      announcement = announcements.pop();
      text.unshift(announcement.text);

      if (announcement.priority === 'assertive') {
        priority = 'assertive';
      }
    }

    if (text.length) {
      liveElement.innerHTML = '';

      liveElement.setAttribute('aria-busy', 'true');

      liveElement.setAttribute('aria-live', priority);

      liveElement.innerHTML = text.join('\n');

      liveElement.setAttribute('aria-busy', 'false');
    }
  }

  Drupal.announce = function (text, priority) {
    announcements.push({
      text: text,
      priority: priority
    });

    return debounce(announce, 200)();
  };
})(Drupal, Drupal.debounce);;
/**
 * @file
 * JavaScript behaviors for details element.
 */

(function ($, Drupal) {

  'use strict';

  Drupal.webform = Drupal.webform || {};
  Drupal.webform.detailsToggle = Drupal.webform.detailsToggle || {};
  Drupal.webform.detailsToggle.options = Drupal.webform.detailsToggle.options || {};

  /**
   * Attach handler to toggle details open/close state.
   *
   * @type {Drupal~behavior}
   */
  Drupal.behaviors.webformDetailsToggle = {
    attach: function (context) {
      $('.js-webform-details-toggle', context).once('webform-details-toggle').each(function () {
        var $form = $(this);
        var $tabs = $form.find('.webform-tabs');

        // Get only the main details elements and ignore all nested details.
        var selector = ($tabs.length) ? '.webform-tab' : '.js-webform-details-toggle, .webform-elements';
        var $details = $form.find('details').filter(function () {
          var $parents = $(this).parentsUntil(selector);
          return ($parents.find('details').length === 0);
        });

        // Toggle is only useful when there are two or more details elements.
        if ($details.length < 2) {
          return;
        }

        var options = $.extend({
          button: '<button type="button" class="webform-details-toggle-state"></button>'
        }, Drupal.webform.detailsToggle.options);

        // Create toggle buttons.
        var $toggle = $(options.button)
          .attr('title', Drupal.t('Toggle details widget state.'))
          .on('click', function (e) {
            // Get details that are not vertical tabs pane.
            var $details = $form.find('details:not(.vertical-tabs__pane)');
            var open;
            if (Drupal.webform.detailsToggle.isFormDetailsOpen($form)) {
              $details.removeAttr('open');
              open = 0;
            }
            else {
              $details.attr('open', 'open');
              open = 1;
            }
            Drupal.webform.detailsToggle.setDetailsToggleLabel($form);

            // Set the saved states for all the details elements.
            // @see webform.element.details.save.js
            if (Drupal.webformDetailsSaveGetName) {
              $details.each(function () {
                // Note: Drupal.webformDetailsSaveGetName checks if localStorage
                // exists and is enabled.
                // @see webform.element.details.save.js
                var name = Drupal.webformDetailsSaveGetName($(this));
                if (name) {
                  localStorage.setItem(name, open);
                }
              });
            }
          })
          .wrap('<div class="webform-details-toggle-state-wrapper"></div>')
          .parent();

        if ($tabs.length) {
          // Add toggle state before the tabs.
          $tabs.find('.item-list:first-child').eq(0).before($toggle);
        }
        else {
          // Add toggle state link to first details element.
          $details.eq(0).before($toggle);
        }

        Drupal.webform.detailsToggle.setDetailsToggleLabel($form);
      });
    }
  };

  /**
   * Determine if a webform's details are all opened.
   *
   * @param {jQuery} $form
   *   A webform.
   *
   * @return {boolean}
   *   TRUE if a webform's details are all opened.
   */
  Drupal.webform.detailsToggle.isFormDetailsOpen = function ($form) {
    return ($form.find('details[open]').length === $form.find('details').length);
  };

  /**
   * Set a webform's details toggle state widget label.
   *
   * @param {jQuery} $form
   *   A webform.
   */
  Drupal.webform.detailsToggle.setDetailsToggleLabel = function ($form) {
    var isOpen = Drupal.webform.detailsToggle.isFormDetailsOpen($form);

    var label = (isOpen) ? Drupal.t('Collapse all') : Drupal.t('Expand all');
    $form.find('.webform-details-toggle-state').html(label);

    var text = (isOpen) ? Drupal.t('All details have been expanded.') : Drupal.t('All details have been collapsed.');
    Drupal.announce(text);
  };

})(jQuery, Drupal);
;
/**
 * @file
 * JavaScript behaviors for message element integration.
 */

(function ($, Drupal) {

  'use strict';

  // Determine if local storage exists and is enabled.
  // This approach is copied from Modernizr.
  // @see https://github.com/Modernizr/Modernizr/blob/c56fb8b09515f629806ca44742932902ac145302/modernizr.js#L696-731
  var hasLocalStorage = (function () {
    try {
      localStorage.setItem('webform', 'webform');
      localStorage.removeItem('webform');
      return true;
    }
    catch (e) {
      return false;
    }
  }());

  // Determine if session storage exists and is enabled.
  // This approach is copied from Modernizr.
  // @see https://github.com/Modernizr/Modernizr/blob/c56fb8b09515f629806ca44742932902ac145302/modernizr.js#L696-731
  var hasSessionStorage = (function () {
    try {
      sessionStorage.setItem('webform', 'webform');
      sessionStorage.removeItem('webform');
      return true;
    }
    catch (e) {
      return false;
    }
  }());

  /**
   * Behavior for handler message close.
   *
   * @type {Drupal~behavior}
   */
  Drupal.behaviors.webformMessageClose = {
    attach: function (context) {
      $(context).find('.js-webform-message--close').once('webform-message--close').each(function () {
        var $element = $(this);

        var id = $element.attr('data-message-id');
        var storage = $element.attr('data-message-storage');
        var effect = $element.attr('data-message-close-effect') || 'hide';
        switch (effect) {
          case 'slide': effect = 'slideUp'; break;

          case 'fade': effect = 'fadeOut'; break;
        }

        // Check storage status.
        if (isClosed($element, storage, id)) {
          return;
        }

        // Only show element if it's style is not set to 'display: none'.
        if ($element.attr('style') !== 'display: none;') {
          $element.show();
        }

        $element.find('.js-webform-message__link').on('click', function (event) {
          $element[effect]();
          setClosed($element, storage, id);
          $element.trigger('close');
          event.preventDefault();
        });
      });
    }
  };

  function isClosed($element, storage, id) {
    if (!id || !storage) {
      return false;
    }

    switch (storage) {
      case 'local':
        if (hasLocalStorage) {
          return localStorage.getItem('Drupal.webform.message.' + id) || false;
        }
        return false;

      case 'session':
        if (hasSessionStorage) {
          return sessionStorage.getItem('Drupal.webform.message.' + id) || false;
        }
        return false;

      default:
        return false;
    }
  }

  function setClosed($element, storage, id) {
    if (!id || !storage) {
      return;
    }

    switch (storage) {
      case 'local':
        if (hasLocalStorage) {
          localStorage.setItem('Drupal.webform.message.' + id, true);
        }
        break;

      case 'session':
        if (hasSessionStorage) {
          sessionStorage.setItem('Drupal.webform.message.' + id, true);
        }
        break;

      case 'user':
      case 'state':
      case 'custom':
        $.get($element.find('.js-webform-message__link').attr('href'));
        return true;
    }
  }

})(jQuery, Drupal);
;
/**
 * @file
 * Unlock protected forms.
 *
 * This works by resetting the form action to the path that It should be as well
 * as injecting the secret form key, only if the current user is verified to be
 * human which is done by waiting for a mousemove, swipe, or tab/enter key to be
 * pressed.
 */

(function ($, Drupal, drupalSettings) {
  "use strict";

  Drupal.antibot = {};

  Drupal.behaviors.antibot = {
    attach: function (context) {
      // Assume the user is not human, despite JS being enabled.
      drupalSettings.antibot.human = false;

      // Wait for a mouse to move, indicating they are human.
      $('body').mousemove(function () {
        // Unlock the forms.
        Drupal.antibot.unlockForms();
      });

      // Wait for a touch move event, indicating that they are human.
      $('body').bind('touchmove', function () {
        // Unlock the forms.
        Drupal.antibot.unlockForms();
      });

      // A tab or enter key pressed can also indicate they are human.
      $('body').keydown(function (e) {
        if ((e.keyCode == 9) || (e.keyCode == 13)) {
          // Unlock the forms.
          Drupal.antibot.unlockForms();
        }
      });
    }
  };

  /**
   * Unlock all locked forms.
   */
  Drupal.antibot.unlockForms = function () {
    // Act only if we haven't yet verified this user as being human.
    if (!drupalSettings.antibot.human) {
      // Check if there are forms to unlock.
      if (drupalSettings.antibot.forms != undefined) {
        // Iterate all antibot forms that we need to unlock.
        $.each(drupalSettings.antibot.forms, function (id, config) {
          // Switch the action.
          $('form#' + config.id).attr('action', $('form#' + config.id).data('action'));

          // Set the key.
          $('form#' + config.id).find('input[name="antibot_key"]').val(config.key);
        });
      }
      // Mark this user as being human.
      drupalSettings.antibot.human = true;
    }
  };
})(jQuery, Drupal, drupalSettings);
;
/**
 * @file
 * JavaScript behaviors for options elements.
 */

(function ($, Drupal) {

  'use strict';

  /**
   * Attach handlers to options buttons element.
   *
   * @type {Drupal~behavior}
   */
  Drupal.behaviors.webformOptionsButtons = {
    attach: function (context) {
      // Place <input> inside of <label> before the label.
      $(context).find('label.webform-options-display-buttons-label > input[type="checkbox"], label.webform-options-display-buttons-label > input[type="radio"]').each(function () {
        var $input = $(this);
        var $label = $input.parent();
        $input.detach().insertBefore($label);
      });
    }
  };


})(jQuery, Drupal);
;
/**
 * @file
 * JavaScript behaviors for select menu.
 */

(function ($, Drupal) {

  'use strict';

  /**
   * Disable select menu options using JavaScript.
   *
   * @type {Drupal~behavior}
   */
  Drupal.behaviors.webformSelectOptionsDisabled = {
    attach: function (context) {
      $('select[data-webform-select-options-disabled]', context).once('webform-select-options-disabled').each(function () {
        var $select = $(this);
        var disabled = $select.attr('data-webform-select-options-disabled').split(/\s*,\s*/);
        $select.find('option').filter(function isDisabled() {
          return ($.inArray(this.value, disabled) !== -1);
        }).attr('disabled', 'disabled');
      });
    }
  };


})(jQuery, Drupal);
;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

(function ($, Drupal) {
  Drupal.theme.progressBar = function (id) {
    return '<div id="' + id + '" class="progress" aria-live="polite">' + '<div class="progress__label">&nbsp;</div>' + '<div class="progress__track"><div class="progress__bar"></div></div>' + '<div class="progress__percentage"></div>' + '<div class="progress__description">&nbsp;</div>' + '</div>';
  };

  Drupal.ProgressBar = function (id, updateCallback, method, errorCallback) {
    this.id = id;
    this.method = method || 'GET';
    this.updateCallback = updateCallback;
    this.errorCallback = errorCallback;

    this.element = $(Drupal.theme('progressBar', id));
  };

  $.extend(Drupal.ProgressBar.prototype, {
    setProgress: function setProgress(percentage, message, label) {
      if (percentage >= 0 && percentage <= 100) {
        $(this.element).find('div.progress__bar').css('width', percentage + '%');
        $(this.element).find('div.progress__percentage').html(percentage + '%');
      }
      $('div.progress__description', this.element).html(message);
      $('div.progress__label', this.element).html(label);
      if (this.updateCallback) {
        this.updateCallback(percentage, message, this);
      }
    },
    startMonitoring: function startMonitoring(uri, delay) {
      this.delay = delay;
      this.uri = uri;
      this.sendPing();
    },
    stopMonitoring: function stopMonitoring() {
      clearTimeout(this.timer);

      this.uri = null;
    },
    sendPing: function sendPing() {
      if (this.timer) {
        clearTimeout(this.timer);
      }
      if (this.uri) {
        var pb = this;

        var uri = this.uri;
        if (uri.indexOf('?') === -1) {
          uri += '?';
        } else {
          uri += '&';
        }
        uri += '_format=json';
        $.ajax({
          type: this.method,
          url: uri,
          data: '',
          dataType: 'json',
          success: function success(progress) {
            if (progress.status === 0) {
              pb.displayError(progress.data);
              return;
            }

            pb.setProgress(progress.percentage, progress.message, progress.label);

            pb.timer = setTimeout(function () {
              pb.sendPing();
            }, pb.delay);
          },
          error: function error(xmlhttp) {
            var e = new Drupal.AjaxError(xmlhttp, pb.uri);
            pb.displayError('<pre>' + e.message + '</pre>');
          }
        });
      }
    },
    displayError: function displayError(string) {
      var error = $('<div class="messages messages--error"></div>').html(string);
      $(this.element).before(error).hide();

      if (this.errorCallback) {
        this.errorCallback(this);
      }
    }
  });
})(jQuery, Drupal);;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

(function (Drupal) {
  Drupal.behaviors.responsiveImageAJAX = {
    attach: function attach() {
      if (window.picturefill) {
        window.picturefill();
      }
    }
  };
})(Drupal);;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/
function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

(function ($, window, Drupal, drupalSettings) {
  Drupal.behaviors.AJAX = {
    attach: function attach(context, settings) {
      function loadAjaxBehavior(base) {
        var elementSettings = settings.ajax[base];
        if (typeof elementSettings.selector === 'undefined') {
          elementSettings.selector = '#' + base;
        }
        $(elementSettings.selector).once('drupal-ajax').each(function () {
          elementSettings.element = this;
          elementSettings.base = base;
          Drupal.ajax(elementSettings);
        });
      }

      Object.keys(settings.ajax || {}).forEach(function (base) {
        return loadAjaxBehavior(base);
      });

      Drupal.ajax.bindAjaxLinks(document.body);

      $('.use-ajax-submit').once('ajax').each(function () {
        var elementSettings = {};

        elementSettings.url = $(this.form).attr('action');

        elementSettings.setClick = true;

        elementSettings.event = 'click';

        elementSettings.progress = { type: 'throbber' };
        elementSettings.base = $(this).attr('id');
        elementSettings.element = this;

        Drupal.ajax(elementSettings);
      });
    },
    detach: function detach(context, settings, trigger) {
      if (trigger === 'unload') {
        Drupal.ajax.expired().forEach(function (instance) {
          Drupal.ajax.instances[instance.instanceIndex] = null;
        });
      }
    }
  };

  Drupal.AjaxError = function (xmlhttp, uri, customMessage) {
    var statusCode = void 0;
    var statusText = void 0;
    var responseText = void 0;
    if (xmlhttp.status) {
      statusCode = '\n' + Drupal.t('An AJAX HTTP error occurred.') + '\n' + Drupal.t('HTTP Result Code: !status', {
        '!status': xmlhttp.status
      });
    } else {
      statusCode = '\n' + Drupal.t('An AJAX HTTP request terminated abnormally.');
    }
    statusCode += '\n' + Drupal.t('Debugging information follows.');
    var pathText = '\n' + Drupal.t('Path: !uri', { '!uri': uri });
    statusText = '';

    try {
      statusText = '\n' + Drupal.t('StatusText: !statusText', {
        '!statusText': $.trim(xmlhttp.statusText)
      });
    } catch (e) {}

    responseText = '';

    try {
      responseText = '\n' + Drupal.t('ResponseText: !responseText', {
        '!responseText': $.trim(xmlhttp.responseText)
      });
    } catch (e) {}

    responseText = responseText.replace(/<("[^"]*"|'[^']*'|[^'">])*>/gi, '');
    responseText = responseText.replace(/[\n]+\s+/g, '\n');

    var readyStateText = xmlhttp.status === 0 ? '\n' + Drupal.t('ReadyState: !readyState', {
      '!readyState': xmlhttp.readyState
    }) : '';

    customMessage = customMessage ? '\n' + Drupal.t('CustomMessage: !customMessage', {
      '!customMessage': customMessage
    }) : '';

    this.message = statusCode + pathText + statusText + customMessage + responseText + readyStateText;

    this.name = 'AjaxError';
  };

  Drupal.AjaxError.prototype = new Error();
  Drupal.AjaxError.prototype.constructor = Drupal.AjaxError;

  Drupal.ajax = function (settings) {
    if (arguments.length !== 1) {
      throw new Error('Drupal.ajax() function must be called with one configuration object only');
    }

    var base = settings.base || false;
    var element = settings.element || false;
    delete settings.base;
    delete settings.element;

    if (!settings.progress && !element) {
      settings.progress = false;
    }

    var ajax = new Drupal.Ajax(base, element, settings);
    ajax.instanceIndex = Drupal.ajax.instances.length;
    Drupal.ajax.instances.push(ajax);

    return ajax;
  };

  Drupal.ajax.instances = [];

  Drupal.ajax.expired = function () {
    return Drupal.ajax.instances.filter(function (instance) {
      return instance && instance.element !== false && !document.body.contains(instance.element);
    });
  };

  Drupal.ajax.bindAjaxLinks = function (element) {
    $(element).find('.use-ajax').once('ajax').each(function (i, ajaxLink) {
      var $linkElement = $(ajaxLink);

      var elementSettings = {
        progress: { type: 'throbber' },
        dialogType: $linkElement.data('dialog-type'),
        dialog: $linkElement.data('dialog-options'),
        dialogRenderer: $linkElement.data('dialog-renderer'),
        base: $linkElement.attr('id'),
        element: ajaxLink
      };
      var href = $linkElement.attr('href');

      if (href) {
        elementSettings.url = href;
        elementSettings.event = 'click';
      }
      Drupal.ajax(elementSettings);
    });
  };

  Drupal.Ajax = function (base, element, elementSettings) {
    var defaults = {
      event: element ? 'mousedown' : null,
      keypress: true,
      selector: base ? '#' + base : null,
      effect: 'none',
      speed: 'none',
      method: 'replaceWith',
      progress: {
        type: 'throbber',
        message: Drupal.t('Please wait...')
      },
      submit: {
        js: true
      }
    };

    $.extend(this, defaults, elementSettings);

    this.commands = new Drupal.AjaxCommands();

    this.instanceIndex = false;

    if (this.wrapper) {
      this.wrapper = '#' + this.wrapper;
    }

    this.element = element;

    this.element_settings = elementSettings;

    this.elementSettings = elementSettings;

    if (this.element && this.element.form) {
      this.$form = $(this.element.form);
    }

    if (!this.url) {
      var $element = $(this.element);
      if ($element.is('a')) {
        this.url = $element.attr('href');
      } else if (this.element && element.form) {
        this.url = this.$form.attr('action');
      }
    }

    var originalUrl = this.url;

    this.url = this.url.replace(/\/nojs(\/|$|\?|#)/, '/ajax$1');

    if (drupalSettings.ajaxTrustedUrl[originalUrl]) {
      drupalSettings.ajaxTrustedUrl[this.url] = true;
    }

    var ajax = this;

    ajax.options = {
      url: ajax.url,
      data: ajax.submit,
      beforeSerialize: function beforeSerialize(elementSettings, options) {
        return ajax.beforeSerialize(elementSettings, options);
      },
      beforeSubmit: function beforeSubmit(formValues, elementSettings, options) {
        ajax.ajaxing = true;
        return ajax.beforeSubmit(formValues, elementSettings, options);
      },
      beforeSend: function beforeSend(xmlhttprequest, options) {
        ajax.ajaxing = true;
        return ajax.beforeSend(xmlhttprequest, options);
      },
      success: function success(response, status, xmlhttprequest) {
        if (typeof response === 'string') {
          response = $.parseJSON(response);
        }

        if (response !== null && !drupalSettings.ajaxTrustedUrl[ajax.url]) {
          if (xmlhttprequest.getResponseHeader('X-Drupal-Ajax-Token') !== '1') {
            var customMessage = Drupal.t('The response failed verification so will not be processed.');
            return ajax.error(xmlhttprequest, ajax.url, customMessage);
          }
        }

        return ajax.success(response, status);
      },
      complete: function complete(xmlhttprequest, status) {
        ajax.ajaxing = false;
        if (status === 'error' || status === 'parsererror') {
          return ajax.error(xmlhttprequest, ajax.url);
        }
      },

      dataType: 'json',
      jsonp: false,
      type: 'POST'
    };

    if (elementSettings.dialog) {
      ajax.options.data.dialogOptions = elementSettings.dialog;
    }

    if (ajax.options.url.indexOf('?') === -1) {
      ajax.options.url += '?';
    } else {
      ajax.options.url += '&';
    }

    var wrapper = 'drupal_' + (elementSettings.dialogType || 'ajax');
    if (elementSettings.dialogRenderer) {
      wrapper += '.' + elementSettings.dialogRenderer;
    }
    ajax.options.url += Drupal.ajax.WRAPPER_FORMAT + '=' + wrapper;

    $(ajax.element).on(elementSettings.event, function (event) {
      if (!drupalSettings.ajaxTrustedUrl[ajax.url] && !Drupal.url.isLocal(ajax.url)) {
        throw new Error(Drupal.t('The callback URL is not local and not trusted: !url', {
          '!url': ajax.url
        }));
      }
      return ajax.eventResponse(this, event);
    });

    if (elementSettings.keypress) {
      $(ajax.element).on('keypress', function (event) {
        return ajax.keypressResponse(this, event);
      });
    }

    if (elementSettings.prevent) {
      $(ajax.element).on(elementSettings.prevent, false);
    }
  };

  Drupal.ajax.WRAPPER_FORMAT = '_wrapper_format';

  Drupal.Ajax.AJAX_REQUEST_PARAMETER = '_drupal_ajax';

  Drupal.Ajax.prototype.execute = function () {
    if (this.ajaxing) {
      return;
    }

    try {
      this.beforeSerialize(this.element, this.options);

      return $.ajax(this.options);
    } catch (e) {
      this.ajaxing = false;
      window.alert('An error occurred while attempting to process ' + this.options.url + ': ' + e.message);

      return $.Deferred().reject();
    }
  };

  Drupal.Ajax.prototype.keypressResponse = function (element, event) {
    var ajax = this;

    if (event.which === 13 || event.which === 32 && element.type !== 'text' && element.type !== 'textarea' && element.type !== 'tel' && element.type !== 'number') {
      event.preventDefault();
      event.stopPropagation();
      $(element).trigger(ajax.elementSettings.event);
    }
  };

  Drupal.Ajax.prototype.eventResponse = function (element, event) {
    event.preventDefault();
    event.stopPropagation();

    var ajax = this;

    if (ajax.ajaxing) {
      return;
    }

    try {
      if (ajax.$form) {
        if (ajax.setClick) {
          element.form.clk = element;
        }

        ajax.$form.ajaxSubmit(ajax.options);
      } else {
        ajax.beforeSerialize(ajax.element, ajax.options);
        $.ajax(ajax.options);
      }
    } catch (e) {
      ajax.ajaxing = false;
      window.alert('An error occurred while attempting to process ' + ajax.options.url + ': ' + e.message);
    }
  };

  Drupal.Ajax.prototype.beforeSerialize = function (element, options) {
    if (this.$form && document.body.contains(this.$form.get(0))) {
      var settings = this.settings || drupalSettings;
      Drupal.detachBehaviors(this.$form.get(0), settings, 'serialize');
    }

    options.data[Drupal.Ajax.AJAX_REQUEST_PARAMETER] = 1;

    var pageState = drupalSettings.ajaxPageState;
    options.data['ajax_page_state[theme]'] = pageState.theme;
    options.data['ajax_page_state[theme_token]'] = pageState.theme_token;
    options.data['ajax_page_state[libraries]'] = pageState.libraries;
  };

  Drupal.Ajax.prototype.beforeSubmit = function (formValues, element, options) {};

  Drupal.Ajax.prototype.beforeSend = function (xmlhttprequest, options) {
    if (this.$form) {
      options.extraData = options.extraData || {};

      options.extraData.ajax_iframe_upload = '1';

      var v = $.fieldValue(this.element);
      if (v !== null) {
        options.extraData[this.element.name] = v;
      }
    }

    $(this.element).prop('disabled', true);

    if (!this.progress || !this.progress.type) {
      return;
    }

    var progressIndicatorMethod = 'setProgressIndicator' + this.progress.type.slice(0, 1).toUpperCase() + this.progress.type.slice(1).toLowerCase();
    if (progressIndicatorMethod in this && typeof this[progressIndicatorMethod] === 'function') {
      this[progressIndicatorMethod].call(this);
    }
  };

  Drupal.theme.ajaxProgressThrobber = function (message) {
    var messageMarkup = typeof message === 'string' ? Drupal.theme('ajaxProgressMessage', message) : '';
    var throbber = '<div class="throbber">&nbsp;</div>';

    return '<div class="ajax-progress ajax-progress-throbber">' + throbber + messageMarkup + '</div>';
  };

  Drupal.theme.ajaxProgressIndicatorFullscreen = function () {
    return '<div class="ajax-progress ajax-progress-fullscreen">&nbsp;</div>';
  };

  Drupal.theme.ajaxProgressMessage = function (message) {
    return '<div class="message">' + message + '</div>';
  };

  Drupal.theme.ajaxProgressBar = function ($element) {
    return $('<div class="ajax-progress ajax-progress-bar"></div>').append($element);
  };

  Drupal.Ajax.prototype.setProgressIndicatorBar = function () {
    var progressBar = new Drupal.ProgressBar('ajax-progress-' + this.element.id, $.noop, this.progress.method, $.noop);
    if (this.progress.message) {
      progressBar.setProgress(-1, this.progress.message);
    }
    if (this.progress.url) {
      progressBar.startMonitoring(this.progress.url, this.progress.interval || 1500);
    }
    this.progress.element = $(Drupal.theme('ajaxProgressBar', progressBar.element));
    this.progress.object = progressBar;
    $(this.element).after(this.progress.element);
  };

  Drupal.Ajax.prototype.setProgressIndicatorThrobber = function () {
    this.progress.element = $(Drupal.theme('ajaxProgressThrobber', this.progress.message));
    $(this.element).after(this.progress.element);
  };

  Drupal.Ajax.prototype.setProgressIndicatorFullscreen = function () {
    this.progress.element = $(Drupal.theme('ajaxProgressIndicatorFullscreen'));
    $('body').append(this.progress.element);
  };

  Drupal.Ajax.prototype.success = function (response, status) {
    var _this = this;

    if (this.progress.element) {
      $(this.progress.element).remove();
    }
    if (this.progress.object) {
      this.progress.object.stopMonitoring();
    }
    $(this.element).prop('disabled', false);

    var elementParents = $(this.element).parents('[data-drupal-selector]').addBack().toArray();

    var focusChanged = false;
    Object.keys(response || {}).forEach(function (i) {
      if (response[i].command && _this.commands[response[i].command]) {
        _this.commands[response[i].command](_this, response[i], status);
        if (response[i].command === 'invoke' && response[i].method === 'focus') {
          focusChanged = true;
        }
      }
    });

    if (!focusChanged && this.element && !$(this.element).data('disable-refocus')) {
      var target = false;

      for (var n = elementParents.length - 1; !target && n >= 0; n--) {
        target = document.querySelector('[data-drupal-selector="' + elementParents[n].getAttribute('data-drupal-selector') + '"]');
      }

      if (target) {
        $(target).trigger('focus');
      }
    }

    if (this.$form && document.body.contains(this.$form.get(0))) {
      var settings = this.settings || drupalSettings;
      Drupal.attachBehaviors(this.$form.get(0), settings);
    }

    this.settings = null;
  };

  Drupal.Ajax.prototype.getEffect = function (response) {
    var type = response.effect || this.effect;
    var speed = response.speed || this.speed;

    var effect = {};
    if (type === 'none') {
      effect.showEffect = 'show';
      effect.hideEffect = 'hide';
      effect.showSpeed = '';
    } else if (type === 'fade') {
      effect.showEffect = 'fadeIn';
      effect.hideEffect = 'fadeOut';
      effect.showSpeed = speed;
    } else {
      effect.showEffect = type + 'Toggle';
      effect.hideEffect = type + 'Toggle';
      effect.showSpeed = speed;
    }

    return effect;
  };

  Drupal.Ajax.prototype.error = function (xmlhttprequest, uri, customMessage) {
    if (this.progress.element) {
      $(this.progress.element).remove();
    }
    if (this.progress.object) {
      this.progress.object.stopMonitoring();
    }

    $(this.wrapper).show();

    $(this.element).prop('disabled', false);

    if (this.$form && document.body.contains(this.$form.get(0))) {
      var settings = this.settings || drupalSettings;
      Drupal.attachBehaviors(this.$form.get(0), settings);
    }
    throw new Drupal.AjaxError(xmlhttprequest, uri, customMessage);
  };

  Drupal.theme.ajaxWrapperNewContent = function ($newContent, ajax, response) {
    return (response.effect || ajax.effect) !== 'none' && $newContent.filter(function (i) {
      return !($newContent[i].nodeName === '#comment' || $newContent[i].nodeName === '#text' && /^(\s|\n|\r)*$/.test($newContent[i].textContent));
    }).length > 1 ? Drupal.theme('ajaxWrapperMultipleRootElements', $newContent) : $newContent;
  };

  Drupal.theme.ajaxWrapperMultipleRootElements = function ($elements) {
    return $('<div></div>').append($elements);
  };

  Drupal.AjaxCommands = function () {};
  Drupal.AjaxCommands.prototype = {
    insert: function insert(ajax, response) {
      var $wrapper = response.selector ? $(response.selector) : $(ajax.wrapper);
      var method = response.method || ajax.method;
      var effect = ajax.getEffect(response);

      var settings = response.settings || ajax.settings || drupalSettings;

      var $newContent = $($.parseHTML(response.data, document, true));

      $newContent = Drupal.theme('ajaxWrapperNewContent', $newContent, ajax, response);

      switch (method) {
        case 'html':
        case 'replaceWith':
        case 'replaceAll':
        case 'empty':
        case 'remove':
          Drupal.detachBehaviors($wrapper.get(0), settings);
          break;
        default:
          break;
      }

      $wrapper[method]($newContent);

      if (effect.showEffect !== 'show') {
        $newContent.hide();
      }

      var $ajaxNewContent = $newContent.find('.ajax-new-content');
      if ($ajaxNewContent.length) {
        $ajaxNewContent.hide();
        $newContent.show();
        $ajaxNewContent[effect.showEffect](effect.showSpeed);
      } else if (effect.showEffect !== 'show') {
        $newContent[effect.showEffect](effect.showSpeed);
      }

      if ($newContent.parents('html').length) {
        $newContent.each(function (index, element) {
          if (element.nodeType === Node.ELEMENT_NODE) {
            Drupal.attachBehaviors(element, settings);
          }
        });
      }
    },
    remove: function remove(ajax, response, status) {
      var settings = response.settings || ajax.settings || drupalSettings;
      $(response.selector).each(function () {
        Drupal.detachBehaviors(this, settings);
      }).remove();
    },
    changed: function changed(ajax, response, status) {
      var $element = $(response.selector);
      if (!$element.hasClass('ajax-changed')) {
        $element.addClass('ajax-changed');
        if (response.asterisk) {
          $element.find(response.asterisk).append(' <abbr class="ajax-changed" title="' + Drupal.t('Changed') + '">*</abbr> ');
        }
      }
    },
    alert: function alert(ajax, response, status) {
      window.alert(response.text, response.title);
    },
    announce: function announce(ajax, response) {
      if (response.priority) {
        Drupal.announce(response.text, response.priority);
      } else {
        Drupal.announce(response.text);
      }
    },
    redirect: function redirect(ajax, response, status) {
      window.location = response.url;
    },
    css: function css(ajax, response, status) {
      $(response.selector).css(response.argument);
    },
    settings: function settings(ajax, response, status) {
      var ajaxSettings = drupalSettings.ajax;

      if (ajaxSettings) {
        Drupal.ajax.expired().forEach(function (instance) {

          if (instance.selector) {
            var selector = instance.selector.replace('#', '');
            if (selector in ajaxSettings) {
              delete ajaxSettings[selector];
            }
          }
        });
      }

      if (response.merge) {
        $.extend(true, drupalSettings, response.settings);
      } else {
        ajax.settings = response.settings;
      }
    },
    data: function data(ajax, response, status) {
      $(response.selector).data(response.name, response.value);
    },
    invoke: function invoke(ajax, response, status) {
      var $element = $(response.selector);
      $element[response.method].apply($element, _toConsumableArray(response.args));
    },
    restripe: function restripe(ajax, response, status) {
      $(response.selector).find('> tbody > tr:visible, > tr:visible').removeClass('odd even').filter(':even').addClass('odd').end().filter(':odd').addClass('even');
    },
    update_build_id: function update_build_id(ajax, response, status) {
      $('input[name="form_build_id"][value="' + response.old + '"]').val(response.new);
    },
    add_css: function add_css(ajax, response, status) {
      $('head').prepend(response.data);
    },
    message: function message(ajax, response) {
      var messages = new Drupal.Message(document.querySelector(response.messageWrapperQuerySelector));
      if (response.clearPrevious) {
        messages.clear();
      }
      messages.add(response.message, response.messageOptions);
    }
  };
})(jQuery, window, Drupal, drupalSettings);;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

(function (Drupal) {
  Drupal.theme.ajaxProgressBar = function ($element) {
    return $element.addClass('ajax-progress ajax-progress-bar');
  };
})(Drupal);;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery","./version"],a):a(jQuery)}(function(a){return function(){function b(a,b,c){return[parseFloat(a[0])*(l.test(a[0])?b/100:1),parseFloat(a[1])*(l.test(a[1])?c/100:1)]}function c(b,c){return parseInt(a.css(b,c),10)||0}function d(b){var c=b[0];return 9===c.nodeType?{width:b.width(),height:b.height(),offset:{top:0,left:0}}:a.isWindow(c)?{width:b.width(),height:b.height(),offset:{top:b.scrollTop(),left:b.scrollLeft()}}:c.preventDefault?{width:0,height:0,offset:{top:c.pageY,left:c.pageX}}:{width:b.outerWidth(),height:b.outerHeight(),offset:b.offset()}}var e,f=Math.max,g=Math.abs,h=/left|center|right/,i=/top|center|bottom/,j=/[\+\-]\d+(\.[\d]+)?%?/,k=/^\w+/,l=/%$/,m=a.fn.position;a.position={scrollbarWidth:function(){if(void 0!==e)return e;var b,c,d=a("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),f=d.children()[0];return a("body").append(d),b=f.offsetWidth,d.css("overflow","scroll"),c=f.offsetWidth,b===c&&(c=d[0].clientWidth),d.remove(),e=b-c},getScrollInfo:function(b){var c=b.isWindow||b.isDocument?"":b.element.css("overflow-x"),d=b.isWindow||b.isDocument?"":b.element.css("overflow-y"),e="scroll"===c||"auto"===c&&b.width<b.element[0].scrollWidth,f="scroll"===d||"auto"===d&&b.height<b.element[0].scrollHeight;return{width:f?a.position.scrollbarWidth():0,height:e?a.position.scrollbarWidth():0}},getWithinInfo:function(b){var c=a(b||window),d=a.isWindow(c[0]),e=!!c[0]&&9===c[0].nodeType,f=!d&&!e;return{element:c,isWindow:d,isDocument:e,offset:f?a(b).offset():{left:0,top:0},scrollLeft:c.scrollLeft(),scrollTop:c.scrollTop(),width:c.outerWidth(),height:c.outerHeight()}}},a.fn.position=function(e){if(!e||!e.of)return m.apply(this,arguments);e=a.extend({},e);var l,n,o,p,q,r,s=a(e.of),t=a.position.getWithinInfo(e.within),u=a.position.getScrollInfo(t),v=(e.collision||"flip").split(" "),w={};return r=d(s),s[0].preventDefault&&(e.at="left top"),n=r.width,o=r.height,p=r.offset,q=a.extend({},p),a.each(["my","at"],function(){var a,b,c=(e[this]||"").split(" ");1===c.length&&(c=h.test(c[0])?c.concat(["center"]):i.test(c[0])?["center"].concat(c):["center","center"]),c[0]=h.test(c[0])?c[0]:"center",c[1]=i.test(c[1])?c[1]:"center",a=j.exec(c[0]),b=j.exec(c[1]),w[this]=[a?a[0]:0,b?b[0]:0],e[this]=[k.exec(c[0])[0],k.exec(c[1])[0]]}),1===v.length&&(v[1]=v[0]),"right"===e.at[0]?q.left+=n:"center"===e.at[0]&&(q.left+=n/2),"bottom"===e.at[1]?q.top+=o:"center"===e.at[1]&&(q.top+=o/2),l=b(w.at,n,o),q.left+=l[0],q.top+=l[1],this.each(function(){var d,h,i=a(this),j=i.outerWidth(),k=i.outerHeight(),m=c(this,"marginLeft"),r=c(this,"marginTop"),x=j+m+c(this,"marginRight")+u.width,y=k+r+c(this,"marginBottom")+u.height,z=a.extend({},q),A=b(w.my,i.outerWidth(),i.outerHeight());"right"===e.my[0]?z.left-=j:"center"===e.my[0]&&(z.left-=j/2),"bottom"===e.my[1]?z.top-=k:"center"===e.my[1]&&(z.top-=k/2),z.left+=A[0],z.top+=A[1],d={marginLeft:m,marginTop:r},a.each(["left","top"],function(b,c){a.ui.position[v[b]]&&a.ui.position[v[b]][c](z,{targetWidth:n,targetHeight:o,elemWidth:j,elemHeight:k,collisionPosition:d,collisionWidth:x,collisionHeight:y,offset:[l[0]+A[0],l[1]+A[1]],my:e.my,at:e.at,within:t,elem:i})}),e.using&&(h=function(a){var b=p.left-z.left,c=b+n-j,d=p.top-z.top,h=d+o-k,l={target:{element:s,left:p.left,top:p.top,width:n,height:o},element:{element:i,left:z.left,top:z.top,width:j,height:k},horizontal:c<0?"left":b>0?"right":"center",vertical:h<0?"top":d>0?"bottom":"middle"};n<j&&g(b+c)<n&&(l.horizontal="center"),o<k&&g(d+h)<o&&(l.vertical="middle"),f(g(b),g(c))>f(g(d),g(h))?l.important="horizontal":l.important="vertical",e.using.call(this,a,l)}),i.offset(a.extend(z,{using:h}))})},a.ui.position={fit:{left:function(a,b){var c,d=b.within,e=d.isWindow?d.scrollLeft:d.offset.left,g=d.width,h=a.left-b.collisionPosition.marginLeft,i=e-h,j=h+b.collisionWidth-g-e;b.collisionWidth>g?i>0&&j<=0?(c=a.left+i+b.collisionWidth-g-e,a.left+=i-c):j>0&&i<=0?a.left=e:i>j?a.left=e+g-b.collisionWidth:a.left=e:i>0?a.left+=i:j>0?a.left-=j:a.left=f(a.left-h,a.left)},top:function(a,b){var c,d=b.within,e=d.isWindow?d.scrollTop:d.offset.top,g=b.within.height,h=a.top-b.collisionPosition.marginTop,i=e-h,j=h+b.collisionHeight-g-e;b.collisionHeight>g?i>0&&j<=0?(c=a.top+i+b.collisionHeight-g-e,a.top+=i-c):j>0&&i<=0?a.top=e:i>j?a.top=e+g-b.collisionHeight:a.top=e:i>0?a.top+=i:j>0?a.top-=j:a.top=f(a.top-h,a.top)}},flip:{left:function(a,b){var c,d,e=b.within,f=e.offset.left+e.scrollLeft,h=e.width,i=e.isWindow?e.scrollLeft:e.offset.left,j=a.left-b.collisionPosition.marginLeft,k=j-i,l=j+b.collisionWidth-h-i,m="left"===b.my[0]?-b.elemWidth:"right"===b.my[0]?b.elemWidth:0,n="left"===b.at[0]?b.targetWidth:"right"===b.at[0]?-b.targetWidth:0,o=-2*b.offset[0];k<0?(c=a.left+m+n+o+b.collisionWidth-h-f,(c<0||c<g(k))&&(a.left+=m+n+o)):l>0&&(d=a.left-b.collisionPosition.marginLeft+m+n+o-i,(d>0||g(d)<l)&&(a.left+=m+n+o))},top:function(a,b){var c,d,e=b.within,f=e.offset.top+e.scrollTop,h=e.height,i=e.isWindow?e.scrollTop:e.offset.top,j=a.top-b.collisionPosition.marginTop,k=j-i,l=j+b.collisionHeight-h-i,m="top"===b.my[1],n=m?-b.elemHeight:"bottom"===b.my[1]?b.elemHeight:0,o="top"===b.at[1]?b.targetHeight:"bottom"===b.at[1]?-b.targetHeight:0,p=-2*b.offset[1];k<0?(d=a.top+n+o+p+b.collisionHeight-h-f,(d<0||d<g(k))&&(a.top+=n+o+p)):l>0&&(c=a.top-b.collisionPosition.marginTop+n+o+p-i,(c>0||g(c)<l)&&(a.top+=n+o+p))}},flipfit:{left:function(){a.ui.position.flip.left.apply(this,arguments),a.ui.position.fit.left.apply(this,arguments)},top:function(){a.ui.position.flip.top.apply(this,arguments),a.ui.position.fit.top.apply(this,arguments)}}}}(),a.ui.position});;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery","../keycode","../position","../safe-active-element","../unique-id","../version","../widget"],a):a(jQuery)}(function(a){return a.widget("ui.menu",{version:"1.12.1",defaultElement:"<ul>",delay:300,options:{icons:{submenu:"ui-icon-caret-1-e"},items:"> *",menus:"ul",position:{my:"left top",at:"right top"},role:"menu",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.mouseHandled=!1,this.element.uniqueId().attr({role:this.options.role,tabIndex:0}),this._addClass("ui-menu","ui-widget ui-widget-content"),this._on({"mousedown .ui-menu-item":function(a){a.preventDefault()},"click .ui-menu-item":function(b){var c=a(b.target),d=a(a.ui.safeActiveElement(this.document[0]));!this.mouseHandled&&c.not(".ui-state-disabled").length&&(this.select(b),b.isPropagationStopped()||(this.mouseHandled=!0),c.has(".ui-menu").length?this.expand(b):!this.element.is(":focus")&&d.closest(".ui-menu").length&&(this.element.trigger("focus",[!0]),this.active&&1===this.active.parents(".ui-menu").length&&clearTimeout(this.timer)))},"mouseenter .ui-menu-item":function(b){if(!this.previousFilter){var c=a(b.target).closest(".ui-menu-item"),d=a(b.currentTarget);c[0]===d[0]&&(this._removeClass(d.siblings().children(".ui-state-active"),null,"ui-state-active"),this.focus(b,d))}},mouseleave:"collapseAll","mouseleave .ui-menu":"collapseAll",focus:function(a,b){var c=this.active||this.element.find(this.options.items).eq(0);b||this.focus(a,c)},blur:function(b){this._delay(function(){var c=!a.contains(this.element[0],a.ui.safeActiveElement(this.document[0]));c&&this.collapseAll(b)})},keydown:"_keydown"}),this.refresh(),this._on(this.document,{click:function(a){this._closeOnDocumentClick(a)&&this.collapseAll(a),this.mouseHandled=!1}})},_destroy:function(){var b=this.element.find(".ui-menu-item").removeAttr("role aria-disabled"),c=b.children(".ui-menu-item-wrapper").removeUniqueId().removeAttr("tabIndex role aria-haspopup");this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex").removeUniqueId().show(),c.children().each(function(){var b=a(this);b.data("ui-menu-submenu-caret")&&b.remove()})},_keydown:function(b){var c,d,e,f,g=!0;switch(b.keyCode){case a.ui.keyCode.PAGE_UP:this.previousPage(b);break;case a.ui.keyCode.PAGE_DOWN:this.nextPage(b);break;case a.ui.keyCode.HOME:this._move("first","first",b);break;case a.ui.keyCode.END:this._move("last","last",b);break;case a.ui.keyCode.UP:this.previous(b);break;case a.ui.keyCode.DOWN:this.next(b);break;case a.ui.keyCode.LEFT:this.collapse(b);break;case a.ui.keyCode.RIGHT:this.active&&!this.active.is(".ui-state-disabled")&&this.expand(b);break;case a.ui.keyCode.ENTER:case a.ui.keyCode.SPACE:this._activate(b);break;case a.ui.keyCode.ESCAPE:this.collapse(b);break;default:g=!1,d=this.previousFilter||"",f=!1,e=b.keyCode>=96&&b.keyCode<=105?(b.keyCode-96).toString():String.fromCharCode(b.keyCode),clearTimeout(this.filterTimer),e===d?f=!0:e=d+e,c=this._filterMenuItems(e),c=f&&c.index(this.active.next())!==-1?this.active.nextAll(".ui-menu-item"):c,c.length||(e=String.fromCharCode(b.keyCode),c=this._filterMenuItems(e)),c.length?(this.focus(b,c),this.previousFilter=e,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter}g&&b.preventDefault()},_activate:function(a){this.active&&!this.active.is(".ui-state-disabled")&&(this.active.children("[aria-haspopup='true']").length?this.expand(a):this.select(a))},refresh:function(){var b,c,d,e,f,g=this,h=this.options.icons.submenu,i=this.element.find(this.options.menus);this._toggleClass("ui-menu-icons",null,!!this.element.find(".ui-icon").length),d=i.filter(":not(.ui-menu)").hide().attr({role:this.options.role,"aria-hidden":"true","aria-expanded":"false"}).each(function(){var b=a(this),c=b.prev(),d=a("<span>").data("ui-menu-submenu-caret",!0);g._addClass(d,"ui-menu-icon","ui-icon "+h),c.attr("aria-haspopup","true").prepend(d),b.attr("aria-labelledby",c.attr("id"))}),this._addClass(d,"ui-menu","ui-widget ui-widget-content ui-front"),b=i.add(this.element),c=b.find(this.options.items),c.not(".ui-menu-item").each(function(){var b=a(this);g._isDivider(b)&&g._addClass(b,"ui-menu-divider","ui-widget-content")}),e=c.not(".ui-menu-item, .ui-menu-divider"),f=e.children().not(".ui-menu").uniqueId().attr({tabIndex:-1,role:this._itemRole()}),this._addClass(e,"ui-menu-item")._addClass(f,"ui-menu-item-wrapper"),c.filter(".ui-state-disabled").attr("aria-disabled","true"),this.active&&!a.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:"menuitem",listbox:"option"}[this.options.role]},_setOption:function(a,b){if("icons"===a){var c=this.element.find(".ui-menu-icon");this._removeClass(c,null,this.options.icons.submenu)._addClass(c,null,b.submenu)}this._super(a,b)},_setOptionDisabled:function(a){this._super(a),this.element.attr("aria-disabled",String(a)),this._toggleClass(null,"ui-state-disabled",!!a)},focus:function(a,b){var c,d,e;this.blur(a,a&&"focus"===a.type),this._scrollIntoView(b),this.active=b.first(),d=this.active.children(".ui-menu-item-wrapper"),this._addClass(d,null,"ui-state-active"),this.options.role&&this.element.attr("aria-activedescendant",d.attr("id")),e=this.active.parent().closest(".ui-menu-item").children(".ui-menu-item-wrapper"),this._addClass(e,null,"ui-state-active"),a&&"keydown"===a.type?this._close():this.timer=this._delay(function(){this._close()},this.delay),c=b.children(".ui-menu"),c.length&&a&&/^mouse/.test(a.type)&&this._startOpening(c),this.activeMenu=b.parent(),this._trigger("focus",a,{item:b})},_scrollIntoView:function(b){var c,d,e,f,g,h;this._hasScroll()&&(c=parseFloat(a.css(this.activeMenu[0],"borderTopWidth"))||0,d=parseFloat(a.css(this.activeMenu[0],"paddingTop"))||0,e=b.offset().top-this.activeMenu.offset().top-c-d,f=this.activeMenu.scrollTop(),g=this.activeMenu.height(),h=b.outerHeight(),e<0?this.activeMenu.scrollTop(f+e):e+h>g&&this.activeMenu.scrollTop(f+e-g+h))},blur:function(a,b){b||clearTimeout(this.timer),this.active&&(this._removeClass(this.active.children(".ui-menu-item-wrapper"),null,"ui-state-active"),this._trigger("blur",a,{item:this.active}),this.active=null)},_startOpening:function(a){clearTimeout(this.timer),"true"===a.attr("aria-hidden")&&(this.timer=this._delay(function(){this._close(),this._open(a)},this.delay))},_open:function(b){var c=a.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(".ui-menu").not(b.parents(".ui-menu")).hide().attr("aria-hidden","true"),b.show().removeAttr("aria-hidden").attr("aria-expanded","true").position(c)},collapseAll:function(b,c){clearTimeout(this.timer),this.timer=this._delay(function(){var d=c?this.element:a(b&&b.target).closest(this.element.find(".ui-menu"));d.length||(d=this.element),this._close(d),this.blur(b),this._removeClass(d.find(".ui-state-active"),null,"ui-state-active"),this.activeMenu=d},this.delay)},_close:function(a){a||(a=this.active?this.active.parent():this.element),a.find(".ui-menu").hide().attr("aria-hidden","true").attr("aria-expanded","false")},_closeOnDocumentClick:function(b){return!a(b.target).closest(".ui-menu").length},_isDivider:function(a){return!/[^\-\u2014\u2013\s]/.test(a.text())},collapse:function(a){var b=this.active&&this.active.parent().closest(".ui-menu-item",this.element);b&&b.length&&(this._close(),this.focus(a,b))},expand:function(a){var b=this.active&&this.active.children(".ui-menu ").find(this.options.items).first();b&&b.length&&(this._open(b.parent()),this._delay(function(){this.focus(a,b)}))},next:function(a){this._move("next","first",a)},previous:function(a){this._move("prev","last",a)},isFirstItem:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},isLastItem:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},_move:function(a,b,c){var d;this.active&&(d="first"===a||"last"===a?this.active["first"===a?"prevAll":"nextAll"](".ui-menu-item").eq(-1):this.active[a+"All"](".ui-menu-item").eq(0)),d&&d.length&&this.active||(d=this.activeMenu.find(this.options.items)[b]()),this.focus(c,d)},nextPage:function(b){var c,d,e;return this.active?void(this.isLastItem()||(this._hasScroll()?(d=this.active.offset().top,e=this.element.height(),this.active.nextAll(".ui-menu-item").each(function(){return c=a(this),c.offset().top-d-e<0}),this.focus(b,c)):this.focus(b,this.activeMenu.find(this.options.items)[this.active?"last":"first"]()))):void this.next(b)},previousPage:function(b){var c,d,e;return this.active?void(this.isFirstItem()||(this._hasScroll()?(d=this.active.offset().top,e=this.element.height(),this.active.prevAll(".ui-menu-item").each(function(){return c=a(this),c.offset().top-d+e>0}),this.focus(b,c)):this.focus(b,this.activeMenu.find(this.options.items).first()))):void this.next(b)},_hasScroll:function(){return this.element.outerHeight()<this.element.prop("scrollHeight")},select:function(b){this.active=this.active||a(b.target).closest(".ui-menu-item");var c={item:this.active};this.active.has(".ui-menu").length||this.collapseAll(b,!0),this._trigger("select",b,c)},_filterMenuItems:function(b){var c=b.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&"),d=new RegExp("^"+c,"i");return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function(){return d.test(a.trim(a(this).children(".ui-menu-item-wrapper").text()))})}})});;
/*! jQuery UI - v1.12.1 - 2017-03-31
* http://jqueryui.com
* Copyright jQuery Foundation and other contributors; Licensed  */
!function(a){"function"==typeof define&&define.amd?define(["jquery","./menu","../keycode","../position","../safe-active-element","../version","../widget"],a):a(jQuery)}(function(a){return a.widget("ui.autocomplete",{version:"1.12.1",defaultElement:"<input>",options:{appendTo:null,autoFocus:!1,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},requestIndex:0,pending:0,_create:function(){var b,c,d,e=this.element[0].nodeName.toLowerCase(),f="textarea"===e,g="input"===e;this.isMultiLine=f||!g&&this._isContentEditable(this.element),this.valueMethod=this.element[f||g?"val":"text"],this.isNewMenu=!0,this._addClass("ui-autocomplete-input"),this.element.attr("autocomplete","off"),this._on(this.element,{keydown:function(e){if(this.element.prop("readOnly"))return b=!0,d=!0,void(c=!0);b=!1,d=!1,c=!1;var f=a.ui.keyCode;switch(e.keyCode){case f.PAGE_UP:b=!0,this._move("previousPage",e);break;case f.PAGE_DOWN:b=!0,this._move("nextPage",e);break;case f.UP:b=!0,this._keyEvent("previous",e);break;case f.DOWN:b=!0,this._keyEvent("next",e);break;case f.ENTER:this.menu.active&&(b=!0,e.preventDefault(),this.menu.select(e));break;case f.TAB:this.menu.active&&this.menu.select(e);break;case f.ESCAPE:this.menu.element.is(":visible")&&(this.isMultiLine||this._value(this.term),this.close(e),e.preventDefault());break;default:c=!0,this._searchTimeout(e)}},keypress:function(d){if(b)return b=!1,void(this.isMultiLine&&!this.menu.element.is(":visible")||d.preventDefault());if(!c){var e=a.ui.keyCode;switch(d.keyCode){case e.PAGE_UP:this._move("previousPage",d);break;case e.PAGE_DOWN:this._move("nextPage",d);break;case e.UP:this._keyEvent("previous",d);break;case e.DOWN:this._keyEvent("next",d)}}},input:function(a){return d?(d=!1,void a.preventDefault()):void this._searchTimeout(a)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(a){return this.cancelBlur?void delete this.cancelBlur:(clearTimeout(this.searching),this.close(a),void this._change(a))}}),this._initSource(),this.menu=a("<ul>").appendTo(this._appendTo()).menu({role:null}).hide().menu("instance"),this._addClass(this.menu.element,"ui-autocomplete","ui-front"),this._on(this.menu.element,{mousedown:function(b){b.preventDefault(),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur,this.element[0]!==a.ui.safeActiveElement(this.document[0])&&this.element.trigger("focus")})},menufocus:function(b,c){var d,e;return this.isNewMenu&&(this.isNewMenu=!1,b.originalEvent&&/^mouse/.test(b.originalEvent.type))?(this.menu.blur(),void this.document.one("mousemove",function(){a(b.target).trigger(b.originalEvent)})):(e=c.item.data("ui-autocomplete-item"),!1!==this._trigger("focus",b,{item:e})&&b.originalEvent&&/^key/.test(b.originalEvent.type)&&this._value(e.value),d=c.item.attr("aria-label")||e.value,void(d&&a.trim(d).length&&(this.liveRegion.children().hide(),a("<div>").text(d).appendTo(this.liveRegion))))},menuselect:function(b,c){var d=c.item.data("ui-autocomplete-item"),e=this.previous;this.element[0]!==a.ui.safeActiveElement(this.document[0])&&(this.element.trigger("focus"),this.previous=e,this._delay(function(){this.previous=e,this.selectedItem=d})),!1!==this._trigger("select",b,{item:d})&&this._value(d.value),this.term=this._value(),this.close(b),this.selectedItem=d}}),this.liveRegion=a("<div>",{role:"status","aria-live":"assertive","aria-relevant":"additions"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,"ui-helper-hidden-accessible"),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeAttr("autocomplete"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(a,b){this._super(a,b),"source"===a&&this._initSource(),"appendTo"===a&&this.menu.element.appendTo(this._appendTo()),"disabled"===a&&b&&this.xhr&&this.xhr.abort()},_isEventTargetInWidget:function(b){var c=this.menu.element[0];return b.target===this.element[0]||b.target===c||a.contains(c,b.target)},_closeOnClickOutside:function(a){this._isEventTargetInWidget(a)||this.close()},_appendTo:function(){var b=this.options.appendTo;return b&&(b=b.jquery||b.nodeType?a(b):this.document.find(b).eq(0)),b&&b[0]||(b=this.element.closest(".ui-front, dialog")),b.length||(b=this.document[0].body),b},_initSource:function(){var b,c,d=this;a.isArray(this.options.source)?(b=this.options.source,this.source=function(c,d){d(a.ui.autocomplete.filter(b,c.term))}):"string"==typeof this.options.source?(c=this.options.source,this.source=function(b,e){d.xhr&&d.xhr.abort(),d.xhr=a.ajax({url:c,data:b,dataType:"json",success:function(a){e(a)},error:function(){e([])}})}):this.source=this.options.source},_searchTimeout:function(a){clearTimeout(this.searching),this.searching=this._delay(function(){var b=this.term===this._value(),c=this.menu.element.is(":visible"),d=a.altKey||a.ctrlKey||a.metaKey||a.shiftKey;b&&(!b||c||d)||(this.selectedItem=null,this.search(null,a))},this.options.delay)},search:function(a,b){return a=null!=a?a:this._value(),this.term=this._value(),a.length<this.options.minLength?this.close(b):this._trigger("search",b)!==!1?this._search(a):void 0},_search:function(a){this.pending++,this._addClass("ui-autocomplete-loading"),this.cancelSearch=!1,this.source({term:a},this._response())},_response:function(){var b=++this.requestIndex;return a.proxy(function(a){b===this.requestIndex&&this.__response(a),this.pending--,this.pending||this._removeClass("ui-autocomplete-loading")},this)},__response:function(a){a&&(a=this._normalize(a)),this._trigger("response",null,{content:a}),!this.options.disabled&&a&&a.length&&!this.cancelSearch?(this._suggest(a),this._trigger("open")):this._close()},close:function(a){this.cancelSearch=!0,this._close(a)},_close:function(a){this._off(this.document,"mousedown"),this.menu.element.is(":visible")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!0,this._trigger("close",a))},_change:function(a){this.previous!==this._value()&&this._trigger("change",a,{item:this.selectedItem})},_normalize:function(b){return b.length&&b[0].label&&b[0].value?b:a.map(b,function(b){return"string"==typeof b?{label:b,value:b}:a.extend({},b,{label:b.label||b.value,value:b.value||b.label})})},_suggest:function(b){var c=this.menu.element.empty();this._renderMenu(c,b),this.isNewMenu=!0,this.menu.refresh(),c.show(),this._resizeMenu(),c.position(a.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next(),this._on(this.document,{mousedown:"_closeOnClickOutside"})},_resizeMenu:function(){var a=this.menu.element;a.outerWidth(Math.max(a.width("").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(b,c){var d=this;a.each(c,function(a,c){d._renderItemData(b,c)})},_renderItemData:function(a,b){return this._renderItem(a,b).data("ui-autocomplete-item",b)},_renderItem:function(b,c){return a("<li>").append(a("<div>").text(c.label)).appendTo(b)},_move:function(a,b){return this.menu.element.is(":visible")?this.menu.isFirstItem()&&/^previous/.test(a)||this.menu.isLastItem()&&/^next/.test(a)?(this.isMultiLine||this._value(this.term),void this.menu.blur()):void this.menu[a](b):void this.search(null,b)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(a,b){this.isMultiLine&&!this.menu.element.is(":visible")||(this._move(a,b),b.preventDefault())},_isContentEditable:function(a){if(!a.length)return!1;var b=a.prop("contentEditable");return"inherit"===b?this._isContentEditable(a.parent()):"true"===b}}),a.extend(a.ui.autocomplete,{escapeRegex:function(a){return a.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")},filter:function(b,c){var d=new RegExp(a.ui.autocomplete.escapeRegex(c),"i");return a.grep(b,function(a){return d.test(a.label||a.value||a)})}}),a.widget("ui.autocomplete",a.ui.autocomplete,{options:{messages:{noResults:"No search results.",results:function(a){return a+(a>1?" results are":" result is")+" available, use up and down arrow keys to navigate."}}},__response:function(b){var c;this._superApply(arguments),this.options.disabled||this.cancelSearch||(c=b&&b.length?this.options.messages.results(b.length):this.options.messages.noResults,this.liveRegion.children().hide(),a("<div>").text(c).appendTo(this.liveRegion))}}),a.ui.autocomplete});;
/**
 * @file
 * Expands the behaviour of the default autocompletion.
 */

(function ($, Drupal, drupalSettings) {

  'use strict';

  // As a safety precaution, bail if the Drupal Core autocomplete framework is
  // not present.
  if (!Drupal.autocomplete) {
    return;
  }

  var autocomplete = {};

  /**
   * Retrieves the custom settings for an autocomplete-enabled input field.
   *
   * @param {HTMLElement} input
   *   The input field.
   * @param {object} globalSettings
   *   The object containing global settings. If none is passed, drupalSettings
   *   is used instead.
   *
   * @return {object}
   *   The effective settings for the given input fields, with defaults set if
   *   applicable.
   */
  autocomplete.getSettings = function (input, globalSettings) {
    globalSettings = globalSettings || drupalSettings || {};
    // Set defaults for all known settings.
    var settings = {
      auto_submit: false,
      delay: 0,
      min_length: 1,
      selector: ':submit',
    };
    var search = $(input).data('search-api-autocomplete-search');
    if (search
        && globalSettings.search_api_autocomplete
        && globalSettings.search_api_autocomplete[search]) {
      $.extend(settings, globalSettings.search_api_autocomplete[search]);
    }
    return settings;
  };

  /**
   * Attaches our custom autocomplete settings to all affected fields.
   *
   * @type {Drupal~behavior}
   *
   * @prop {Drupal~behaviorAttach} attach
   *   Attaches the autocomplete behaviors.
   */
  Drupal.behaviors.searchApiAutocomplete = {
    attach: function (context, settings) {
      // Find all our fields with autocomplete settings
      $(context)
        .find('.ui-autocomplete-input[data-search-api-autocomplete-search]')
        .once('search-api-autocomplete')
        .each(function () {
          var uiAutocomplete = $(this).data('ui-autocomplete');
          if (!uiAutocomplete) {
            return;
          }
          var $element = uiAutocomplete.menu.element;
          $element.addClass('search-api-autocomplete-search');
          var elementSettings = autocomplete.getSettings(this, settings);
          if (elementSettings['delay']) {
            uiAutocomplete.options['delay'] = elementSettings['delay'];
          }
          if (elementSettings['min_length']) {
            uiAutocomplete.options['minLength'] = elementSettings['min_length'];
          }
          // Override the "select" callback of the jQuery UI autocomplete.
          var oldSelect = uiAutocomplete.options.select;
          uiAutocomplete.options.select = function (event, ui) {
            // If this is a URL suggestion, instead of autocompleting we
            // redirect the user to that URL.
            if (ui.item.url) {
              location.href = ui.item.url;
              return false;
            }

            var ret = oldSelect.apply(this, arguments);

            // If auto-submit is enabled, submit the form.
            if (elementSettings['auto_submit'] && elementSettings['selector']) {
              $(elementSettings['selector'], this.form).trigger('click');
            }

            return ret;
          };
        });
    }
  };

  Drupal.SearchApiAutocomplete = autocomplete;

})(jQuery, Drupal, drupalSettings);
;
